<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>YYText 是如何工作的</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>YYText 是如何工作的 | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="YYText 是如何工作的" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="zh" />
<meta name="description" content="上面的阴影效果是用以下代码实现的：" />
<meta property="og:description" content="上面的阴影效果是用以下代码实现的：" />
<link rel="canonical" href="https://lzwjava.github.io/yytext-zh" />
<meta property="og:url" content="https://lzwjava.github.io/yytext-zh" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-24T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="YYText 是如何工作的" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-24T00:00:00+08:00","datePublished":"2016-05-24T00:00:00+08:00","description":"上面的阴影效果是用以下代码实现的：","headline":"YYText 是如何工作的","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/yytext-zh"},"url":"https://lzwjava.github.io/yytext-zh"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=1344a5f96828f87a167f517becc5fe052a2341e7">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=1344a5f96828f87a167f517becc5fe052a2341e7" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       YYText 是如何工作的 | 原创
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/zh/2016-05-24-yytext-zh.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postszh2016-05-24-yytext-zh.md</span> -->
      

      <!-- <span>2016-05-24-yytext-zh.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/yytext-en" >English</option>
        <option value="/yytext-zh" selected>中文</option>
        <option value="/yytext-ja" >日本語</option>
        <option value="/yytext-es" >Español</option>
        <option value="/yytext-hi" >हिंदी</option>
        <option value="/yytext-fr" >Français</option>
        <option value="/yytext-de" >Deutsch</option>
        <option value="/yytext-ar" >العربية</option>
        <option value="/yytext-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>上面的阴影效果是用以下代码实现的：</p>

<p>可以看到先生成了 <code class="language-plaintext highlighter-rouge">YYTextShadow</code>， 然后赋值给了 <code class="language-plaintext highlighter-rouge">attributedString</code> 的 <code class="language-plaintext highlighter-rouge">yy_textShadow</code>，然后再把 <code class="language-plaintext highlighter-rouge">attributedString</code> 赋值到 <code class="language-plaintext highlighter-rouge">YYLabel</code> 里面，接着把 <code class="language-plaintext highlighter-rouge">YYLabel</code> 加入到 <code class="language-plaintext highlighter-rouge">UIView</code> 里来显示。跟踪 <code class="language-plaintext highlighter-rouge">yy_textShadow</code> 发现，主要是把 <code class="language-plaintext highlighter-rouge">textShadow</code> 绑定到了 <code class="language-plaintext highlighter-rouge">NSAttributedString</code> 的 attribute 里，key 是 <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code>，值是 <code class="language-plaintext highlighter-rouge">textShadow</code>，也就是先把 shadow 存起来，后来再使用。用 Shift + Command + J 快速跳转到定义处：</p>

<p>这里有个 <code class="language-plaintext highlighter-rouge">addAttribute</code>，它在 <code class="language-plaintext highlighter-rouge">NSAttributedString.h</code> 里定义：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAttribute</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">value</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">range</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</code></pre></div></div>

<p>说明可以赋值任意的键值对给它。而 <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> 的定义是一个普通的字符串，这意味着先是把 shadow 信息存起来，然后后面再使用。我们全局搜索一下 <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code>。</p>

<p>然后我们来到 <code class="language-plaintext highlighter-rouge">YYTextLayout</code> 里的 <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> 函数：</p>

<p><code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> 是说改变一个 Context 里的原点坐标，所以</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>是说要把绘制的上下文移动到 <code class="language-plaintext highlighter-rouge">point</code> 点。我们还是先搞清楚哪里调用了 <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>，发现是在 <code class="language-plaintext highlighter-rouge">drawInContext</code> 里调用的。</p>

<p>在 <code class="language-plaintext highlighter-rouge">drawInContext</code> 里，依次绘制方块的边框，然后绘制背景边框、阴影、下划线、文字、附属物、内阴影、删除线、文字边框、调试线。</p>

<p>那么到底哪里用了 <code class="language-plaintext highlighter-rouge">drawInContext</code> 呢？可以看到里面有个参数 <code class="language-plaintext highlighter-rouge">YYTextDebugOption</code>，所以这个函数一定不是系统的回调，而是 YYText 里面自己调用的。</p>

<p>按住 Ctrl + 1 弹出快捷键，发现有四个地方调用了它。</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext:size:debug</code> 仍然是 YYText 自己的调用，因为 <code class="language-plaintext highlighter-rouge">debug</code> 的类型是 <code class="language-plaintext highlighter-rouge">YYTextDebugOption *</code>， 是 YY 自身的。<code class="language-plaintext highlighter-rouge">newAsyncTask</code> 不像是系统的调用，<code class="language-plaintext highlighter-rouge">addAttachmentToView:layer:</code> 同理，所以极有可能是 <code class="language-plaintext highlighter-rouge">drawRect:</code>。</p>

<p>果然是，看右边的快速帮助，有详尽的解释，帮助的下面也说明了是在 <code class="language-plaintext highlighter-rouge">UIView</code> 里定义的。再看 <code class="language-plaintext highlighter-rouge">YYTextContainerView</code>，它是继承了 <code class="language-plaintext highlighter-rouge">UIView</code> 的。</p>

<p>所以 <code class="language-plaintext highlighter-rouge">YYLabel</code> 是用了 <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> 咯？然后让系统调用 <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> 里的 <code class="language-plaintext highlighter-rouge">drawRect:</code> 画出来？</p>

<p>奇怪，<code class="language-plaintext highlighter-rouge">YYLabel</code> 可继承了 <code class="language-plaintext highlighter-rouge">UIView</code>。所以，YYText 里应该有两套东西！一套 <code class="language-plaintext highlighter-rouge">YYLabel</code>，一套 <code class="language-plaintext highlighter-rouge">YYTextView</code>，像 <code class="language-plaintext highlighter-rouge">UILabel</code> 和 <code class="language-plaintext highlighter-rouge">UITextView</code> 一样。接着我们再回去看之前的 <code class="language-plaintext highlighter-rouge">YYLabel</code> 的 <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code>，</p>

<p>很长，在中间的位置调用了 <code class="language-plaintext highlighter-rouge">YYTextLayout</code> 里的 <code class="language-plaintext highlighter-rouge">drawInContext</code>。<code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code>，它又是在哪里调用的呢？</p>

<p>在第二行被调用了。所以可以简单地理解为 <code class="language-plaintext highlighter-rouge">YYLabel</code> 用了异步来绘制文本。而 <code class="language-plaintext highlighter-rouge">_displayAsync</code> 被上面的 <code class="language-plaintext highlighter-rouge">display</code> 调用了。看 <code class="language-plaintext highlighter-rouge">display</code> 的文档，说是系统会在恰当的时间来调用来更新 layer 的内容，你不要直接去调用它。我们也可以给它打个断点。</p>

<p>说明 <code class="language-plaintext highlighter-rouge">display</code> 是在 <code class="language-plaintext highlighter-rouge">CALayer</code> 的一次事务中调用的。为何用事务，大概是因为想批量更新，效率高点吧？不像是数据库里的回滚需求。</p>

<p><code class="language-plaintext highlighter-rouge">display</code> 的系统文档还说，如果你想你的 layer 绘制不一样，那你可以复写这个方法，来实现你自己的绘制。</p>

<p>所以，我们简单的有了一点思路。<code class="language-plaintext highlighter-rouge">YYLabel</code> 通过复写 <code class="language-plaintext highlighter-rouge">UIView</code> 的 <code class="language-plaintext highlighter-rouge">display</code> 方法，来异步绘制自己的阴影等各种效果，阴影效果先保存在了 <code class="language-plaintext highlighter-rouge">YYLabel</code> 的 <code class="language-plaintext highlighter-rouge">attributedText</code> 里的 attribute 中，在 <code class="language-plaintext highlighter-rouge">display</code> 中绘制的时候再取出来，绘制的时候用了系统的 CoreGraphics 框架。</p>

<p>理清了一些思路后，会发现，真正强大的是什么？一边是把这么多效果、异步调用等组织起来，一边是对底层 CoreGraphics 框架熟练运用。所以对前面的代码组织有了些了解后，接着我们深入到 CoreGraphics 框架上去。看看是怎么绘制上去的。</p>

<p>让我们重新回到 <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>。</p>

<p>这里，<code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> 和 <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> 包围起了一段绘制的代码。<code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> 的意思是说，把当前的绘图状态拷贝一份，放到绘制栈里。每个绘制的 Context 都维护着一个绘制栈。我也不清楚，里面栈到底是怎么操作的。先暂且理解为绘制 Context 前要调用 <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code>，绘制 Context 后要调用 <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code>，之后中间的绘制就能有效地出现在 Context 里。<code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> 是移动到 Context 移动到相应的位置。先是移动到 <code class="language-plaintext highlighter-rouge">point.x</code> 和 <code class="language-plaintext highlighter-rouge">point.y</code> ，绘制的相应位置，至于后面移动到 0 和 <code class="language-plaintext highlighter-rouge">size.height</code>，倒不清楚了，后续再看看。接着取出了 <code class="language-plaintext highlighter-rouge">lines</code>，执行了 <code class="language-plaintext highlighter-rouge">for</code> 循环。</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> 是什么？发现在 <code class="language-plaintext highlighter-rouge">YYTextLayout</code> 里的 <code class="language-plaintext highlighter-rouge">(YYTextLayout *)layoutWithContainer:(YYTextContainer *)container text:(NSAttributedString *)text range:(NSRange)range </code> 赋值的。</p>

<p>接着翻到这个函数的定义处：</p>

<p>这个函数非常长，367 到 861 行，500 行代码！看了头尾，可见它的用处就是得到这些变量。<code class="language-plaintext highlighter-rouge">lines</code> 是怎么得到的呢？</p>

<p>可以见到在一个大的 <code class="language-plaintext highlighter-rouge">for</code> 循环里把一条一条 <code class="language-plaintext highlighter-rouge">line</code> 加入到 <code class="language-plaintext highlighter-rouge">lines</code> 里。那 <code class="language-plaintext highlighter-rouge">lineCount</code> 是怎么得到的呢？</p>

<p>第 472 行创建了一个 <code class="language-plaintext highlighter-rouge">framesetter</code> 对象，<code class="language-plaintext highlighter-rouge">text</code> 参数是 <code class="language-plaintext highlighter-rouge">NSAttributedString</code>，接着在 <code class="language-plaintext highlighter-rouge">frameSetter</code> 对象中创建了一个 <code class="language-plaintext highlighter-rouge">CTFrameRef</code>，接着从 <code class="language-plaintext highlighter-rouge">CTFrameRef</code> 得到了 <code class="language-plaintext highlighter-rouge">lines</code>。 <code class="language-plaintext highlighter-rouge">line</code> 到底是什么呢？我们给它打个断点。</p>

<p>发现，<code class="language-plaintext highlighter-rouge">shadow</code> 这个字的 <code class="language-plaintext highlighter-rouge">lineCount = 2</code>，并不是我们想象中的字母个数。</p>

<p>所以猜测，白色的 <code class="language-plaintext highlighter-rouge">Shadow</code> 整个是一条 <code class="language-plaintext highlighter-rouge">line</code>，阴影也是一条 <code class="language-plaintext highlighter-rouge">line</code>？</p>

<p>YYText 里有好几个例子，只显示其中一种效果，把其它的代码注释掉。发现很奇怪，Shadow 的 <code class="language-plaintext highlighter-rouge">lineCount = 2</code>，Multiple Shadows 的 <code class="language-plaintext highlighter-rouge">lineCount</code> 也是 2，可 Multiple Shadows 还有内阴影啊，应该是 3 条啊？</p>

<p>去找 CTLine 的苹果文档，说 CTLine 代表着一行的文本，一个 CTLine 对象包含着一组的 <code class="language-plaintext highlighter-rouge">glyph runs</code>。所以就是简单的行数而已！看上面的断点截图，刚刚 <code class="language-plaintext highlighter-rouge">shadow</code> 之所以为 2 ，是因为它的文本是 <code class="language-plaintext highlighter-rouge">shadow\n\n</code>，看刚刚，<code class="language-plaintext highlighter-rouge">\n\n</code> 是故意加的，为了显示美观：</p>

<p>所以 <code class="language-plaintext highlighter-rouge">shadow\n\n</code> 就是两行文本。CTLine 就是我们平时说的行。接着回去看我们的 <code class="language-plaintext highlighter-rouge">lineCount</code>：</p>

<p>这里得到 <code class="language-plaintext highlighter-rouge">CTLines</code> 数组，从里面的个数，然后如果 <code class="language-plaintext highlighter-rouge">lineCount</code> 大于 0 的话，得到每行的坐标原点。好了，有了 <code class="language-plaintext highlighter-rouge">lineCount</code>，我们接着看 <code class="language-plaintext highlighter-rouge">for</code> 循环。</p>

<p>从 <code class="language-plaintext highlighter-rouge">ctLines</code> 数组里得到 <code class="language-plaintext highlighter-rouge">CTLine</code>，接着得到 <code class="language-plaintext highlighter-rouge">YYTextLine</code> 对象，然后加入到 <code class="language-plaintext highlighter-rouge">lines</code> 数组中。然后做一些 <code class="language-plaintext highlighter-rouge">line</code> 的 frame 计算。<code class="language-plaintext highlighter-rouge">YYTextLine</code> 的构造函数很简单，先保存着位置、是否垂直排版、<code class="language-plaintext highlighter-rouge">CTLine</code> 对象：</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> 搞清楚之后，我们再回去之前的 <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> 中去：</p>

<p>这下代码简单了。先获取到行数，遍历它，然后取得 <code class="language-plaintext highlighter-rouge">GlyphRuns</code> 数组，再遍历它，<code class="language-plaintext highlighter-rouge">GlyphRun</code> 可以理解为一个图元，或者绘制单元。然后从中得到 <code class="language-plaintext highlighter-rouge">attributes</code> 数组，用我们之前的 <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code>，获取我们一开始赋值的 <code class="language-plaintext highlighter-rouge">shadow</code>，接着开始绘制阴影：</p>

<p>一个 <code class="language-plaintext highlighter-rouge">while</code> 循环，不断绘制子阴影。调用 <code class="language-plaintext highlighter-rouge">CGContextSetShadowWithColor</code> 设好阴影的位移、半径、颜色。接着调用 <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> 来真正的绘制。<code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> 被三个地方调用了：</p>

<p>用来绘制内阴影和文本阴影以及文本。说明它是个通用方法，用来画 <code class="language-plaintext highlighter-rouge">Run</code> 这个对象。</p>

<p>一开始获取文字的变换矩阵，用 <code class="language-plaintext highlighter-rouge">runTextMatrixIsID</code> 来看看它是否原地不变，如果不是垂直排版或没有设置图元转换的话，就直接上来画。调用 <code class="language-plaintext highlighter-rouge">CTRunDraw</code> 来画 <code class="language-plaintext highlighter-rouge">run</code> 对象。接着断点发现，绘制一开始那个阴影时只进入了 <code class="language-plaintext highlighter-rouge">if</code> 里面，没有进入 <code class="language-plaintext highlighter-rouge">else</code> 里面。</p>

<p>所以我们的阴影绘制就到此结束了！</p>

<p>总结一下，<code class="language-plaintext highlighter-rouge">YYLabel</code> 先把阴影等效果保存在 <code class="language-plaintext highlighter-rouge">attributedText</code> 里的 attributes，复写了 <code class="language-plaintext highlighter-rouge">UIView</code> 的 <code class="language-plaintext highlighter-rouge">display</code> 方法，在 <code class="language-plaintext highlighter-rouge">display</code> 中进行异步绘制，用 <code class="language-plaintext highlighter-rouge">CoreText</code> 框架得到 <code class="language-plaintext highlighter-rouge">CTLine</code>、<code class="language-plaintext highlighter-rouge">CTRun</code> 对象，从 <code class="language-plaintext highlighter-rouge">CTRun</code> 获取到 attributes，之后再根据 attributes 里的各属性，用 <code class="language-plaintext highlighter-rouge">CoreGraphics</code> 框架把 <code class="language-plaintext highlighter-rouge">CTRun</code> 对象绘制到 Context 中。</p>

<p>理解还是不够，等后续再来品读。不觉感叹 YY 实在太强了！今天理了理思路，让自己边写边读代码，不至于枯燥，同时供大家参考。得去睡觉了。</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-zh" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
