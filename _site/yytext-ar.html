<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>كيف يعمل YYText</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>كيف يعمل YYText | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="كيف يعمل YYText" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="ar" />
<meta name="description" content="تم تحقيق تأثير الظل أعلاه باستخدام الكود التالي:" />
<meta property="og:description" content="تم تحقيق تأثير الظل أعلاه باستخدام الكود التالي:" />
<link rel="canonical" href="https://lzwjava.github.io/yytext-ar" />
<meta property="og:url" content="https://lzwjava.github.io/yytext-ar" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-24T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="كيف يعمل YYText" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-24T00:00:00+08:00","datePublished":"2016-05-24T00:00:00+08:00","description":"تم تحقيق تأثير الظل أعلاه باستخدام الكود التالي:","headline":"كيف يعمل YYText","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/yytext-ar"},"url":"https://lzwjava.github.io/yytext-ar"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=14043099952524e763c1e5f4ef6c2245832fd05d">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=14043099952524e763c1e5f4ef6c2245832fd05d" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       كيف يعمل YYText | أصلي، ترجم بواسطة AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/ar/2016-05-24-yytext-ar.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsar2016-05-24-yytext-ar.md</span> -->
      

      <!-- <span>2016-05-24-yytext-ar.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/yytext-en" >English</option>
        <option value="/yytext-zh" >中文</option>
        <option value="/yytext-ja" >日本語</option>
        <option value="/yytext-es" >Español</option>
        <option value="/yytext-hi" >हिंदी</option>
        <option value="/yytext-fr" >Français</option>
        <option value="/yytext-de" >Deutsch</option>
        <option value="/yytext-ar" selected>العربية</option>
        <option value="/yytext-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>تم تحقيق تأثير الظل أعلاه باستخدام الكود التالي:</p>

<p>يمكننا أن نرى أنه تم إنشاء <code class="language-plaintext highlighter-rouge">YYTextShadow</code> أولاً، ثم تم تعيينه لخاصية <code class="language-plaintext highlighter-rouge">yy_textShadow</code> في <code class="language-plaintext highlighter-rouge">attributedString</code>، وبعد ذلك تم تعيين <code class="language-plaintext highlighter-rouge">attributedString</code> إلى <code class="language-plaintext highlighter-rouge">YYLabel</code>، ثم تم إضافة <code class="language-plaintext highlighter-rouge">YYLabel</code> إلى <code class="language-plaintext highlighter-rouge">UIView</code> لعرضه. عند تتبع <code class="language-plaintext highlighter-rouge">yy_textShadow</code>، نجد أنه يتم بشكل أساسي ربط <code class="language-plaintext highlighter-rouge">textShadow</code> بسمة <code class="language-plaintext highlighter-rouge">NSAttributedString</code> باستخدام المفتاح <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> والقيمة <code class="language-plaintext highlighter-rouge">textShadow</code>، أي أنه يتم تخزين الظل أولاً ثم استخدامه لاحقًا. يمكنك الانتقال بسرعة إلى مكان التعريف باستخدام Shift + Command + J:</p>

<p>هناك دالة تُسمى <code class="language-plaintext highlighter-rouge">addAttribute</code>، وهي مُعرَّفة في ملف <code class="language-plaintext highlighter-rouge">NSAttributedString.h</code>:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAttribute</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">value</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">range</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>ترجمة:</strong></p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAttribute</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">value</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">range</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>ملاحظة:</strong> الكود الموجود في الكتلة البرمجية هو كود Objective-C، ولا يتم ترجمته.</p>

<p>التفسير هو أنه يمكن تعيين أي أزواج من المفاتيح والقيم له. بينما تعريف <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> هو عبارة عن سلسلة نصية عادية، مما يعني أنه يتم أولاً تخزين معلومات الظل، ثم يتم استخدامها لاحقًا. دعونا نبحث بشكل شامل عن <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code>.</p>

<p>ثم نصل إلى الدالة <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> داخل <code class="language-plaintext highlighter-rouge">YYTextLayout</code>:</p>

<p><code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> تعني تغيير إحداثيات نقطة الأصل في Context، لذا</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>المقصود هو نقل سياق الرسم إلى النقطة <code class="language-plaintext highlighter-rouge">point</code>. دعونا أولاً نحدد مكان استدعاء <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>، ونجد أنه يتم استدعاؤه داخل <code class="language-plaintext highlighter-rouge">drawInContext</code>.</p>

<p>في <code class="language-plaintext highlighter-rouge">drawInContext</code>، يتم رسم حدود المربع أولاً، ثم يتم رسم حدود الخلفية، الظل، الخط السفلي، النص، الملحقات، الظل الداخلي، الخط المشطوب، حدود النص، وخطوط التصحيح بالترتيب.</p>

<p>إذن، أين تم استخدام <code class="language-plaintext highlighter-rouge">drawInContext</code> بالضبط؟ يمكننا أن نرى أن هناك معلمة تسمى <code class="language-plaintext highlighter-rouge">YYTextDebugOption</code>، لذا فإن هذه الوظيفة بالتأكيد ليست رد فعل من النظام، بل هي وظيفة يتم استدعاؤها داخل YYText نفسها.</p>

<p>اضغط على Ctrl + 1 لإظهار قائمة الاختصارات، ستلاحظ وجود أربعة أماكن تم استدعاؤها فيها.</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext:size:debug</code> لا يزال استدعاءً خاصًا بـ YYText، لأن نوع <code class="language-plaintext highlighter-rouge">debug</code> هو <code class="language-plaintext highlighter-rouge">YYTextDebugOption *</code>، وهو خاص بـ YY. <code class="language-plaintext highlighter-rouge">newAsyncTask</code> لا يبدو كاستدعاء نظامي، وكذلك <code class="language-plaintext highlighter-rouge">addAttachmentToView:layer:</code>، لذا من المرجح أن يكون <code class="language-plaintext highlighter-rouge">drawRect:</code>.</p>

<p>بالفعل، بالنظر إلى المساعدة السريعة على اليمين، ستجد شرحًا تفصيليًا، كما أن الجزء السفلي من المساعدة يوضح أنه تم تعريفه في <code class="language-plaintext highlighter-rouge">UIView</code>. وبالنظر إلى <code class="language-plaintext highlighter-rouge">YYTextContainerView</code>، نجد أنه يرث من <code class="language-plaintext highlighter-rouge">UIView</code>.</p>

<p>إذن، <code class="language-plaintext highlighter-rouge">YYLabel</code> يستخدم <code class="language-plaintext highlighter-rouge">YYTextContainerView</code>؟ ثم يقوم النظام باستدعاء <code class="language-plaintext highlighter-rouge">drawRect:</code> داخل <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> للرسم؟</p>

<p>غريب، <code class="language-plaintext highlighter-rouge">YYLabel</code> يمكن أن يرث من <code class="language-plaintext highlighter-rouge">UIView</code>. لذا، يجب أن يكون هناك مجموعتان من الأشياء في YYText! مجموعة <code class="language-plaintext highlighter-rouge">YYLabel</code>، ومجموعة <code class="language-plaintext highlighter-rouge">YYTextView</code>، تمامًا مثل <code class="language-plaintext highlighter-rouge">UILabel</code> و <code class="language-plaintext highlighter-rouge">UITextView</code>. ثم نعود وننظر إلى <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code> السابق في <code class="language-plaintext highlighter-rouge">YYLabel</code>،</p>

<p>طويل، في منتصف الطريق يتم استدعاء <code class="language-plaintext highlighter-rouge">drawInContext</code> من داخل <code class="language-plaintext highlighter-rouge">YYTextLayout</code>. <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code>، أين يتم استدعاؤه؟</p>

<p>تم استدعاؤه في السطر الثاني. لذا يمكن فهمه ببساطة على أن <code class="language-plaintext highlighter-rouge">YYLabel</code> يستخدم الرسم غير المتزامن للنص. بينما يتم استدعاء <code class="language-plaintext highlighter-rouge">_displayAsync</code> من خلال <code class="language-plaintext highlighter-rouge">display</code> أعلاه. بالنظر إلى وثائق <code class="language-plaintext highlighter-rouge">display</code>، يُقال أن النظام سيستدعيه في الوقت المناسب لتحديث محتوى الطبقة، ولا يجب عليك استدعاؤه مباشرة. يمكننا أيضًا وضع نقطة توقف له.</p>

<p>يبدو أن <code class="language-plaintext highlighter-rouge">display</code> يتم استدعاؤه ضمن معاملة (<code class="language-plaintext highlighter-rouge">transaction</code>) في <code class="language-plaintext highlighter-rouge">CALayer</code>. السبب في استخدام المعاملة ربما يكون لتحقيق تحديثات مجمعة، مما يعزز الكفاءة. لا يبدو أن هناك حاجة إلى التراجع كما في قواعد البيانات.</p>

<p>توضح وثائق النظام الخاصة بـ <code class="language-plaintext highlighter-rouge">display</code> أيضًا أنه إذا كنت ترغب في أن يكون رسم الطبقة (layer) مختلفًا، فيمكنك إعادة كتابة هذه الطريقة لتنفيذ الرسم الخاص بك.</p>

<p>لذلك، لدينا فكرة بسيطة. <code class="language-plaintext highlighter-rouge">YYLabel</code> يعيد كتابة طريقة <code class="language-plaintext highlighter-rouge">display</code> الخاصة بـ <code class="language-plaintext highlighter-rouge">UIView</code> لرسم ظلاله وتأثيراته الأخرى بشكل غير متزامن، يتم حفظ تأثيرات الظل أولاً في السمات (attributes) داخل <code class="language-plaintext highlighter-rouge">attributedText</code> الخاص بـ <code class="language-plaintext highlighter-rouge">YYLabel</code>، ثم يتم استرجاعها عند الرسم في طريقة <code class="language-plaintext highlighter-rouge">display</code>، ويتم استخدام إطار عمل CoreGraphics الخاص بالنظام للرسم.</p>

<p>بعد توضيح بعض الأفكار، سنجد أن القوة الحقيقية تكمن في أمرين: الأول هو تنظيم العديد من التأثيرات والاستدعاءات غير المتزامنة، والثاني هو الإتقان الجيد لإطار العمل الأساسي CoreGraphics. لذا، بعد فهم تنظيم الكود السابق، سنتعمق الآن في إطار عمل CoreGraphics. لنرى كيف يتم الرسم عليه.</p>

<p>لنعد مرة أخرى إلى <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>.</p>

<p>هنا، <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> و <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> يحيطان بجزء من الكود الخاص بالرسم. معنى <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> هو نسخ حالة الرسم الحالية وحفظها في مكدس الرسم. كل Context للرسم يحتفظ بمكدس رسم خاص به. أنا لست متأكدًا تمامًا من كيفية عمل المكدس داخليًا. ولكن يمكننا أن نفهم بشكل مؤقت أنه يجب استدعاء <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> قبل البدء في الرسم على الـ Context، واستدعاء <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> بعد الانتهاء من الرسم، وذلك لضمان أن الرسم الذي يتم في المنتصف يظهر بشكل صحيح في الـ Context.</p>

<p><code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> يستخدم لنقل الـ Context إلى موقع معين. أولاً، يتم نقله إلى الإحداثيات <code class="language-plaintext highlighter-rouge">point.x</code> و <code class="language-plaintext highlighter-rouge">point.y</code>، وهي المواقع المناسبة للرسم. أما بالنسبة للنقل إلى 0 و <code class="language-plaintext highlighter-rouge">size.height</code>، فأنا لست متأكدًا من الغرض منه، وسأحتاج إلى التحقق لاحقًا. بعد ذلك، يتم استخراج <code class="language-plaintext highlighter-rouge">lines</code> وتنفيذ حلقة <code class="language-plaintext highlighter-rouge">for</code>.</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> 是什么؟ تم العثور عليه في <code class="language-plaintext highlighter-rouge">YYTextLayout</code> حيث يتم تعيينه في الدالة <code class="language-plaintext highlighter-rouge">(YYTextLayout *)layoutWithContainer:(YYTextContainer *)container text:(NSAttributedString *)text range:(NSRange)range</code>.</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> هو عبارة عن مصفوفة تحتوي على أسطر النص التي تم إنشاؤها بواسطة <code class="language-plaintext highlighter-rouge">YYTextLayout</code>. يتم استخدام هذه المصفوفة لتخزين المعلومات حول كل سطر من النص، مثل موقعه وحجمه ومحتواه. يتم تعبئة هذه المصفوفة أثناء عملية إنشاء التخطيط (<code class="language-plaintext highlighter-rouge">layout</code>) للنص داخل الحاوية (<code class="language-plaintext highlighter-rouge">container</code>) المحددة.</p>

<p>عندما تقوم باستدعاء الدالة <code class="language-plaintext highlighter-rouge">layoutWithContainer:text:range:</code>، يتم تحليل النص (<code class="language-plaintext highlighter-rouge">text</code>) وتقسيمه إلى أسطر بناءً على الحاوية المحددة (<code class="language-plaintext highlighter-rouge">container</code>) والنطاق (<code class="language-plaintext highlighter-rouge">range</code>) المحدد. يتم بعد ذلك تخزين هذه الأسطر في المصفوفة <code class="language-plaintext highlighter-rouge">lines</code>، والتي يمكن استخدامها لاحقًا لرسم النص أو إجراء عمليات أخرى متعلقة بالتخطيط.</p>

<p>ثم انتقل إلى تعريف هذه الدالة:</p>

<p>هذه الدالة طويلة جدًا، من السطر 367 إلى السطر 861، أي حوالي 500 سطر من الكود! بعد النظر إلى البداية والنهاية، يمكن ملاحظة أن الغرض منها هو الحصول على هذه المتغيرات. كيف يتم الحصول على <code class="language-plaintext highlighter-rouge">lines</code>؟</p>

<p>يمكننا أن نرى في حلقة <code class="language-plaintext highlighter-rouge">for</code> الكبيرة أنه يتم إضافة كل سطر <code class="language-plaintext highlighter-rouge">line</code> واحدًا تلو الآخر إلى <code class="language-plaintext highlighter-rouge">lines</code>. إذًا، كيف يتم الحصول على <code class="language-plaintext highlighter-rouge">lineCount</code>؟</p>

<p>في السطر 472، تم إنشاء كائن <code class="language-plaintext highlighter-rouge">framesetter</code>، حيث كانت المعلمة <code class="language-plaintext highlighter-rouge">text</code> من نوع <code class="language-plaintext highlighter-rouge">NSAttributedString</code>. بعد ذلك، تم إنشاء <code class="language-plaintext highlighter-rouge">CTFrameRef</code> داخل كائن <code class="language-plaintext highlighter-rouge">frameSetter</code>، ثم تم الحصول على <code class="language-plaintext highlighter-rouge">lines</code> من <code class="language-plaintext highlighter-rouge">CTFrameRef</code>. ما هو بالضبط <code class="language-plaintext highlighter-rouge">line</code>؟ دعونا نضع نقطة توقف له.</p>

<p>تم اكتشاف أن <code class="language-plaintext highlighter-rouge">lineCount = 2</code> لكلمة <code class="language-plaintext highlighter-rouge">shadow</code>، وليس عدد الأحرف كما كنا نتوقع.</p>

<p>لذا يُعتقد أن <code class="language-plaintext highlighter-rouge">Shadow</code> الأبيض بأكمله هو <code class="language-plaintext highlighter-rouge">line</code> واحد، وظله أيضًا <code class="language-plaintext highlighter-rouge">line</code> واحد؟</p>

<p>في YYText، هناك عدة أمثلة، ولكن يتم عرض تأثير واحد فقط، بينما يتم تعليق الأكواد الأخرى. لاحظت شيئًا غريبًا: في حالة Shadow، <code class="language-plaintext highlighter-rouge">lineCount = 2</code>، وفي حالة Multiple Shadows، <code class="language-plaintext highlighter-rouge">lineCount</code> أيضًا يساوي 2. لكن في Multiple Shadows، هناك أيضًا ظل داخلي، أليس من المفترض أن يكون هناك 3 خطوط؟</p>

<p>بالذهاب إلى وثائق Apple الخاصة بـ <code class="language-plaintext highlighter-rouge">CTLine</code>، نجد أن <code class="language-plaintext highlighter-rouge">CTLine</code> يمثل سطرًا من النص، حيث يحتوي كائن <code class="language-plaintext highlighter-rouge">CTLine</code> على مجموعة من <code class="language-plaintext highlighter-rouge">glyph runs</code>. إذن، الأمر ببساطة يتعلق بعدد الأسطر! بالنظر إلى لقطة الشاشة أعلاه، نرى أن <code class="language-plaintext highlighter-rouge">shadow</code> كانت تساوي 2 لأن النص كان <code class="language-plaintext highlighter-rouge">shadow\n\n</code>. لاحظ أن <code class="language-plaintext highlighter-rouge">\n\n</code> تمت إضافتها عمدًا لأغراض تجميلية.</p>

<p>لذا فإن <code class="language-plaintext highlighter-rouge">shadow\n\n</code> عبارة عن سطرين من النص. CTLine هو ما نسميه عادةً بالسطر. لنعود الآن إلى <code class="language-plaintext highlighter-rouge">lineCount</code>:</p>

<p>هنا نحصل على مصفوفة <code class="language-plaintext highlighter-rouge">CTLines</code>، ونحصل على عدد العناصر داخلها، ثم إذا كان <code class="language-plaintext highlighter-rouge">lineCount</code> أكبر من 0، نحصل على نقطة الأصل لكل سطر. حسنًا، لدينا الآن <code class="language-plaintext highlighter-rouge">lineCount</code>، فلننظر إلى حلقة <code class="language-plaintext highlighter-rouge">for</code>.</p>

<p>من مصفوفة <code class="language-plaintext highlighter-rouge">ctLines</code> نحصل على <code class="language-plaintext highlighter-rouge">CTLine</code>، ثم نحصل على كائن <code class="language-plaintext highlighter-rouge">YYTextLine</code>، ونضيفه إلى مصفوفة <code class="language-plaintext highlighter-rouge">lines</code>. بعد ذلك نقوم ببعض حسابات الإطار لـ <code class="language-plaintext highlighter-rouge">line</code>. منشئ <code class="language-plaintext highlighter-rouge">YYTextLine</code> بسيط، حيث يحفظ أولاً الموضع، وما إذا كان النص عموديًا، وكائن <code class="language-plaintext highlighter-rouge">CTLine</code>:</p>

<p>بعد أن فهمنا <code class="language-plaintext highlighter-rouge">lines</code>، دعونا نعود إلى الدالة السابقة <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>:</p>

<p>أصبح الكود الآن أبسط. أولاً، نحصل على عدد الأسطر، ثم نقوم بتمريرها، وبعد ذلك نحصل على مصفوفة <code class="language-plaintext highlighter-rouge">GlyphRuns</code>، ونقوم بتمريرها أيضًا. يمكن فهم <code class="language-plaintext highlighter-rouge">GlyphRun</code> على أنه عنصر رسومي أو وحدة رسم. ثم نحصل من خلالها على مصفوفة <code class="language-plaintext highlighter-rouge">attributes</code>، ونستخدم <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> الذي ذكرناه سابقًا للحصول على <code class="language-plaintext highlighter-rouge">shadow</code> الذي قمنا بتعيينه في البداية، ثم نبدأ في رسم الظل:</p>

<p>حلقة <code class="language-plaintext highlighter-rouge">while</code> تقوم برسم الظلال الفرعية بشكل مستمر. يتم استدعاء <code class="language-plaintext highlighter-rouge">CGContextSetShadowWithColor</code> لتعيين إزاحة الظل ونصف قطره ولونه. ثم يتم استدعاء <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> للرسم الفعلي. يتم استدعاء <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> في ثلاثة أماكن:</p>

<p>تُستخدم لرسم الظلال الداخلية وظلال النصوص بالإضافة إلى النص نفسه. يشير هذا إلى أنها طريقة عامة تُستخدم لرسم الكائن <code class="language-plaintext highlighter-rouge">Run</code>.</p>

<p>في البداية، يتم الحصول على مصفوفة التحويل للنص باستخدام <code class="language-plaintext highlighter-rouge">runTextMatrixIsID</code> للتحقق مما إذا كانت المصفوفة هي مصفوفة الهوية (أي أنها لا تغير النص)، وإذا لم يكن النص مرتبطًا بشكل عمودي أو لم يتم تعيين تحويل الرسوم، يتم البدء في الرسم مباشرة. يتم استدعاء <code class="language-plaintext highlighter-rouge">CTRunDraw</code> لرسم كائن <code class="language-plaintext highlighter-rouge">run</code>. بعد ذلك، عند وضع نقطة توقف، تم اكتشاف أنه عند رسم الظل الأول، تم الدخول فقط إلى <code class="language-plaintext highlighter-rouge">if</code> ولم يتم الدخول إلى <code class="language-plaintext highlighter-rouge">else</code>.</p>

<p>لذلك، نكون قد انتهينا من رسم الظلال!</p>

<p>باختصار، يقوم <code class="language-plaintext highlighter-rouge">YYLabel</code> بحفظ تأثيرات مثل الظل في السمات (attributes) داخل <code class="language-plaintext highlighter-rouge">attributedText</code>، ثم يعيد كتابة طريقة <code class="language-plaintext highlighter-rouge">display</code> الخاصة بـ <code class="language-plaintext highlighter-rouge">UIView</code>. في طريقة <code class="language-plaintext highlighter-rouge">display</code>، يتم الرسم بشكل غير متزامن باستخدام إطار عمل <code class="language-plaintext highlighter-rouge">CoreText</code> للحصول على كائنات <code class="language-plaintext highlighter-rouge">CTLine</code> و <code class="language-plaintext highlighter-rouge">CTRun</code>. يتم استخراج السمات من <code class="language-plaintext highlighter-rouge">CTRun</code>، ثم بناءً على هذه السمات، يتم رسم كائن <code class="language-plaintext highlighter-rouge">CTRun</code> في السياق (Context) باستخدام إطار عمل <code class="language-plaintext highlighter-rouge">CoreGraphics</code>.</p>

<p>الفهم لا يزال غير كافٍ، سأعود لاحقًا لأقرأه مرة أخرى. لا أستطيع إلا أن أتعجب من مدى قوة YY! اليوم قمت بترتيب أفكاري، وجعلت نفسي أكتب وأقرأ الكود في نفس الوقت، حتى لا يكون الأمر مملًا، وفي نفس الوقت أقدم مرجعًا للآخرين. حان الوقت للذهاب إلى النوم.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-ar" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
