<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Java VPN Proxy Client with Netty</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Java VPN Proxy Client with Netty | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Java VPN Proxy Client with Netty" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-06-20-java-vpn-proxy-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-06-20-java-vpn-proxy-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Java VPN Proxy Client with Netty" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Java VPN Proxy Client with Netty","url":"https://lzwjava.github.io/notes/2025-06-20-java-vpn-proxy-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=0d0ed91473e3fb62aa74191eecbb668e44e74532">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=0d0ed91473e3fb62aa74191eecbb668e44e74532" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Java VPN Proxy Client with Netty | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-06-20-java-vpn-proxy-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-06-20-java-vpn-proxy-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.10</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/java-vpn-proxy-en" selected>English</option>
        <option value="/java-vpn-proxy-zh" >中文</option>
        <option value="/java-vpn-proxy-ja" >日本語</option>
        <option value="/java-vpn-proxy-es" >Español</option>
        <option value="/java-vpn-proxy-hi" >हिंदी</option>
        <option value="/java-vpn-proxy-fr" >Français</option>
        <option value="/java-vpn-proxy-de" >Deutsch</option>
        <option value="/java-vpn-proxy-ar" >العربية</option>
        <option value="/java-vpn-proxy-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>To build a Clash VPN proxy client in Java using Netty or Spring Boot, we need a robust framework to handle networking, YAML configuration parsing, and proxy protocols like SOCKS, HTTP, and Shadowsocks. Netty is ideal for high-performance networking, while Spring Boot can simplify configuration and dependency management. Below, I’ll outline the core logic, main libraries, and provide a sample implementation focusing on Netty for the networking layer, as it’s better suited for low-level proxy operations. The client will support popular Clash YAML configurations (e.g., for proxies, rules, and DNS).</p>

<h3 id="main-logic">Main Logic</h3>
<ol>
  <li><strong>Configuration Parsing</strong>:
    <ul>
      <li>Parse Clash-compatible YAML configuration files (e.g., <code class="language-plaintext highlighter-rouge">config.yaml</code>) containing proxy servers, rules, and DNS settings.</li>
      <li>Support common proxy types: HTTP, SOCKS5, Shadowsocks, etc.</li>
      <li>Map YAML fields to Java objects for easy access.</li>
    </ul>
  </li>
  <li><strong>Proxy Server Setup</strong>:
    <ul>
      <li>Initialize a Netty server to listen for incoming client connections (e.g., on a local port like 7890).</li>
      <li>Handle SOCKS5/HTTP proxy protocols to accept client requests.</li>
    </ul>
  </li>
  <li><strong>Routing and Rule Handling</strong>:
    <ul>
      <li>Implement rule-based routing (e.g., domain, IP, or geo-based) as defined in the YAML config.</li>
      <li>Route client requests to the appropriate upstream proxy server or direct connection.</li>
    </ul>
  </li>
  <li><strong>Connection Management</strong>:
    <ul>
      <li>Use Netty’s event-driven model to manage client-to-proxy and proxy-to-destination connections.</li>
      <li>Support connection pooling and keep-alive for efficiency.</li>
    </ul>
  </li>
  <li><strong>DNS Resolution</strong>:
    <ul>
      <li>Handle DNS queries as specified in the config (e.g., use upstream DNS or a local resolver).</li>
      <li>Support DNS over HTTPS (DoH) or other secure protocols if configured.</li>
    </ul>
  </li>
  <li><strong>Protocol Handling</strong>:
    <ul>
      <li>Implement protocol-specific logic for Shadowsocks (e.g., AEAD encryption), SOCKS5, and HTTP.</li>
      <li>Use pluggable protocol handlers to support extensibility.</li>
    </ul>
  </li>
  <li><strong>Error Handling and Logging</strong>:
    <ul>
      <li>Gracefully handle connection failures, invalid configurations, or unsupported protocols.</li>
      <li>Provide detailed logs for debugging.</li>
    </ul>
  </li>
</ol>

<h3 id="main-libraries">Main Libraries</h3>
<ul>
  <li><strong>Netty</strong>: For high-performance networking and event-driven I/O. Handles client connections, proxy forwarding, and protocol encoding/decoding.</li>
  <li><strong>SnakeYAML</strong>: To parse Clash-compatible YAML configuration files.</li>
  <li><strong>Bouncy Castle</strong>: For cryptographic operations (e.g., Shadowsocks AEAD encryption).</li>
  <li><strong>SLF4J</strong>: For logging.</li>
  <li><strong>Apache Commons</strong>: For utility functions (e.g., configuration validation).</li>
  <li><strong>Jackson (optional)</strong>: If you prefer JSON-like handling for YAML or additional config formats.</li>
  <li><strong>DNSJava (optional)</strong>: For custom DNS resolution if needed.</li>
</ul>

<h3 id="core-implementation">Core Implementation</h3>
<p>Below is a simplified Netty-based implementation of a Clash-like VPN proxy client. It focuses on:</p>
<ul>
  <li>Parsing a Clash YAML config.</li>
  <li>Setting up a SOCKS5 proxy server.</li>
  <li>Forwarding requests to an upstream proxy or destination.</li>
  <li>Basic rule-based routing.</li>
</ul>

<pre><code class="language-x-java-source">import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.socksx.v5.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.Yaml;

import java.io.FileReader;
import java.util.List;
import java.util.Map;

public class ClashProxyClient {
    private static final Logger logger = LoggerFactory.getLogger(ClashProxyClient.class);
    private static final int DEFAULT_PORT = 7890;
    private Map&lt;String, Object&gt; config;

    // Configuration class to hold parsed YAML data
    static class ProxyConfig {
        List&lt;Map&lt;String, String&gt;&gt; proxies;
        List&lt;String&gt; rules;

        public ProxyConfig(Map&lt;String, Object&gt; config) {
            this.proxies = (List&lt;Map&lt;String, String&gt;&gt;) config.get("proxies");
            this.rules = (List&lt;String&gt;) config.get("rules");
        }
    }

    // Load Clash YAML configuration
    public void loadConfig(String configPath) throws Exception {
        Yaml yaml = new Yaml();
        try (FileReader reader = new FileReader(configPath)) {
            config = yaml.load(reader);
            logger.info("Loaded configuration from {}", configPath);
        }
    }

    // Start the proxy server
    public void start() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer&lt;Channel&gt;() {
                        @Override
                        protected void initChannel(Channel ch) {
                            ChannelPipeline pipeline = ch.pipeline();
                            // Add SOCKS5 protocol handlers
                            pipeline.addLast(new Socks5ServerEncoder());
                            pipeline.addLast(new Socks5InitialRequestDecoder());
                            pipeline.addLast(new Socks5InitialRequestHandler());
                            pipeline.addLast(new Socks5CommandRequestDecoder());
                            pipeline.addLast(new ProxyHandler(new ProxyConfig(config)));
                        }
                    });

            ChannelFuture future = bootstrap.bind(DEFAULT_PORT).sync();
            logger.info("Proxy server started on port {}", DEFAULT_PORT);
            future.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

    // Handle SOCKS5 command requests and route traffic
    static class ProxyHandler extends SimpleChannelInboundHandler&lt;Socks5CommandRequest&gt; {
        private final ProxyConfig config;

        public ProxyHandler(ProxyConfig config) {
            this.config = config;
        }

        @Override
        protected void channelRead0(ChannelHandlerContext ctx, Socks5CommandRequest request) {
            String destination = request.dstAddr() + ":" + request.dstPort();
            logger.info("Handling request for {}", destination);

            // Simple rule-based routing (extend with actual rule parsing)
            String selectedProxy = selectProxy(destination);
            if (selectedProxy != null) {
                logger.info("Routing to proxy: {}", selectedProxy);
                // Implement proxy forwarding logic here
                ctx.write(new DefaultSocks5CommandResponse(
                        Socks5CommandStatus.SUCCESS, request.dstAddrType(),
                        request.dstAddr(), request.dstPort()));
            } else {
                logger.warn("No matching proxy found for {}", destination);
                ctx.write(new DefaultSocks5CommandResponse(
                        Socks5CommandStatus.FAILURE, request.dstAddrType(),
                        request.dstAddr(), request.dstPort()));
            }
        }

        private String selectProxy(String destination) {
            // Implement rule-based proxy selection
            for (String rule : config.rules) {
                // Example: Match domain or IP rules
                if (destination.matches(rule)) {
                    return config.proxies.get(0).get("name"); // Simplified
                }
            }
            return null; // Direct connection or fallback
        }
    }

    // Handle SOCKS5 initial request
    static class Socks5InitialRequestHandler extends SimpleChannelInboundHandler&lt;Socks5InitialRequest&gt; {
        @Override
        protected void channelRead0(ChannelHandlerContext ctx, Socks5InitialRequest msg) {
            ctx.write(new DefaultSocks5InitialResponse(Socks5AuthMethod.NO_AUTH));
        }
    }

    public static void main(String[] args) throws Exception {
        ClashProxyClient client = new ClashProxyClient();
        client.loadConfig("config.yaml");
        client.start();
    }
}
</code></pre>

<h3 id="sample-yaml-configuration">Sample YAML Configuration</h3>
<p>Here’s an example <code class="language-plaintext highlighter-rouge">config.yaml</code> compatible with the above code:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">proxies</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">proxy1</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">socks5</span>
    <span class="na">server</span><span class="pi">:</span> <span class="s">192.168.1.100</span>
    <span class="na">port</span><span class="pi">:</span> <span class="m">1080</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">proxy2</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">http</span>
    <span class="na">server</span><span class="pi">:</span> <span class="s">192.168.1.101</span>
    <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
<span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">DOMAIN,example.com,proxy1</span>
  <span class="pi">-</span> <span class="s">IP-CIDR,192.168.0.0/16,DIRECT</span>
</code></pre></div></div>

<h3 id="explanation-of-core-logic">Explanation of Core Logic</h3>
<ul>
  <li><strong>YAML Parsing</strong>: The <code class="language-plaintext highlighter-rouge">loadConfig</code> method uses SnakeYAML to parse the Clash configuration into a <code class="language-plaintext highlighter-rouge">ProxyConfig</code> object, which holds proxy definitions and routing rules.</li>
  <li><strong>Netty Server</strong>: The <code class="language-plaintext highlighter-rouge">start</code> method sets up a Netty server listening on port 7890, handling SOCKS5 protocol requests using Netty’s built-in SOCKS5 codecs.</li>
  <li><strong>Request Handling</strong>: The <code class="language-plaintext highlighter-rouge">ProxyHandler</code> processes SOCKS5 command requests, applies routing rules, and selects an upstream proxy or direct connection.</li>
  <li><strong>Routing</strong>: The <code class="language-plaintext highlighter-rouge">selectProxy</code> method (simplified) matches destination addresses against rules to choose the appropriate proxy.</li>
  <li><strong>Extensibility</strong>: The code is modular, allowing easy addition of new protocols (e.g., Shadowsocks) by extending the <code class="language-plaintext highlighter-rouge">ProxyHandler</code>.</li>
</ul>

<h3 id="next-steps">Next Steps</h3>
<ol>
  <li><strong>Protocol Support</strong>: Add handlers for Shadowsocks (using Bouncy Castle for encryption) and HTTP proxies.</li>
  <li><strong>Advanced Routing</strong>: Implement full Clash rule parsing (e.g., GEOIP, DOMAIN-SUFFIX) using regex or a rule engine.</li>
  <li><strong>DNS Handling</strong>: Integrate DNSJava or a custom resolver for Clash’s DNS settings.</li>
  <li><strong>Connection Pooling</strong>: Use Netty’s <code class="language-plaintext highlighter-rouge">ChannelPool</code> for efficient upstream connections.</li>
  <li><strong>Spring Boot (Optional)</strong>: If you prefer Spring Boot, use it for configuration management and REST endpoints for monitoring, but keep Netty for the core proxy logic.</li>
</ol>

<h3 id="dependencies-maven">Dependencies (Maven)</h3>
<p>Add these to your <code class="language-plaintext highlighter-rouge">pom.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependencies&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>io.netty<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>netty-all<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>4.1.111.Final<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.yaml<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>snakeyaml<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>2.3<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.slf4j<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>slf4j-api<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>2.0.16<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.bouncycastle<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>bcprov-jdk18on<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>1.78.1<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;/dependencies&gt;</span>
</code></pre></div></div>

<p>This provides a foundation for a Clash-like VPN proxy client. You can extend it by adding support for more protocols, advanced routing, and DNS features based on your needs. Let me know if you want to dive deeper into any specific part!</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
