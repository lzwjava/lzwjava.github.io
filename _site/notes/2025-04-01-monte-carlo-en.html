<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Monte Carlo Tree Search</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Monte Carlo Tree Search | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Monte Carlo Tree Search" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-04-01-monte-carlo-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-04-01-monte-carlo-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Monte Carlo Tree Search" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Monte Carlo Tree Search","url":"https://lzwjava.github.io/notes/2025-04-01-monte-carlo-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=44118a0318f2fe6463997f724330a296a496f3e9">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=44118a0318f2fe6463997f724330a296a496f3e9" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Monte Carlo Tree Search | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-04-01-monte-carlo-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-04-01-monte-carlo-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.10</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/monte-carlo-en" selected>English</option>
        <option value="/monte-carlo-zh" >中文</option>
        <option value="/monte-carlo-ja" >日本語</option>
        <option value="/monte-carlo-es" >Español</option>
        <option value="/monte-carlo-hi" >हिंदी</option>
        <option value="/monte-carlo-fr" >Français</option>
        <option value="/monte-carlo-de" >Deutsch</option>
        <option value="/monte-carlo-ar" >العربية</option>
        <option value="/monte-carlo-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Let’s dive into a comprehensive guide on <strong>Monte Carlo Tree Search (MCTS)</strong>, a powerful algorithm widely used in decision-making problems, especially in games and artificial intelligence. I’ll break it down step-by-step, covering its origins, core concepts, mechanics, implementation, strengths, weaknesses, and applications—everything you need to grasp it thoroughly.</p>

<hr />

<h3 id="what-is-monte-carlo-tree-search">What is Monte Carlo Tree Search?</h3>

<p>Monte Carlo Tree Search is a heuristic search algorithm that combines the precision of tree search with the randomness of Monte Carlo methods. It’s particularly effective for problems with large, complex decision spaces where exhaustively exploring all possibilities (like in minimax) isn’t feasible. MCTS builds a partial search tree incrementally, using random simulations to guide its exploration toward promising moves.</p>

<ul>
  <li><strong>Origins</strong>: MCTS emerged in the mid-2000s, with significant contributions from Rémi Coulom (2006) and others. It gained fame when it powered Go-playing AI, notably in AlphaGo, revolutionizing how computers tackle games with vast state spaces.</li>
  <li><strong>Key Use Case</strong>: Games like Go, Chess, Poker, and even real-world problems like planning or optimization.</li>
</ul>

<hr />

<h3 id="core-concepts">Core Concepts</h3>

<p>MCTS operates on a <strong>tree</strong> where:</p>
<ul>
  <li><strong>Nodes</strong> represent game states or decision points.</li>
  <li><strong>Edges</strong> represent actions or moves leading to new states.</li>
  <li>The <strong>root</strong> is the current state from which decisions are made.</li>
</ul>

<p>The algorithm balances <strong>exploration</strong> (trying new moves) and <strong>exploitation</strong> (focusing on known good moves) using a statistical approach. It doesn’t require a perfect evaluation function—just a way to simulate outcomes.</p>

<hr />

<h3 id="the-four-phases-of-mcts">The Four Phases of MCTS</h3>

<p>MCTS iterates through four distinct steps in each simulation cycle:</p>

<h4 id="1-selection">1. <strong>Selection</strong></h4>
<ul>
  <li>Start at the root and traverse the tree to a leaf node (a node not fully expanded or a terminal state).</li>
  <li>Use a <strong>selection policy</strong> to choose child nodes. The most common is the <strong>Upper Confidence Bound applied to Trees (UCT)</strong> formula:
\[
UCT = \bar{X}_i + C \sqrt{\frac{\ln(N)}{n_i}}
\]
    <ul>
      <li>\(\bar{X}_i\): Average reward (win rate) of the node.</li>
      <li>\(n_i\): Number of visits to the node.</li>
      <li>\(N\): Number of visits to the parent node.</li>
      <li>\(C\): Exploration constant (typically \(\sqrt{2}\) or tuned per problem).</li>
    </ul>
  </li>
  <li>UCT balances exploitation (\(\bar{X}_i\)) and exploration (the \(\sqrt{\frac{\ln(N)}{n_i}}\) term).</li>
</ul>

<h4 id="2-expansion">2. <strong>Expansion</strong></h4>
<ul>
  <li>If the selected leaf node isn’t terminal and has unvisited children, expand it by adding one or more child nodes (representing untried moves).</li>
  <li>Typically, only one child is added per iteration to control memory usage.</li>
</ul>

<h4 id="3-simulation-rollout">3. <strong>Simulation (Rollout)</strong></h4>
<ul>
  <li>From the newly expanded node, run a <strong>random simulation</strong> (or rollout) to a terminal state (e.g., win/loss/draw).</li>
  <li>The simulation uses a lightweight policy—often uniform random moves—since evaluating every state precisely is too costly.</li>
  <li>The outcome (e.g., +1 for a win, 0 for a draw, -1 for a loss) is recorded.</li>
</ul>

<h4 id="4-backpropagation">4. <strong>Backpropagation</strong></h4>
<ul>
  <li>Propagate the simulation result back up the tree, updating statistics for each visited node:
    <ul>
      <li>Increment the visit count (\(n_i\)).</li>
      <li>Update the total reward (e.g., sum of wins or average win rate).</li>
    </ul>
  </li>
  <li>This refines the tree’s knowledge about which paths are promising.</li>
</ul>

<p>Repeat these steps for many iterations (e.g., thousands), then pick the best move from the root based on the most visited child or highest average reward.</p>

<hr />

<h3 id="how-mcts-works-an-example">How MCTS Works: An Example</h3>

<p>Imagine a simple tic-tac-toe game:</p>
<ol>
  <li><strong>Root</strong>: Current board state (e.g., X’s turn with a partially filled board).</li>
  <li><strong>Selection</strong>: UCT picks a promising move (e.g., placing X in the center) based on prior simulations.</li>
  <li><strong>Expansion</strong>: Add a child node for an untried move (e.g., O’s response in a corner).</li>
  <li><strong>Simulation</strong>: Play random moves until the game ends (e.g., X wins).</li>
  <li><strong>Backpropagation</strong>: Update stats—center move gets +1 reward, visit count increases.</li>
</ol>

<p>After thousands of iterations, the tree reveals that placing X in the center has a high win rate, so it’s chosen.</p>

<hr />

<h3 id="pseudocode">Pseudocode</h3>

<p>Here’s a basic MCTS implementation:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">visits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">reward</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">mcts</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">iterations</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">selection</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">is_terminal</span><span class="p">():</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">expansion</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="n">simulation</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">state</span><span class="p">)</span>
        <span class="n">backpropagation</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">reward</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">best_child</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">selection</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">is_terminal</span><span class="p">():</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">uct</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span>

<span class="k">def</span> <span class="nf">expansion</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">untried_moves</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">get_untried_moves</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">untried_moves</span><span class="p">:</span>
        <span class="n">move</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">(</span><span class="n">untried_moves</span><span class="p">)</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">state</span><span class="p">.</span><span class="n">apply_move</span><span class="p">(</span><span class="n">move</span><span class="p">)</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">new_state</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">child</span>
    <span class="k">return</span> <span class="n">node</span>

<span class="k">def</span> <span class="nf">simulation</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">current</span><span class="p">.</span><span class="n">is_terminal</span><span class="p">():</span>
        <span class="n">move</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">get_moves</span><span class="p">())</span>
        <span class="n">current</span><span class="p">.</span><span class="n">apply_move</span><span class="p">(</span><span class="n">move</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">current</span><span class="p">.</span><span class="n">get_result</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">backpropagation</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">reward</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">node</span><span class="p">.</span><span class="n">visits</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">node</span><span class="p">.</span><span class="n">reward</span> <span class="o">+=</span> <span class="n">reward</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">parent</span>

<span class="k">def</span> <span class="nf">uct</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">child</span><span class="p">.</span><span class="n">visits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>  <span class="c1"># Explore unvisited nodes
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">reward</span> <span class="o">/</span> <span class="n">child</span><span class="p">.</span><span class="n">visits</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.41</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">visits</span><span class="p">)</span> <span class="o">/</span> <span class="n">child</span><span class="p">.</span><span class="n">visits</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">best_child</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="p">.</span><span class="n">visits</span><span class="p">)</span>  <span class="c1"># Or use reward/visits
</span></code></pre></div></div>

<hr />

<h3 id="strengths-of-mcts">Strengths of MCTS</h3>

<ol>
  <li><strong>Anytime Algorithm</strong>: Stop it anytime and get a reasonable move based on current stats.</li>
  <li><strong>No Evaluation Function Needed</strong>: Relies on simulations, not domain-specific heuristics.</li>
  <li><strong>Scalable</strong>: Works in huge state spaces (e.g., Go with \(10^{170}\) possible positions).</li>
  <li><strong>Adaptive</strong>: Naturally focuses on promising branches as iterations increase.</li>
</ol>

<hr />

<h3 id="weaknesses-of-mcts">Weaknesses of MCTS</h3>

<ol>
  <li><strong>Computationally Intensive</strong>: Requires many simulations for good results, which can be slow without optimization.</li>
  <li><strong>Shallow Exploration</strong>: May miss deep strategies if iterations are limited.</li>
  <li><strong>Randomness Dependency</strong>: Poor rollout policies can skew results; quality depends on simulation accuracy.</li>
  <li><strong>Memory Usage</strong>: Tree growth can be a bottleneck in memory-constrained environments.</li>
</ol>

<hr />

<h3 id="enhancements-and-variations">Enhancements and Variations</h3>

<p>To address weaknesses, MCTS is often enhanced:</p>
<ul>
  <li><strong>Heuristics in Rollouts</strong>: Use domain knowledge (e.g., preferring center moves in tic-tac-toe) instead of pure randomness.</li>
  <li><strong>Parallelization</strong>: Run multiple simulations concurrently (root parallelization or tree parallelization).</li>
  <li><strong>RAVE (Rapid Action Value Estimation)</strong>: Share statistics across similar moves to speed convergence.</li>
  <li><strong>Integration with Neural Networks</strong>: As in AlphaGo, use neural nets to guide selection (policy network) and evaluate states (value network).</li>
</ul>

<hr />

<h3 id="applications">Applications</h3>

<ol>
  <li><strong>Games</strong>:
    <ul>
      <li>Go (AlphaGo’s breakthrough).</li>
      <li>Chess (combined with neural networks in engines like Leela Chess Zero).</li>
      <li>Poker (handles imperfect information with adaptations).</li>
    </ul>
  </li>
  <li><strong>Robotics</strong>: Path planning in uncertain environments.</li>
  <li><strong>Optimization</strong>: Solving combinatorial problems like scheduling or resource allocation.</li>
  <li><strong>Real-Time Strategy</strong>: Decision-making in dynamic, unpredictable scenarios.</li>
</ol>

<hr />

<h3 id="practical-tips-for-implementation">Practical Tips for Implementation</h3>

<ul>
  <li><strong>Tune \(C\)</strong>: Adjust the UCT exploration constant based on your problem (\(C = \sqrt{2}\) is a starting point).</li>
  <li><strong>Limit Tree Growth</strong>: Prune nodes or cap expansion to manage memory.</li>
  <li><strong>Optimize Rollouts</strong>: Use lightweight simulations or heuristics to save time.</li>
  <li><strong>Test Iterations</strong>: Experiment with 100, 1,000, or 10,000 iterations to balance speed and quality.</li>
</ul>

<hr />

<h3 id="conclusion">Conclusion</h3>

<p>MCTS is a versatile, elegant algorithm that shines in domains where traditional search methods falter. Its beauty lies in its simplicity—random simulations guided by a growing tree—yet it scales to tackle some of the hardest problems in AI. Whether you’re coding a game AI or solving a planning task, MCTS offers a robust starting point, especially when paired with modern enhancements like neural networks.</p>

<p>If you’d like, I can walk you through a specific implementation (e.g., for tic-tac-toe) or explore a particular aspect—like UCT tuning or parallel MCTS—in more detail. What do you think?</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
