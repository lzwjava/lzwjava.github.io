<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Binary Search in Finance Data Projects</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Binary Search in Finance Data Projects | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Binary Search in Finance Data Projects" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-05-28-projects-binary-search-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-05-28-projects-binary-search-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Binary Search in Finance Data Projects" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Binary Search in Finance Data Projects","url":"https://lzwjava.github.io/notes/2025-05-28-projects-binary-search-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=82d69ac940e04f8043b440734f0f4a8f76b43c56">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=82d69ac940e04f8043b440734f0f4a8f76b43c56" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Binary Search in Finance Data Projects | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-05-28-projects-binary-search-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-05-28-projects-binary-search-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.10</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/projects-binary-search-en" selected>English</option>
        <option value="/projects-binary-search-zh" >中文</option>
        <option value="/projects-binary-search-ja" >日本語</option>
        <option value="/projects-binary-search-es" >Español</option>
        <option value="/projects-binary-search-hi" >हिंदी</option>
        <option value="/projects-binary-search-fr" >Français</option>
        <option value="/projects-binary-search-de" >Deutsch</option>
        <option value="/projects-binary-search-ar" >العربية</option>
        <option value="/projects-binary-search-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Binary search is an efficient algorithm for finding an item from a <strong>sorted list</strong> of items by repeatedly dividing the search interval in half. In the context of your finance project with a focus on data, databases, Angular frontend, and SQL queries, binary search can be applied in specific scenarios where you need to search through sorted data. Below, I’ll explain how and where you can use binary search in your project, tailored to your tech stack and finance domain.</p>

<h3 id="key-characteristics-of-binary-search">Key Characteristics of Binary Search</h3>
<ul>
  <li><strong>Requirement</strong>: The data must be <strong>sorted</strong> (e.g., ascending or descending order).</li>
  <li><strong>Time Complexity</strong>: O(log n), making it much faster than linear search (O(n)) for large datasets.</li>
  <li><strong>Use Case</strong>: Best for static or infrequently changing sorted data where you need to locate a specific value quickly.</li>
</ul>

<h3 id="where-binary-search-can-be-applied-in-your-finance-project">Where Binary Search Can Be Applied in Your Finance Project</h3>
<p>In a finance project with a database-heavy backend and an Angular frontend, binary search can be applied in the following areas:</p>

<h4 id="1-backend-searching-in-sorted-database-results">1. <strong>Backend: Searching in Sorted Database Results</strong></h4>
<ul>
  <li><strong>Scenario</strong>: Your finance project likely involves querying large datasets (e.g., transaction records, stock prices, or account balances) sorted by fields like transaction ID, date, or amount. If the data is already sorted (or you sort it in the SQL query), you can use binary search to locate specific records efficiently in memory after fetching them.</li>
  <li><strong>Example</strong>:
    <ul>
      <li>You retrieve a sorted list of transactions (e.g., by date or amount) from the database using a query like:
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">transactions</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="o">?</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">transaction_date</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
      <li>After fetching the results into your backend (e.g., Node.js, Java, or Python), you can use binary search to find a specific transaction by date or ID without iterating through the entire list.</li>
    </ul>
  </li>
  <li><strong>Implementation</strong>:
    <ul>
      <li>Load the sorted data into an array or list in your backend.</li>
      <li>Implement binary search to find the target record. For example, in JavaScript:
        <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">binarySearch</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="o">===</span> <span class="nx">target</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">target</span><span class="p">)</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// Not found</span>
<span class="p">}</span>

<span class="c1">// Example: Find transaction with specific date</span>
<span class="kd">const</span> <span class="nx">transactions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">date</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2025-01-01</span><span class="dl">'</span><span class="p">,</span> <span class="na">amount</span><span class="p">:</span> <span class="mi">100</span> <span class="p">},</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">date</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2025-01-02</span><span class="dl">'</span><span class="p">,</span> <span class="na">amount</span><span class="p">:</span> <span class="mi">200</span> <span class="p">},</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">date</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2025-01-03</span><span class="dl">'</span><span class="p">,</span> <span class="na">amount</span><span class="p">:</span> <span class="mi">150</span> <span class="p">}</span>
<span class="p">];</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">binarySearch</span><span class="p">(</span><span class="nx">transactions</span><span class="p">,</span> <span class="dl">'</span><span class="s1">2025-01-02</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">date</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// { id: 2, date: '2025-01-02', amount: 200 }</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>When to Use</strong>:
    <ul>
      <li>The dataset is sorted and relatively static (e.g., historical transaction data).</li>
      <li>The dataset is too large for linear search but small enough to fit in memory after the SQL query.</li>
      <li>You need to perform multiple searches on the same sorted dataset.</li>
    </ul>
  </li>
</ul>

<h4 id="2-frontend-searching-in-angular-for-ui-features">2. <strong>Frontend: Searching in Angular for UI Features</strong></h4>
<ul>
  <li><strong>Scenario</strong>: In your Angular frontend, you might display sorted data (e.g., a table of stock prices, sorted by price or date). If the user wants to quickly find a specific item (e.g., a stock with a particular price or a transaction on a specific date), you can implement binary search in the frontend to avoid scanning the entire dataset.</li>
  <li><strong>Example</strong>:
    <ul>
      <li>You fetch sorted data from the backend via an API and store it in an Angular component.</li>
      <li>Implement binary search in TypeScript to find an item in the sorted array.</li>
      <li>Display the result in the UI (e.g., highlight a transaction or scroll to a specific row in a table).</li>
      <li>TypeScript example in an Angular component:
        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">TransactionComponent</span> <span class="p">{</span>
  <span class="nl">transactions</span><span class="p">:</span> <span class="kr">any</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">date</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2025-01-01</span><span class="dl">'</span><span class="p">,</span> <span class="na">amount</span><span class="p">:</span> <span class="mi">100</span> <span class="p">},</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">date</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2025-01-02</span><span class="dl">'</span><span class="p">,</span> <span class="na">amount</span><span class="p">:</span> <span class="mi">200</span> <span class="p">},</span>
    <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">date</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2025-01-03</span><span class="dl">'</span><span class="p">,</span> <span class="na">amount</span><span class="p">:</span> <span class="mi">150</span> <span class="p">}</span>
  <span class="p">];</span>

  <span class="nx">findTransaction</span><span class="p">(</span><span class="nx">targetDate</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">transactions</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">transactions</span><span class="p">[</span><span class="nx">mid</span><span class="p">].</span><span class="nx">date</span> <span class="o">===</span> <span class="nx">targetDate</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">transactions</span><span class="p">[</span><span class="nx">mid</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">transactions</span><span class="p">[</span><span class="nx">mid</span><span class="p">].</span><span class="nx">date</span> <span class="o">&lt;</span> <span class="nx">targetDate</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// Not found</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>When to Use</strong>:
    <ul>
      <li>The frontend receives a sorted dataset (e.g., via API) and needs to perform quick searches for user interactions (e.g., filtering or searching in a table).</li>
      <li>The dataset is small enough to be handled in the browser without performance issues.</li>
      <li>You want to reduce the number of API calls to the backend for searching.</li>
    </ul>
  </li>
</ul>

<h4 id="3-in-memory-data-structures-for-finance-calculations">3. <strong>In-Memory Data Structures for Finance Calculations</strong></h4>
<ul>
  <li><strong>Scenario</strong>: Finance projects often involve calculations like portfolio analysis, historical price lookups, or interest rate calculations. If you maintain sorted in-memory data structures (e.g., arrays of historical stock prices or interest rates), binary search can quickly locate values for calculations.</li>
  <li><strong>Example</strong>:
    <ul>
      <li>You have a sorted array of historical stock prices by date and need to find the price on a specific date for a financial model (e.g., calculating returns).</li>
      <li>Use binary search to locate the price efficiently instead of scanning the entire array.</li>
      <li>Example in Python (if your backend uses Python):
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">prices</span><span class="p">,</span> <span class="n">target_date</span><span class="p">):</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="s">'date'</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_date</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">prices</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="s">'price'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="s">'date'</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target_date</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="bp">None</span>  <span class="c1"># Not found
</span>
<span class="n">prices</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s">'date'</span><span class="p">:</span> <span class="s">'2025-01-01'</span><span class="p">,</span> <span class="s">'price'</span><span class="p">:</span> <span class="mi">100</span><span class="p">},</span>
    <span class="p">{</span><span class="s">'date'</span><span class="p">:</span> <span class="s">'2025-01-02'</span><span class="p">,</span> <span class="s">'price'</span><span class="p">:</span> <span class="mi">105</span><span class="p">},</span>
    <span class="p">{</span><span class="s">'date'</span><span class="p">:</span> <span class="s">'2025-01-03'</span><span class="p">,</span> <span class="s">'price'</span><span class="p">:</span> <span class="mi">110</span><span class="p">}</span>
<span class="p">]</span>
<span class="n">price</span> <span class="o">=</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">prices</span><span class="p">,</span> <span class="s">'2025-01-02'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">price</span><span class="p">)</span>  <span class="c1"># Output: 105
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>When to Use</strong>:
    <ul>
      <li>You’re performing calculations on sorted datasets like time-series financial data (e.g., stock prices, exchange rates).</li>
      <li>The data is already sorted or can be pre-sorted without significant overhead.</li>
    </ul>
  </li>
</ul>

<h4 id="4-optimizing-sql-queries-with-binary-search-logic">4. <strong>Optimizing SQL Queries with Binary Search Logic</strong></h4>
<ul>
  <li><strong>Scenario</strong>: While SQL databases are optimized for searching (e.g., using indexes), you can mimic binary search logic in specific cases, such as when working with indexed, sorted data or when implementing custom search logic in stored procedures.</li>
  <li><strong>Example</strong>:
    <ul>
      <li>If you have a large table with a sorted index (e.g., on transaction_date), you can write a stored procedure that uses binary search-like logic to narrow down the search space.</li>
      <li>For example, in a PostgreSQL stored procedure:
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">FUNCTION</span> <span class="n">find_transaction</span><span class="p">(</span><span class="n">target_date</span> <span class="nb">DATE</span><span class="p">)</span>
<span class="k">RETURNS</span> <span class="k">TABLE</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">amount</span> <span class="nb">NUMERIC</span><span class="p">)</span> <span class="k">AS</span> <span class="err">$$</span>
<span class="k">DECLARE</span>
    <span class="n">mid_point</span> <span class="nb">DATE</span><span class="p">;</span>
    <span class="n">lower_bound</span> <span class="nb">DATE</span><span class="p">;</span>
    <span class="n">upper_bound</span> <span class="nb">DATE</span><span class="p">;</span>
<span class="k">BEGIN</span>
    <span class="k">SELECT</span> <span class="k">MIN</span><span class="p">(</span><span class="n">transaction_date</span><span class="p">),</span> <span class="k">MAX</span><span class="p">(</span><span class="n">transaction_date</span><span class="p">)</span>
    <span class="k">INTO</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span>
    <span class="k">FROM</span> <span class="n">transactions</span><span class="p">;</span>

    <span class="n">WHILE</span> <span class="n">lower_bound</span> <span class="o">&lt;=</span> <span class="n">upper_bound</span> <span class="n">LOOP</span>
        <span class="n">mid_point</span> <span class="p">:</span><span class="o">=</span> <span class="n">lower_bound</span> <span class="o">+</span> <span class="p">(</span><span class="n">upper_bound</span> <span class="o">-</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">IF</span> <span class="k">EXISTS</span> <span class="p">(</span>
            <span class="k">SELECT</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="n">transactions</span>
            <span class="k">WHERE</span> <span class="n">transaction_date</span> <span class="o">=</span> <span class="n">target_date</span>
            <span class="k">AND</span> <span class="n">transaction_date</span> <span class="o">=</span> <span class="n">mid_point</span>
        <span class="p">)</span> <span class="k">THEN</span>
            <span class="k">RETURN</span> <span class="n">QUERY</span>
            <span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">amount</span> <span class="k">FROM</span> <span class="n">transactions</span>
            <span class="k">WHERE</span> <span class="n">transaction_date</span> <span class="o">=</span> <span class="n">target_date</span><span class="p">;</span>
            <span class="k">RETURN</span><span class="p">;</span>
        <span class="n">ELSIF</span> <span class="n">target_date</span> <span class="o">&gt;</span> <span class="n">mid_point</span> <span class="k">THEN</span>
            <span class="n">lower_bound</span> <span class="p">:</span><span class="o">=</span> <span class="n">mid_point</span> <span class="o">+</span> <span class="n">INTERVAL</span> <span class="s1">'1 day'</span><span class="p">;</span>
        <span class="k">ELSE</span>
            <span class="n">upper_bound</span> <span class="p">:</span><span class="o">=</span> <span class="n">mid_point</span> <span class="o">-</span> <span class="n">INTERVAL</span> <span class="s1">'1 day'</span><span class="p">;</span>
        <span class="k">END</span> <span class="n">IF</span><span class="p">;</span>
    <span class="k">END</span> <span class="n">LOOP</span><span class="p">;</span>
    <span class="k">RETURN</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="err">$$</span> <span class="k">LANGUAGE</span> <span class="n">plpgsql</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>When to Use</strong>:
    <ul>
      <li>You’re working with very large datasets, and the database’s built-in indexing isn’t sufficient for your specific search pattern.</li>
      <li>You’re implementing custom logic in stored procedures for performance optimization.</li>
      <li>Note: This is less common, as database indexes (e.g., B-trees) already use similar principles internally.</li>
    </ul>
  </li>
</ul>

<h4 id="5-caching-frequently-searched-data">5. <strong>Caching Frequently Searched Data</strong></h4>
<ul>
  <li><strong>Scenario</strong>: In finance applications, certain data (e.g., exchange rates, tax rates, or historical data) is frequently accessed and can be cached in sorted order. Binary search can be used to query this cached data quickly.</li>
  <li><strong>Example</strong>:
    <ul>
      <li>Cache a sorted list of exchange rates in a Redis cache or an in-memory data structure.</li>
      <li>Use binary search to find the exchange rate for a specific date or currency pair.</li>
      <li>Example in Node.js with Redis:
        <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">redis</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">redis</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">client</span> <span class="o">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">createClient</span><span class="p">();</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">findExchangeRate</span><span class="p">(</span><span class="nx">targetDate</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">rates</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="k">await</span> <span class="nx">client</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">exchange_rates</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// Sorted array</span>
    <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">rates</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">rates</span><span class="p">[</span><span class="nx">mid</span><span class="p">].</span><span class="nx">date</span> <span class="o">===</span> <span class="nx">targetDate</span><span class="p">)</span> <span class="k">return</span> <span class="nx">rates</span><span class="p">[</span><span class="nx">mid</span><span class="p">].</span><span class="nx">rate</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">rates</span><span class="p">[</span><span class="nx">mid</span><span class="p">].</span><span class="nx">date</span> <span class="o">&lt;</span> <span class="nx">targetDate</span><span class="p">)</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>When to Use</strong>:
    <ul>
      <li>You’re caching static or semi-static data (e.g., daily exchange rates, tax tables).</li>
      <li>The cached data is sorted, and you need to perform frequent lookups.</li>
    </ul>
  </li>
</ul>

<h3 id="when-not-to-use-binary-search">When <strong>Not</strong> to Use Binary Search</h3>
<ul>
  <li><strong>Unsorted Data</strong>: Binary search requires sorted data. If sorting the data is too expensive (O(n log n)), consider other algorithms or data structures (e.g., hash tables for O(1) lookups).</li>
  <li><strong>Dynamic Data</strong>: If the dataset changes frequently (e.g., real-time stock prices), maintaining sorted order can be costly. Use database indexes or other data structures like hash maps or trees instead.</li>
  <li><strong>Small Datasets</strong>: For small datasets (e.g., &lt; 100 items), linear search may be faster due to lower overhead.</li>
  <li><strong>Database-Level Searches</strong>: SQL databases with proper indexes (e.g., B-tree or hash indexes) are optimized for searching. Binary search is more useful for in-memory data or post-query processing.</li>
</ul>

<h3 id="practical-considerations-for-your-project">Practical Considerations for Your Project</h3>
<ol>
  <li><strong>Data Volume</strong>: Binary search shines with large datasets (e.g., thousands or millions of records). Evaluate whether your datasets are large enough to benefit from binary search over linear search or database queries.</li>
  <li><strong>Sorting Overhead</strong>: Ensure the data is already sorted or that sorting is feasible. For example, retrieve sorted data from SQL (<code class="language-plaintext highlighter-rouge">ORDER BY</code>) or maintain sorted arrays in memory.</li>
  <li><strong>Integration with Angular</strong>: In the frontend, use binary search for client-side filtering or searching in sorted tables to improve UX (e.g., quickly finding a transaction in a paginated table).</li>
  <li><strong>Finance-Specific Use Cases</strong>:
    <ul>
      <li><strong>Transaction Lookups</strong>: Find specific transactions by ID, date, or amount in sorted lists.</li>
      <li><strong>Time-Series Analysis</strong>: Locate specific dates in historical financial data (e.g., stock prices, interest rates).</li>
      <li><strong>Portfolio Management</strong>: Search for specific assets or metrics in sorted portfolios.</li>
    </ul>
  </li>
  <li><strong>Alternative Data Structures</strong>:
    <ul>
      <li>If binary search isn’t suitable (e.g., unsorted or dynamic data), consider:
        <ul>
          <li><strong>Hash Maps</strong>: For O(1) lookups by key (e.g., transaction ID).</li>
          <li><strong>B-Trees or Indexes</strong>: Let the database handle searches efficiently.</li>
          <li><strong>Trie or Prefix Trees</strong>: For string-based searches (e.g., searching account names).</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="example-workflow-in-your-project">Example Workflow in Your Project</h3>
<ol>
  <li><strong>Backend</strong>:
    <ul>
      <li>Run a SQL query to fetch sorted transactions: <code class="language-plaintext highlighter-rouge">SELECT * FROM transactions WHERE account_id = ? ORDER BY transaction_date</code>.</li>
      <li>Load the results into an in-memory array.</li>
      <li>Use binary search to find a specific transaction by date or amount.</li>
    </ul>
  </li>
  <li><strong>Frontend</strong>:
    <ul>
      <li>Fetch the sorted data via an API and display it in an Angular table.</li>
      <li>Implement a search feature in the Angular component using binary search to highlight or filter specific records.</li>
    </ul>
  </li>
  <li><strong>Caching</strong>:
    <ul>
      <li>Cache frequently accessed sorted data (e.g., exchange rates) in Redis or an in-memory store.</li>
      <li>Use binary search to query the cache for fast lookups.</li>
    </ul>
  </li>
</ol>

<h3 id="conclusion">Conclusion</h3>
<p>Binary search is a powerful tool for your finance project when dealing with <strong>sorted, static, or semi-static data</strong> in memory, either in the backend (e.g., after SQL queries) or frontend (e.g., Angular tables). It’s particularly useful for large datasets where O(log n) performance is beneficial, such as transaction lookups, time-series data searches, or cached data queries. However, ensure the data is sorted, and consider alternatives like database indexes or hash maps for unsorted or dynamic data. If you have specific datasets or use cases in mind, let me know, and I can tailor the examples further!</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
