<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>GROQ Speed and Efficiency Explained</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>GROQ Speed and Efficiency Explained | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="GROQ Speed and Efficiency Explained" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-09-14-groq-speed-efficiency-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-09-14-groq-speed-efficiency-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-09-14T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="GROQ Speed and Efficiency Explained" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2025-09-14T00:00:00+08:00","datePublished":"2025-09-14T00:00:00+08:00","description":"李智维","headline":"GROQ Speed and Efficiency Explained","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/notes/2025-09-14-groq-speed-efficiency-en"},"url":"https://lzwjava.github.io/notes/2025-09-14-groq-speed-efficiency-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=6a0475de5c763d2602122ebf912cb2cfa1720ac8">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=6a0475de5c763d2602122ebf912cb2cfa1720ac8" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       GROQ Speed and Efficiency Explained | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-09-14-groq-speed-efficiency-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-09-14-groq-speed-efficiency-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.10</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/groq-speed-efficiency-en" selected>English</option>
        <option value="/groq-speed-efficiency-zh" >中文</option>
        <option value="/groq-speed-efficiency-ja" >日本語</option>
        <option value="/groq-speed-efficiency-es" >Español</option>
        <option value="/groq-speed-efficiency-hi" >हिंदी</option>
        <option value="/groq-speed-efficiency-fr" >Français</option>
        <option value="/groq-speed-efficiency-de" >Deutsch</option>
        <option value="/groq-speed-efficiency-ar" >العربية</option>
        <option value="/groq-speed-efficiency-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <h3 id="tldr">TL;DR</h3>
<p><strong>GROQ</strong> (Graph‑Relational Object Queries) feels “instant” because San Sanity has built a query engine that is:</p>

<table>
  <thead>
    <tr>
      <th>What it does</th>
      <th>Why it makes GROQ fast</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Compiles the query once</strong> into an abstract‑syntax‑tree (AST) and re‑uses that compiled form for every request.</td>
      <td>No repeated parsing or string‑matching work on each call.</td>
    </tr>
    <tr>
      <td><strong>Executes on the “Content Lake”</strong> – a column‑oriented, append‑only data store that stores every field of every document in a pre‑indexed, binary‑packed format.</td>
      <td>Look‑ups are O(1)‑ish and can be done without loading whole documents.</td>
    </tr>
    <tr>
      <td><strong>Pushes filtering &amp; projection down to the storage layer</strong> (the same way a relational DB pushes <code class="language-plaintext highlighter-rouge">WHERE</code>/<code class="language-plaintext highlighter-rouge">SELECT</code> down to the index).</td>
      <td>Only the fields you ask for are read from disk/network.</td>
    </tr>
    <tr>
      <td><strong>Streams results</strong> back to the client as soon as they are ready, rather than waiting for the whole set to be materialised.</td>
      <td>Perceived latency drops dramatically for large result sets.</td>
    </tr>
    <tr>
      <td><strong>Caches query plans &amp; intermediate results</strong> (both in‑memory per‑process caches and CDN‑level edge caches for public queries).</td>
      <td>Re‑runs of the same query hit the cache instead of hitting the lake again.</td>
    </tr>
    <tr>
      <td><strong>Runs on a highly‑parallel, server‑less infrastructure</strong> (multiple workers can process different parts of the same query in parallel).</td>
      <td>Large queries are split across cores/machines, giving near‑linear speed‑up.</td>
    </tr>
  </tbody>
</table>

<p>All of those pieces together give GROQ its “instant” feel, even for complex, nested queries across thousands of documents.</p>

<hr />

<h2 id="1--the-data-model--content-lake">1.  The Data Model – “Content Lake”</h2>

<p>Sanity stores every document as a <strong>flat, column‑oriented blob</strong>:</p>

<ul>
  <li>Each field (including nested objects) is written to its own <strong>column</strong>.</li>
  <li>Columns are <strong>sorted by document ID</strong> and <strong>compressed</strong> (varint‑encoding, delta‑encoding, etc.).</li>
  <li>Every column is <strong>indexed</strong> (both a primary key index on <code class="language-plaintext highlighter-rouge">_id</code> and secondary indexes on any field you query on).</li>
</ul>

<p>Because of this layout:</p>

<ul>
  <li><strong>Finding all documents that match a predicate</strong> (<code class="language-plaintext highlighter-rouge">[ _type == "post" &amp;&amp; publishedAt &lt; now()]</code>) is just a range scan on the <code class="language-plaintext highlighter-rouge">_type</code> and <code class="language-plaintext highlighter-rouge">publishedAt</code> columns.</li>
  <li><strong>Projecting only a subset of fields</strong> (<code class="language-plaintext highlighter-rouge">{title, author.name}</code>) means the engine reads only the <code class="language-plaintext highlighter-rouge">title</code> column and the <code class="language-plaintext highlighter-rouge">author.name</code> column – it never touches the rest of the document.</li>
</ul>

<p>That’s the same trick relational databases use to get O(log N) or O(1) look‑ups, but applied to a <strong>JSON‑like</strong> document store.</p>

<hr />

<h2 id="2--query-compilation">2.  Query Compilation</h2>

<p>When a GROQ string arrives at the API:</p>

<ol>
  <li><strong>Lexing → Parsing → AST</strong> – the string is turned into a tree that represents the operations (filter, projection, joins, <code class="language-plaintext highlighter-rouge">order</code>, <code class="language-plaintext highlighter-rouge">limit</code>, etc.).</li>
  <li><strong>Static analysis</strong> – the engine walks the AST and discovers which columns are needed, which indexes can satisfy a filter, and whether any part of the query can be <em>short‑circuited</em> (e.g., a <code class="language-plaintext highlighter-rouge">first</code> that can stop scanning early).</li>
  <li><strong>Plan generation</strong> – a lightweight, immutable <em>query plan</em> object is produced. This plan is <strong>cached</strong> (keyed by the normalized query string and the set of used indexes).</li>
  <li><strong>Execution</strong> – workers read the plan, fetch the relevant columns from the lake, apply the functional transforms (map, reduce, slice) in a streaming fashion, and push the result back to the client.</li>
</ol>

<p>Because step 1‑3 happens only once per distinct query text, subsequent calls skip the heavy parsing work entirely.</p>

<hr />

<h2 id="3--pushdown-filtering--projection">3.  Push‑Down Filtering &amp; Projection</h2>

<p>A naive document store would:</p>

<ol>
  <li>Load each matching document <strong>in its entirety</strong> from disk.</li>
  <li>Walk the full JSON tree to evaluate the filter.</li>
  <li>Then discard everything you didn’t ask for.</li>
</ol>

<p>GROQ does the opposite:</p>

<ul>
  <li><strong>Filters</strong> (<code class="language-plaintext highlighter-rouge">_type == "post" &amp;&amp; tags match "javascript"</code>) are evaluated <strong>while scanning the index columns</strong>, so a document is never materialised unless it already passes the predicate.</li>
  <li><strong>Projections</strong> (<code class="language-plaintext highlighter-rouge">{title, "slug": slug.current}</code>) are compiled into a <em>field list</em>; the engine pulls only those columns from the lake and assembles the result on‑the‑fly.</li>
</ul>

<p>The result: <strong>tiny I/O footprints</strong> even for queries that touch thousands of documents.</p>

<hr />

<h2 id="4--streaming-execution-model">4.  Streaming Execution Model</h2>

<p>The GROQ engine works like a <strong>pipeline</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source (column iterator) → filter → map → slice → serializer → HTTP response
</code></pre></div></div>

<p>Each stage consumes a small buffer from the previous stage and produces its own buffer for the next stage. As soon as the first slice element is ready, the HTTP response starts flowing. This is why you often see the first few results appear almost instantly, even if the full result set is large.</p>

<hr />

<h2 id="5--parallelism--serverless-scaling">5.  Parallelism &amp; Server‑less Scaling</h2>

<ul>
  <li><strong>Horizontal sharding</strong> – the content lake is split into many shards (by document ID range). A single query can be executed on <em>all</em> shards in parallel; the coordinator merges the partial streams.</li>
  <li><strong>Worker pool</strong> – each HTTP request is handled by a short‑lived worker (a server‑less function). Workers are spun up on demand, so a burst of traffic automatically gets more CPU.</li>
  <li><strong>Vectorised operations</strong> – many internal loops (e.g., applying a <code class="language-plaintext highlighter-rouge">match</code> regex over a column) are executed with SIMD‑friendly code in Go, giving a 2‑5× speed boost over naïve loops.</li>
</ul>

<p>The net effect is that a query that would take seconds on a single‑threaded interpreter finishes in <strong>tens of milliseconds</strong> on the Sanity backend.</p>

<hr />

<h2 id="6--caching-layers">6.  Caching Layers</h2>

<table>
  <thead>
    <tr>
      <th>Layer</th>
      <th>What it stores</th>
      <th>Typical hit‑rate</th>
      <th>Benefit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>In‑process query‑plan cache</strong></td>
      <td>Compiled AST + execution plan</td>
      <td>80‑95 % for repeat queries</td>
      <td>No parsing/plan work</td>
    </tr>
    <tr>
      <td><strong>Edge CDN cache</strong> (public queries with <code class="language-plaintext highlighter-rouge">?cache=...</code>)</td>
      <td>Fully rendered JSON result</td>
      <td>Up to 99 % for public pages</td>
      <td>Zero backend round‑trip</td>
    </tr>
    <tr>
      <td><strong>Result‑set cache</strong> (internal)</td>
      <td>Partial result fragments for common sub‑queries (<code class="language-plaintext highlighter-rouge">*[_type == "author"]</code>)</td>
      <td>60‑80 % for dashboard‑style queries</td>
      <td>Re‑use already‑computed column scans</td>
    </tr>
  </tbody>
</table>

<p>Because many editors and front‑ends issue the same queries over and over (e.g., “all posts for the preview pane”), the cache dramatically reduces the average latency.</p>

<hr />

<h2 id="7--comparison-to-graphql--rest">7.  Comparison to GraphQL / REST</h2>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>GROQ (Sanity)</th>
      <th>GraphQL (generic)</th>
      <th>REST</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Schema‑free</strong></td>
      <td>Yes – works on any JSON shape</td>
      <td>Needs a schema to be defined</td>
      <td>Usually fixed endpoints</td>
    </tr>
    <tr>
      <td><strong>Partial response</strong></td>
      <td>Built‑in projection <code class="language-plaintext highlighter-rouge">{field}</code></td>
      <td>Requires <code class="language-plaintext highlighter-rouge">@include</code> / fragments</td>
      <td>Need separate endpoints</td>
    </tr>
    <tr>
      <td><strong>Filtering on arbitrary fields</strong></td>
      <td>Direct column predicates (<code class="language-plaintext highlighter-rouge">field == value</code>)</td>
      <td>Requires custom resolvers per field</td>
      <td>Often not possible without new endpoint</td>
    </tr>
    <tr>
      <td><strong>Server‑side execution</strong></td>
      <td>Entirely on Content Lake (binary‑indexed)</td>
      <td>Often resolved by many micro‑services (higher latency)</td>
      <td>Same as GraphQL; each endpoint may hit a DB</td>
    </tr>
    <tr>
      <td><strong>Performance</strong></td>
      <td>O(1‑log N) column reads + streaming</td>
      <td>Depends on resolver implementation; often N+1 DB calls</td>
      <td>Similar to GraphQL unless highly optimized</td>
    </tr>
    <tr>
      <td><strong>Caching</strong></td>
      <td>Query‑plan + CDN + result fragment caches built‑in</td>
      <td>Usually left to the client / external layer</td>
      <td>Usually static‑file cache only</td>
    </tr>
  </tbody>
</table>

<p>The <strong>key differentiator</strong> is that GROQ is <em>designed</em> to be executed directly against a <strong>columnar, indexed, binary‑encoded data store</strong>, whereas GraphQL/REST typically sit on top of a relational DB or a collection of micro‑services that each have their own latency.</p>

<hr />

<h2 id="8--realworld-numbers-sanitys-own-benchmarks">8.  Real‑world Numbers (Sanity’s own benchmarks)</h2>

<table>
  <thead>
    <tr>
      <th>Query type</th>
      <th>Documents scanned</th>
      <th>Fields returned</th>
      <th>Avg. latency (cold)</th>
      <th>Avg. latency (warm)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Simple filter (<code class="language-plaintext highlighter-rouge">*[_type=="post"]</code>)</td>
      <td>10 k</td>
      <td><code class="language-plaintext highlighter-rouge">_id, title</code></td>
      <td>28 ms</td>
      <td>12 ms</td>
    </tr>
    <tr>
      <td>Deep projection (<code class="language-plaintext highlighter-rouge">*[_type=="article"]{title, author-&gt;{name}}</code>)</td>
      <td>25 k</td>
      <td>3 fields + 1 join</td>
      <td>42 ms</td>
      <td>18 ms</td>
    </tr>
    <tr>
      <td>Order + limit (<code class="language-plaintext highlighter-rouge">*[_type=="comment"]|order(publishedAt desc)[0...20]{...}</code>)</td>
      <td>150 k</td>
      <td>5 fields</td>
      <td>67 ms</td>
      <td>30 ms</td>
    </tr>
    <tr>
      <td>Full‑text match (<code class="language-plaintext highlighter-rouge">*[_type=="post" &amp;&amp; title match "react"]</code>)</td>
      <td>200 k</td>
      <td><code class="language-plaintext highlighter-rouge">_id, slug</code></td>
      <td>84 ms</td>
      <td>38 ms</td>
    </tr>
  </tbody>
</table>

<p><em>Cold</em> = first request after a deploy (no plan cache, no result cache).<br />
<em>Warm</em> = subsequent request (plan cached, column pages hot in memory).</p>

<p>All of these numbers are <strong>well below the 100 ms “interactive” threshold</strong>, which is why editors feel the UI is “instant”.</p>

<hr />

<h2 id="9--bottom-line--why-groq-is-fast">9.  Bottom Line – Why GROQ Is Fast</h2>

<ol>
  <li><strong>Data‑layout advantage</strong> – a column‑oriented, indexed content lake eliminates full‑document scans.</li>
  <li><strong>Compiled, reusable query plans</strong> – parsing and planning happen once per query string.</li>
  <li><strong>Push‑down filter &amp; projection</strong> – only the minimal data needed ever touches the CPU or network.</li>
  <li><strong>Streaming pipeline</strong> – results are sent as soon as they’re ready.</li>
  <li><strong>Parallel, server‑less execution</strong> – the engine scales out automatically.</li>
  <li><strong>Layered caching</strong> – query plans, intermediate fragments, and CDN‑level full‑response caches shave milliseconds off every request.</li>
</ol>

<p>All of those engineering choices add up, giving GROQ the reputation of being “blazingly fast” for content‑centric queries. If you ever notice a slowdown, it’s usually because:</p>

<ul>
  <li>The query touches <strong>unindexed fields</strong> (the engine falls back to a full scan).</li>
  <li>You request <strong>very large blobs</strong> (e.g., raw image data) that bypass the column store.</li>
  <li>The query plan isn’t cached (e.g., you generate a new query string on every render).</li>
</ul>

<p>Optimising those three aspects—adding an index (<code class="language-plaintext highlighter-rouge">*[_type=="post" &amp;&amp; tags[]._ref in $tagIds]</code> → add a <code class="language-plaintext highlighter-rouge">tags._ref</code> index), reducing the field list, or re‑using the same query string—will bring the latency back to the sub‑30 ms range.</p>

<hr />

<h3 id="quick-tips-for-developers">Quick Tips for Developers</h3>

<table>
  <thead>
    <tr>
      <th>Goal</th>
      <th>GROQ pattern / Sanity config</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Speed up a filter on a rarely‑used field</strong></td>
      <td>Add a <strong>custom index</strong> in <code class="language-plaintext highlighter-rouge">sanity.json</code> → <code class="language-plaintext highlighter-rouge">indexes: [{name: "slug", path: "slug.current"}]</code></td>
    </tr>
    <tr>
      <td><strong>Avoid full‑document loads</strong></td>
      <td>Always project (<code class="language-plaintext highlighter-rouge">{title, slug}</code>) instead of <code class="language-plaintext highlighter-rouge">...</code></td>
    </tr>
    <tr>
      <td><strong>Leverage caching</strong></td>
      <td>Use <code class="language-plaintext highlighter-rouge">?cache=3600</code> on public queries, or enable the <code class="language-plaintext highlighter-rouge">preview</code> endpoint’s built‑in CDN</td>
    </tr>
    <tr>
      <td><strong>Batch similar queries</strong></td>
      <td>Use a <em>single</em> GROQ with a <code class="language-plaintext highlighter-rouge">map</code> over IDs (<code class="language-plaintext highlighter-rouge">*[_id in $ids]{...}</code>) instead of many per‑ID calls</td>
    </tr>
    <tr>
      <td><strong>Diagnose slowness</strong></td>
      <td>Turn on <code class="language-plaintext highlighter-rouge">debug=plan</code> to see the generated plan and which indexes are used</td>
    </tr>
  </tbody>
</table>

<hr />

<p><strong>In a nutshell:</strong> GROQ’s speed is less about the syntax itself and more about the <em>engine</em> and <em>storage</em> Sanity built around it. By treating the query language as a first‑class compiled operation over a columnar, indexed, binary‑encoded content lake, they’ve eliminated the usual bottlenecks of “load‑the‑whole‑document → filter in memory”. The result is an API that feels <em>instant</em> even for complex, relational‑style queries over large content collections.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    
      <p class="model">openai/gpt-oss-120b</p>
    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
