<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Garbage Collection in Java</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Garbage Collection in Java | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Garbage Collection in Java" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-03-27-java-garbage-collection-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-03-27-java-garbage-collection-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Garbage Collection in Java" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Garbage Collection in Java","url":"https://lzwjava.github.io/notes/2025-03-27-java-garbage-collection-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=652cb04173a53a4facbf7c624ecf758b93a918e0">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=652cb04173a53a4facbf7c624ecf758b93a918e0" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Garbage Collection in Java | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-03-27-java-garbage-collection-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-03-27-java-garbage-collection-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.10</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/java-garbage-collection-en" selected>English</option>
        <option value="/java-garbage-collection-zh" >中文</option>
        <option value="/java-garbage-collection-ja" >日本語</option>
        <option value="/java-garbage-collection-es" >Español</option>
        <option value="/java-garbage-collection-hi" >हिंदी</option>
        <option value="/java-garbage-collection-fr" >Français</option>
        <option value="/java-garbage-collection-de" >Deutsch</option>
        <option value="/java-garbage-collection-ar" >العربية</option>
        <option value="/java-garbage-collection-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Okay, let’s learn about Garbage Collection (GC) in Java! It’s a crucial aspect of Java’s memory management that helps developers avoid manual memory allocation and deallocation.</p>

<p><strong>What is Garbage Collection in Java?</strong></p>

<p>Garbage Collection is the automatic process of reclaiming memory occupied by objects that are no longer in use by a Java application. In essence, it’s Java’s way of cleaning up the “garbage” (unused objects) to make space for new objects.</p>

<p><strong>Why is Garbage Collection Needed?</strong></p>

<p>In many other programming languages (like C or C++), developers are responsible for explicitly allocating and deallocating memory using functions like <code class="language-plaintext highlighter-rouge">malloc</code> and <code class="language-plaintext highlighter-rouge">free</code>. This manual memory management can lead to several problems:</p>

<ul>
  <li><strong>Memory Leaks:</strong> If memory is allocated but never freed, the application can eventually run out of memory and crash.</li>
  <li><strong>Dangling Pointers:</strong> If memory is freed but a pointer still refers to that memory location, using that pointer can lead to unpredictable behavior or crashes.</li>
  <li><strong>Increased Development Complexity:</strong> Managing memory manually adds a significant layer of complexity to software development.</li>
</ul>

<p>Java’s Garbage Collection automates this process, freeing developers from the burden of manual memory management and making it easier to write safer and more reliable code.</p>

<p><strong>How Does Garbage Collection Work?</strong></p>

<p>The core idea behind garbage collection is to identify which objects in memory are still being used by the application and which are not. The garbage collector then reclaims the memory occupied by the unused objects.</p>

<p>Here’s a simplified overview of the process:</p>

<ol>
  <li><strong>Identifying Live Objects (Marking):</strong> The garbage collector starts by identifying the set of objects that are still reachable from the “root” objects. Root objects are typically objects that are directly accessible by the application, such as:
    <ul>
      <li>Local variables in currently executing methods.</li>
      <li>Static variables.</li>
      <li>Objects referenced by native code.</li>
      <li>The Java Virtual Machine’s (JVM) active threads.</li>
    </ul>

    <p>The garbage collector traverses the object graph starting from these roots, marking all the objects that are reachable.</p>
  </li>
  <li>
    <p><strong>Reclaiming Memory (Sweeping and Compacting):</strong> Once the live objects are marked, the garbage collector needs to reclaim the memory occupied by the unmarked (unreachable) objects. Different garbage collection algorithms employ different strategies for this:</p>

    <ul>
      <li><strong>Mark and Sweep:</strong> This algorithm identifies and marks the live objects, then sweeps through the memory, freeing the space occupied by the unmarked objects. This can lead to memory fragmentation (small, scattered blocks of free memory that are not large enough to allocate new objects).</li>
      <li><strong>Mark and Compact:</strong> This algorithm also marks live objects. After marking, it moves (compacts) the live objects together in memory, eliminating fragmentation and making it easier to allocate contiguous blocks of memory for new objects.</li>
      <li><strong>Copying:</strong> This algorithm divides the memory into two or more regions. Live objects are copied from one region to another, effectively reclaiming the space in the original region.</li>
    </ul>
  </li>
</ol>

<p><strong>Key Concepts in Java Garbage Collection:</strong></p>

<ul>
  <li><strong>Heap:</strong> The area of memory where objects are allocated in Java. The garbage collector primarily operates on the heap.</li>
  <li><strong>Young Generation (Nursery):</strong> This is a portion of the heap where newly created objects are initially allocated. It’s further divided into:
    <ul>
      <li><strong>Eden Space:</strong> Where most new objects are created.</li>
      <li><strong>Survivor Spaces (S0 and S1):</strong> Used to hold objects that have survived a few minor garbage collection cycles.</li>
    </ul>
  </li>
  <li><strong>Old Generation (Tenured Generation):</strong> Objects that have survived multiple garbage collection cycles in the young generation are eventually moved to the old generation. Objects in the old generation are generally long-lived.</li>
  <li><strong>Permanent Generation (PermGen) / Metaspace:</strong> In older versions of Java (before Java 8), the Permanent Generation stored metadata about classes and methods. In Java 8 and later, this has been replaced by Metaspace, which is part of native memory (not the Java heap).</li>
  <li><strong>Garbage Collection Algorithms:</strong> Different algorithms are used for garbage collection, each with its own trade-offs in terms of performance and efficiency.</li>
</ul>

<p><strong>Generational Garbage Collection:</strong></p>

<p>Java HotSpot JVM (the most common JVM) uses a generational approach to garbage collection. This is based on the observation that most objects in an application have short lifespans.</p>

<ol>
  <li>
    <p><strong>Minor GC (Young Generation GC):</strong> When the Eden space becomes full, a minor GC is triggered. Live objects from Eden and one of the Survivor spaces (say, S0) are copied to the other Survivor space (S1). Objects that have survived a certain number of minor GC cycles are moved to the old generation. Unreachable objects are discarded.</p>
  </li>
  <li>
    <p><strong>Major GC (Old Generation GC) / Full GC:</strong> When the old generation becomes full, a major GC (or sometimes a full GC, which can involve both young and old generations) is performed. This process is generally more time-consuming than a minor GC and can cause longer pauses in the application’s execution.</p>
  </li>
</ol>

<p><strong>Common Garbage Collectors in Java HotSpot JVM:</strong></p>

<p>The Java HotSpot JVM offers several garbage collection algorithms that can be chosen based on the application’s requirements (e.g., low latency, high throughput). Some common ones include:</p>

<ul>
  <li><strong>Serial Collector:</strong> Uses a single thread for garbage collection. Suitable for small applications with limited resources.</li>
  <li><strong>Parallel Collector:</strong> Uses multiple threads for garbage collection, improving throughput. Suitable for applications with moderate to large data sets running on multi-core processors.</li>
  <li><strong>CMS (Concurrent Mark Sweep) Collector:</strong> Tries to minimize pause times by performing most of the garbage collection work concurrently with the application threads. However, it can lead to fragmentation and might require a full GC eventually.</li>
  <li><strong>G1 (Garbage-First) Collector:</strong> Aims to provide a good balance between throughput and low latency. It divides the heap into regions and prioritizes collecting garbage from regions with the most garbage. It’s the default collector in Java 9 and later.</li>
  <li><strong>ZGC (Z Garbage Collector):</strong> A low-latency garbage collector designed for large heaps. It aims for pause times of less than 10ms.</li>
  <li><strong>Shenandoah:</strong> Another low-latency garbage collector with similar goals to ZGC.</li>
</ul>

<p>You can specify which garbage collector to use via JVM command-line options.</p>

<p><strong>When Does Garbage Collection Run?</strong></p>

<p>Garbage collection is mostly an automatic process driven by the JVM. It typically runs when:</p>

<ul>
  <li>The young generation (Eden space) becomes full.</li>
  <li>The old generation becomes full.</li>
  <li>The system is low on memory.</li>
</ul>

<p>While you cannot directly control <em>when</em> garbage collection will run, you can suggest to the JVM that it might be a good time to perform garbage collection using <code class="language-plaintext highlighter-rouge">System.gc()</code>. However, there’s no guarantee that the JVM will actually run the garbage collector immediately or at all when you call this method. It’s generally better to rely on the JVM’s automatic garbage collection mechanism.</p>

<p><strong><code class="language-plaintext highlighter-rouge">System.gc()</code> and Finalization:</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">System.gc()</code>:</strong> As mentioned, this is a request to the JVM to run the garbage collector. It’s often advised to avoid relying on this method for critical memory management, as the JVM is usually better at deciding when to perform GC.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">finalize()</code> Method:</strong> Before an object is garbage collected, the JVM gives it a chance to perform any cleanup operations by calling its <code class="language-plaintext highlighter-rouge">finalize()</code> method (if it’s implemented). However, <code class="language-plaintext highlighter-rouge">finalize()</code> has several drawbacks and is generally discouraged in modern Java development. It can introduce performance issues and make garbage collection less predictable. Consider using other mechanisms like try-with-resources for resource management.</li>
</ul>

<p><strong>Impact of Garbage Collection on Application Performance:</strong></p>

<p>While garbage collection is essential for memory management, it can also impact the performance of an application due to the “stop-the-world” pauses. During these pauses, all application threads are stopped while the garbage collector performs its work. The duration and frequency of these pauses depend on the garbage collection algorithm being used and the size and characteristics of the heap.</p>

<p>Low-latency garbage collectors like G1, ZGC, and Shenandoah aim to minimize these pause times to make applications more responsive.</p>

<p><strong>Tuning Garbage Collection:</strong></p>

<p>For applications with specific performance requirements, garbage collection can be tuned by adjusting JVM parameters such as:</p>

<ul>
  <li>Heap size (<code class="language-plaintext highlighter-rouge">-Xms</code>, <code class="language-plaintext highlighter-rouge">-Xmx</code>)</li>
  <li>Young generation size (<code class="language-plaintext highlighter-rouge">-Xmn</code>)</li>
  <li>Survivor ratios (<code class="language-plaintext highlighter-rouge">-XX:SurvivorRatio</code>)</li>
  <li>Choosing a specific garbage collector (<code class="language-plaintext highlighter-rouge">-XX:+UseG1GC</code>, <code class="language-plaintext highlighter-rouge">-XX:+UseZGC</code>, etc.)</li>
  <li>Setting garbage collection flags for more fine-grained control.</li>
</ul>

<p>GC tuning is an advanced topic and usually requires careful analysis of the application’s behavior and performance.</p>

<p><strong>Best Practices for Writing Garbage Collector-Friendly Code:</strong></p>

<p>While Java handles memory management automatically, writing code with the garbage collector in mind can lead to better performance:</p>

<ul>
  <li><strong>Minimize Object Creation:</strong> Creating a large number of short-lived objects can put pressure on the garbage collector. Try to reuse objects when appropriate.</li>
  <li><strong>Release Object References:</strong> If you have a reference to an object that you no longer need, set the reference to <code class="language-plaintext highlighter-rouge">null</code>. This makes the object eligible for garbage collection sooner.</li>
  <li><strong>Use Data Structures Wisely:</strong> Choose data structures that are appropriate for your needs. For example, using a large <code class="language-plaintext highlighter-rouge">ArrayList</code> and then discarding most of its elements can be inefficient.</li>
  <li><strong>Avoid Finalizers:</strong> As mentioned earlier, avoid relying on the <code class="language-plaintext highlighter-rouge">finalize()</code> method for resource cleanup. Use try-with-resources for resources like files and network connections.</li>
  <li><strong>Be Mindful of Static Variables:</strong> Objects referenced by static variables will live for the entire duration of the application, so be cautious about storing large or unnecessary objects in static fields.</li>
</ul>

<p><strong>In Summary:</strong></p>

<p>Garbage Collection in Java is an automatic memory management process that reclaims memory occupied by unused objects. It simplifies development by freeing developers from manual memory management. Understanding how it works, the different generations of the heap, and the available garbage collection algorithms can help you write more efficient and performant Java applications.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
