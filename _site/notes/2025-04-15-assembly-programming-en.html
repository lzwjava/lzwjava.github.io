<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Assembly Language Programming</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Assembly Language Programming | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Assembly Language Programming" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-04-15-assembly-programming-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-04-15-assembly-programming-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Assembly Language Programming" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Assembly Language Programming","url":"https://lzwjava.github.io/notes/2025-04-15-assembly-programming-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=aa8525dd3b9385f3575f7ff51dabb8a21e8f2f54">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=aa8525dd3b9385f3575f7ff51dabb8a21e8f2f54" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Assembly Language Programming | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-04-15-assembly-programming-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-04-15-assembly-programming-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.10</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/assembly-programming-en" selected>English</option>
        <option value="/assembly-programming-zh" >中文</option>
        <option value="/assembly-programming-ja" >日本語</option>
        <option value="/assembly-programming-es" >Español</option>
        <option value="/assembly-programming-hi" >हिंदी</option>
        <option value="/assembly-programming-fr" >Français</option>
        <option value="/assembly-programming-de" >Deutsch</option>
        <option value="/assembly-programming-ar" >العربية</option>
        <option value="/assembly-programming-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Below is a comprehensive tutorial for <strong>Part 2: Assembly Language Programming</strong>, covering the topics outlined: <em>8086 Instruction Set (Data Transfer, Arithmetic, Logic, and Control Flow Instructions), Assembly Language Programming (Sequential, Branch, and Loop Structures), and Interrupt Service Routines</em>. This tutorial is designed to be thorough, accessible, and practical, building on the fundamentals of microcomputers (e.g., 8086/8088 architecture). It assumes basic knowledge of CPU registers and memory addressing.</p>

<hr />

<h2 id="part-2-assembly-language-programming">Part 2: Assembly Language Programming</h2>

<p>Assembly language is a low-level programming language that provides direct control over a microprocessor’s operations. For the Intel 8086/8088, assembly language allows programmers to write instructions that map closely to machine code, offering fine-grained control over hardware resources like registers, memory, and I/O devices.</p>

<h3 id="1-8086-instruction-set">1. 8086 Instruction Set</h3>

<p>The 8086 instruction set is a collection of commands that the CPU understands, categorized by their function: <strong>data transfer</strong>, <strong>arithmetic</strong>, <strong>logic</strong>, and <strong>control flow</strong>. Each instruction operates on registers, memory, or immediate values, using the 8086’s addressing modes (e.g., register, direct, indirect).</p>

<h4 id="a-data-transfer-instructions">a. Data Transfer Instructions</h4>
<p>These instructions move data between registers, memory, and immediate values.</p>

<ul>
  <li><strong>MOV (Move)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">MOV destination, source</code></li>
      <li>Function: Copies data from source to destination.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">MOV AX, BX</code> (copy BX to AX); <code class="language-plaintext highlighter-rouge">MOV AX, [1234h]</code> (copy data from memory address DS:1234h to AX).</li>
      <li>Notes: Does not affect flags; source and destination must be the same size (8-bit or 16-bit).</li>
    </ul>
  </li>
  <li><strong>XCHG (Exchange)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">XCHG destination, source</code></li>
      <li>Function: Swaps contents of source and destination.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">XCHG AX, BX</code> (swap AX and BX).</li>
    </ul>
  </li>
  <li><strong>PUSH (Push onto Stack)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">PUSH source</code></li>
      <li>Function: Pushes 16-bit data onto the stack, decrements SP by 2.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">PUSH AX</code> (save AX on stack).</li>
    </ul>
  </li>
  <li><strong>POP (Pop from Stack)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">POP destination</code></li>
      <li>Function: Pops 16-bit data from stack to destination, increments SP by 2.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">POP BX</code> (restore BX from stack).</li>
    </ul>
  </li>
  <li><strong>LEA (Load Effective Address)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">LEA destination, source</code></li>
      <li>Function: Loads the address of a memory operand into a register.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">LEA BX, [SI+4]</code> (load address of DS:SI+4 into BX).</li>
    </ul>
  </li>
  <li><strong>IN/OUT</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">IN destination, port</code>; <code class="language-plaintext highlighter-rouge">OUT port, source</code></li>
      <li>Function: Transfers data to/from I/O ports.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">IN AL, 60h</code> (read keyboard port); <code class="language-plaintext highlighter-rouge">OUT 61h, AL</code> (write to speaker port).</li>
    </ul>
  </li>
</ul>

<h4 id="b-arithmetic-instructions">b. Arithmetic Instructions</h4>
<p>These perform mathematical operations, updating flags (e.g., ZF, CF, SF, OF) based on results.</p>

<ul>
  <li><strong>ADD (Add)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">ADD destination, source</code></li>
      <li>Function: Adds source to destination, stores result in destination.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">ADD AX, BX</code> (AX = AX + BX).</li>
    </ul>
  </li>
  <li><strong>SUB (Subtract)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">SUB destination, source</code></li>
      <li>Function: Subtracts source from destination.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">SUB CX, 10</code> (CX = CX - 10).</li>
    </ul>
  </li>
  <li><strong>INC (Increment)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">INC destination</code></li>
      <li>Function: Increments destination by 1.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">INC BX</code> (BX = BX + 1).</li>
    </ul>
  </li>
  <li><strong>DEC (Decrement)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">DEC destination</code></li>
      <li>Function: Decrements destination by 1.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">DEC CX</code> (CX = CX - 1).</li>
    </ul>
  </li>
  <li><strong>MUL (Multiply, Unsigned)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">MUL source</code></li>
      <li>Function: Multiplies AL (8-bit) or AX (16-bit) by source, stores result in AX or DX:AX.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">MUL BX</code> (DX:AX = AX * BX).</li>
    </ul>
  </li>
  <li><strong>DIV (Divide, Unsigned)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">DIV source</code></li>
      <li>Function: Divides AX (8-bit) or DX:AX (16-bit) by source, stores quotient in AL/AX, remainder in AH/DX.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">DIV BX</code> (AX = DX:AX / BX, DX = remainder).</li>
    </ul>
  </li>
  <li><strong>ADC (Add with Carry)</strong> and <strong>SBB (Subtract with Borrow)</strong>:
    <ul>
      <li>Function: Handle multi-word arithmetic using the carry flag.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">ADC AX, BX</code> (AX = AX + BX + CF).</li>
    </ul>
  </li>
</ul>

<h4 id="c-logic-instructions">c. Logic Instructions</h4>
<p>These perform bitwise operations and manipulate binary data.</p>

<ul>
  <li><strong>AND (Bitwise AND)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">AND destination, source</code></li>
      <li>Function: Performs bitwise AND, stores result in destination.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">AND AX, 0FFh</code> (clear upper byte of AX).</li>
    </ul>
  </li>
  <li><strong>OR (Bitwise OR)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">OR destination, source</code></li>
      <li>Function: Performs bitwise OR.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">OR BX, 1000h</code> (set bit 12 in BX).</li>
    </ul>
  </li>
  <li><strong>XOR (Bitwise XOR)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">XOR destination, source</code></li>
      <li>Function: Performs bitwise XOR.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">XOR AX, AX</code> (clear AX to 0).</li>
    </ul>
  </li>
  <li><strong>NOT (Bitwise NOT)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">NOT destination</code></li>
      <li>Function: Inverts all bits in destination.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">NOT BX</code> (BX = ~BX).</li>
    </ul>
  </li>
  <li><strong>SHL/SHR (Shift Left/Right)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">SHL destination, count</code>; <code class="language-plaintext highlighter-rouge">SHR destination, count</code></li>
      <li>Function: Shifts bits left/right, fills with 0 (SHR) or sign bit (SAL/SAR).</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">SHL AX, 1</code> (AX = AX * 2).</li>
    </ul>
  </li>
  <li><strong>ROL/ROR (Rotate Left/Right)</strong>:
    <ul>
      <li>Function: Rotates bits, wrapping around through carry flag.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">ROL BX, 1</code> (rotate BX left by 1 bit).</li>
    </ul>
  </li>
</ul>

<h4 id="d-control-flow-instructions">d. Control Flow Instructions</h4>
<p>These alter the program’s execution sequence, enabling jumps, loops, and subroutines.</p>

<ul>
  <li><strong>JMP (Jump)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">JMP label</code></li>
      <li>Function: Unconditionally jumps to a label.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">JMP start</code> (goto label <code class="language-plaintext highlighter-rouge">start</code>).</li>
      <li>Variants:
        <ul>
          <li>Short jump (±127 bytes).</li>
          <li>Near jump (within segment).</li>
          <li>Far jump (different segment).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Conditional Jumps</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">Jcc label</code> (e.g., JZ, JNZ, JC, JNC)</li>
      <li>Function: Jumps based on flag states.</li>
      <li>Examples:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">JZ loop_end</code> (jump if zero flag set).</li>
          <li><code class="language-plaintext highlighter-rouge">JC error</code> (jump if carry flag set).</li>
          <li>Common conditions: JZ (zero), JNZ (not zero), JS (sign), JO (overflow).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>LOOP (Loop)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">LOOP label</code></li>
      <li>Function: Decrements CX, jumps to label if CX ≠ 0.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">LOOP process</code> (repeat until CX = 0).</li>
      <li>Variants:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">LOOPE/LOOPZ</code>: Loop if CX ≠ 0 and ZF = 1.</li>
          <li><code class="language-plaintext highlighter-rouge">LOOPNE/LOOPNZ</code>: Loop if CX ≠ 0 and ZF = 0.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>CALL (Call Subroutine)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">CALL label</code></li>
      <li>Function: Pushes return address onto stack, jumps to subroutine.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">CALL compute_sum</code> (call subroutine).</li>
    </ul>
  </li>
  <li><strong>RET (Return)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">RET</code></li>
      <li>Function: Pops return address from stack, resumes execution.</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">RET</code> (return from subroutine).</li>
    </ul>
  </li>
  <li><strong>INT (Interrupt)</strong>:
    <ul>
      <li>Syntax: <code class="language-plaintext highlighter-rouge">INT number</code></li>
      <li>Function: Triggers a software interrupt, calling an interrupt service routine (ISR).</li>
      <li>Example: <code class="language-plaintext highlighter-rouge">INT 21h</code> (DOS system call).</li>
    </ul>
  </li>
  <li><strong>IRET (Interrupt Return)</strong>:
    <ul>
      <li>Function: Returns from an ISR, restoring flags and return address.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="2-assembly-language-programming">2. Assembly Language Programming</h3>

<p>Assembly language programs are written as human-readable instructions that are assembled into machine code. The 8086 uses a <strong>segmented memory model</strong>, with code, data, and stack segments defined explicitly.</p>

<h4 id="a-program-structure">a. Program Structure</h4>
<p>A typical 8086 assembly program includes:</p>
<ul>
  <li><strong>Directives</strong>: Instructions for the assembler (e.g., NASM, MASM).
    <ul>
      <li><code class="language-plaintext highlighter-rouge">SEGMENT</code>: Defines code, data, or stack segments.</li>
      <li><code class="language-plaintext highlighter-rouge">ORG</code>: Sets origin address.</li>
      <li><code class="language-plaintext highlighter-rouge">DB/DW</code>: Defines byte/word data.</li>
    </ul>
  </li>
  <li><strong>Instructions</strong>: CPU operations (e.g., MOV, ADD).</li>
  <li><strong>Labels</strong>: Mark locations for jumps or data.</li>
  <li><strong>Comments</strong>: Explain code (e.g., <code class="language-plaintext highlighter-rouge">; comment</code>).</li>
</ul>

<p><strong>Example Program Structure (MASM syntax)</strong>:</p>
<pre><code class="language-asm">.model small
.stack 100h
.data
    message db 'Hello, World!$'
.code
main proc
    mov ax, @data    ; Initialize DS
    mov ds, ax
    mov dx, offset message ; Load message address
    mov ah, 09h      ; DOS print string function
    int 21h          ; Call DOS interrupt
    mov ah, 4Ch      ; Exit program
    int 21h
main endp
end main
</code></pre>

<h4 id="b-sequential-structures">b. Sequential Structures</h4>
<p>Sequential code executes instructions in order, without jumps or loops.</p>

<p><strong>Example: Adding Two Numbers</strong></p>
<pre><code class="language-asm">mov ax, 5        ; AX = 5
mov bx, 10       ; BX = 10
add ax, bx       ; AX = AX + BX (15)
mov [result], ax ; Store result in memory
</code></pre>
<ul>
  <li>Instructions execute one after another.</li>
  <li>Common for simple calculations or data initialization.</li>
</ul>

<h4 id="c-branch-structures">c. Branch Structures</h4>
<p>Branching uses conditional/unconditional jumps to alter program flow based on conditions.</p>

<p><strong>Example: Compare and Branch</strong></p>
<pre><code class="language-asm">mov ax, 10       ; AX = 10
cmp ax, 15       ; Compare AX with 15
je equal         ; Jump if AX == 15
mov bx, 1        ; Else, BX = 1
jmp done
equal:
    mov bx, 0    ; BX = 0 if equal
done:
    ; Continue program
</code></pre>
<ul>
  <li><strong>CMP</strong>: Sets flags based on subtraction (AX - 15).</li>
  <li><strong>JE</strong>: Jumps if ZF = 1 (equal).</li>
  <li>Useful for if-then-else logic.</li>
</ul>

<h4 id="d-loop-structures">d. Loop Structures</h4>
<p>Loops repeat instructions until a condition is met, often using <code class="language-plaintext highlighter-rouge">LOOP</code> or conditional jumps.</p>

<p><strong>Example: Sum Numbers 1 to 10</strong></p>
<pre><code class="language-asm">mov cx, 10       ; Loop counter = 10
mov ax, 0        ; Sum = 0
sum_loop:
    add ax, cx   ; Add CX to sum
    loop sum_loop ; Decrement CX, loop if CX ≠ 0
    ; AX = 55 (1 + 2 + ... + 10)
</code></pre>
<ul>
  <li><code class="language-plaintext highlighter-rouge">LOOP</code> simplifies counter-based iteration.</li>
  <li>Alternative: Use <code class="language-plaintext highlighter-rouge">CMP</code> and <code class="language-plaintext highlighter-rouge">JNZ</code> for custom conditions.</li>
</ul>

<p><strong>Example with Conditional Loop</strong></p>
<pre><code class="language-asm">mov ax, 0        ; Counter
mov bx, 100      ; Limit
count_up:
    inc ax       ; AX++
    cmp ax, bx   ; Compare with 100
    jle count_up ; Jump if AX &lt;= 100
</code></pre>
<ul>
  <li>Flexible for non-counter-based loops.</li>
</ul>

<h4 id="e-subroutines">e. Subroutines</h4>
<p>Subroutines modularize code, allowing reuse via <code class="language-plaintext highlighter-rouge">CALL</code> and <code class="language-plaintext highlighter-rouge">RET</code>.</p>

<p><strong>Example: Square a Number</strong></p>
<pre><code class="language-asm">main:
    mov ax, 4    ; Input
    call square  ; Call subroutine
    ; AX = 16
    jmp exit
square:
    push bx      ; Save BX
    mov bx, ax   ; Copy AX
    mul bx       ; AX = AX * BX
    pop bx       ; Restore BX
    ret          ; Return
exit:
    ; End program
</code></pre>
<ul>
  <li><strong>PUSH/POP</strong>: Save/restore registers to avoid side effects.</li>
  <li>Stack manages return addresses automatically.</li>
</ul>

<hr />

<h3 id="3-interrupt-service-routines-isrs">3. Interrupt Service Routines (ISRs)</h3>

<p>Interrupts allow the CPU to respond to external or internal events (e.g., keyboard input, timer ticks) by pausing the current program and executing an ISR.</p>

<h4 id="interrupt-mechanism">Interrupt Mechanism</h4>
<ul>
  <li><strong>Interrupt Vector Table (IVT)</strong>:
    <ul>
      <li>Located at memory 0000:0000h–0000:03FFh.</li>
      <li>Stores addresses of ISRs for 256 interrupt types (0–255).</li>
      <li>Each entry: Segment:Offset (4 bytes).</li>
    </ul>
  </li>
  <li><strong>Types</strong>:
    <ul>
      <li><strong>Hardware Interrupts</strong>: Triggered by devices (e.g., IRQ).</li>
      <li><strong>Software Interrupts</strong>: Triggered by <code class="language-plaintext highlighter-rouge">INT</code> instruction (e.g., INT 21h for DOS).</li>
      <li><strong>Exceptions</strong>: CPU errors (e.g., divide by zero).</li>
    </ul>
  </li>
  <li><strong>Process</strong>:
    <ol>
      <li>Interrupt occurs.</li>
      <li>CPU saves flags, CS, and IP on stack.</li>
      <li>Jumps to ISR via IVT.</li>
      <li>ISR executes, ends with <code class="language-plaintext highlighter-rouge">IRET</code> to restore state.</li>
    </ol>
  </li>
</ul>

<h4 id="writing-an-isr">Writing an ISR</h4>
<p>ISRs must:</p>
<ul>
  <li>Preserve registers (PUSH/POP).</li>
  <li>Handle the interrupt quickly.</li>
  <li>End with <code class="language-plaintext highlighter-rouge">IRET</code>.</li>
</ul>

<p><strong>Example: Custom Timer ISR</strong></p>
<pre><code class="language-asm">.data
old_vec dw 2 dup(0) ; Store old interrupt vector
.code
install_isr:
    cli             ; Disable interrupts
    mov ax, 0
    mov es, ax      ; ES = 0 (IVT segment)
    mov bx, 1Ch*4   ; Timer interrupt (1Ch)
    mov ax, es:[bx] ; Save old vector
    mov old_vec, ax
    mov ax, es:[bx+2]
    mov old_vec+2, ax
    mov ax, offset my_isr ; Set new vector
    mov es:[bx], ax
    mov ax, cs
    mov es:[bx+2], ax
    sti             ; Enable interrupts
    ret
my_isr:
    push ax
    inc word ptr [counter] ; Increment counter
    pop ax
    iret            ; Return from interrupt
</code></pre>
<ul>
  <li>Hooks timer interrupt (1Ch, ~18.2 Hz).</li>
  <li>Increments a counter variable.</li>
  <li>Preserves registers and uses <code class="language-plaintext highlighter-rouge">IRET</code>.</li>
</ul>

<p><strong>Example: DOS Interrupt (INT 21h)</strong></p>
<pre><code class="language-asm">mov ah, 09h      ; Print string function
mov dx, offset msg ; Address of '$'-terminated string
int 21h          ; Call DOS
</code></pre>
<ul>
  <li>INT 21h provides OS services (e.g., I/O, file handling).</li>
  <li>AH specifies the function code.</li>
</ul>

<h4 id="practical-notes">Practical Notes</h4>
<ul>
  <li><strong>Saving State</strong>: ISRs must preserve all registers to avoid corrupting the main program.</li>
  <li><strong>Priority</strong>: Hardware interrupts may preempt others (managed by PIC).</li>
  <li><strong>Debugging</strong>: Use tools like DEBUG.COM or modern emulators (e.g., DOSBox, Bochs).</li>
</ul>

<hr />

<h3 id="example-program-factorial-calculation">Example Program: Factorial Calculation</h3>
<p>This program calculates the factorial of a number (e.g., 5! = 120) using a loop and subroutine.</p>

<pre><code class="language-asm">.model small
.stack 100h
.data
    num dw 5        ; Input number
    result dw ?     ; Store result
.code
main proc
    mov ax, @data
    mov ds, ax      ; Initialize DS
    mov ax, num     ; Load number
    call factorial  ; Compute factorial
    mov result, ax  ; Store result
    mov ah, 4Ch     ; Exit
    int 21h
main endp
factorial proc
    push bx
    mov bx, ax      ; BX = n
    mov ax, 1       ; AX = result
fact_loop:
    cmp bx, 1
    jle done        ; If BX &lt;= 1, exit
    mul bx          ; AX = AX * BX
    dec bx          ; BX--
    jmp fact_loop
done:
    pop bx
    ret
factorial endp
end main
</code></pre>
<ul>
  <li><strong>Logic</strong>:
    <ul>
      <li>Input: num = 5.</li>
      <li>Loop: AX = AX * BX, BX– until BX = 1.</li>
      <li>Result: AX = 5 * 4 * 3 * 2 * 1 = 120.</li>
    </ul>
  </li>
  <li><strong>Features</strong>:
    <ul>
      <li>Subroutine for modularity.</li>
      <li>Stack for register preservation.</li>
      <li>Sequential and loop structures.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="best-practices">Best Practices</h3>
<ol>
  <li><strong>Comment Code</strong>: Assembly is cryptic; explain every step.</li>
  <li><strong>Minimize Register Use</strong>: Avoid unnecessary overwrites.</li>
  <li><strong>Test Incrementally</strong>: Use debuggers to trace execution.</li>
  <li><strong>Handle Edge Cases</strong>: Check for overflow, zero, or negative inputs.</li>
  <li><strong>Optimize</strong>: Reduce instructions (e.g., use XOR AX, AX instead of MOV AX, 0).</li>
</ol>

<hr />

<h3 id="summary">Summary</h3>
<ul>
  <li><strong>8086 Instruction Set</strong>:
    <ul>
      <li><strong>Data Transfer</strong>: MOV, PUSH, POP for moving data.</li>
      <li><strong>Arithmetic</strong>: ADD, SUB, MUL for calculations.</li>
      <li><strong>Logic</strong>: AND, OR, XOR for bit manipulation.</li>
      <li><strong>Control Flow</strong>: JMP, LOOP, CALL for program flow.</li>
    </ul>
  </li>
  <li><strong>Programming Structures</strong>:
    <ul>
      <li><strong>Sequential</strong>: Linear execution for simple tasks.</li>
      <li><strong>Branch</strong>: Conditional jumps for decisions.</li>
      <li><strong>Loop</strong>: LOOP or Jcc for repetition.</li>
      <li><strong>Subroutines</strong>: CALL/RET for modular code.</li>
    </ul>
  </li>
  <li><strong>Interrupts</strong>:
    <ul>
      <li>ISRs handle events via IVT.</li>
      <li>Preserve state, end with IRET.</li>
      <li>Used for hardware (e.g., timer) and software (e.g., DOS) interrupts.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="practice-questions">Practice Questions</h3>
<ol>
  <li>Write a program to reverse a string in memory.</li>
  <li>Implement a subroutine to check if a number is prime.</li>
  <li>Create an ISR for the keyboard interrupt (INT 09h) to count keypresses.</li>
  <li>Explain the difference between <code class="language-plaintext highlighter-rouge">JMP</code> and <code class="language-plaintext highlighter-rouge">CALL</code>.</li>
  <li>Optimize this code: <code class="language-plaintext highlighter-rouge">MOV AX, 0; MOV BX, AX; ADD BX, 5</code>.</li>
</ol>

<hr />

<p>This tutorial covers the essentials of 8086 assembly programming, with examples and explanations to build practical skills. If you’d like to explore specific instructions, advanced techniques (e.g., string operations), or emulation tools, let me know!</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
