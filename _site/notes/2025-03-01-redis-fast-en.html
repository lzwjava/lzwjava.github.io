<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Why is Redis Fast</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Why is Redis Fast | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Why is Redis Fast" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-03-01-redis-fast-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-03-01-redis-fast-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Why is Redis Fast" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Why is Redis Fast","url":"https://lzwjava.github.io/notes/2025-03-01-redis-fast-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=5dc6bde1e9a37ea9c508461e5a5cdae981a42eb8">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=5dc6bde1e9a37ea9c508461e5a5cdae981a42eb8" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Why is Redis Fast | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-03-01-redis-fast-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-03-01-redis-fast-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.09</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/redis-fast-en" selected>English</option>
        <option value="/redis-fast-zh" >中文</option>
        <option value="/redis-fast-ja" >日本語</option>
        <option value="/redis-fast-es" >Español</option>
        <option value="/redis-fast-hi" >हिंदी</option>
        <option value="/redis-fast-fr" >Français</option>
        <option value="/redis-fast-de" >Deutsch</option>
        <option value="/redis-fast-ar" >العربية</option>
        <option value="/redis-fast-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <h3 id="key-points">Key Points</h3>
<ul>
  <li>It seems likely that the YouTube video “System Design: Why is single-threaded Redis so fast?” by ByteByteGo explains Redis’s speed due to in-memory storage, IO multiplexing, and efficient data structures.</li>
  <li>Research suggests these factors allow Redis to handle up to 100,000 queries per second, despite being single-threaded for request processing.</li>
  <li>The evidence leans toward recent Redis versions adding multi-threading for specific tasks, but the core remains single-threaded.</li>
</ul>

<hr />

<h3 id="introduction">Introduction</h3>
<p>This blog post is based on the YouTube video “System Design: Why is single-threaded Redis so fast?” by ByteByteGo, part of their system design series. Redis, known for its high performance, can handle up to 100,000 queries per second on a single machine, which is impressive for a single-threaded system. Let’s explore why this is possible and what makes Redis so fast.</p>

<h3 id="reasons-for-rediss-speed">Reasons for Redis’s Speed</h3>
<p>Redis’s speed can be attributed to several key factors, likely covered in the video:</p>

<ul>
  <li>
    <p><strong>In-Memory Storage</strong>: Redis stores data in RAM, which is much faster than disk storage. This reduces latency and increases throughput, as memory access times are in nanoseconds compared to milliseconds for disk access.</p>
  </li>
  <li>
    <p><strong>IO Multiplexing and Single-Threaded Execution</strong>: IO multiplexing, using mechanisms like epoll on Linux, allows a single thread to handle multiple client connections efficiently. This avoids the overhead of context switching, and the single-threaded loop simplifies operations by eliminating synchronization issues.</p>
  </li>
  <li>
    <p><strong>Efficient Data Structures</strong>: Redis uses optimized data structures like hash tables (O(1) lookups), linked lists, and skip lists, which enhance performance by minimizing memory usage and speeding up operations.</p>
  </li>
</ul>

<h3 id="scaling-and-evolution">Scaling and Evolution</h3>
<p>For high concurrency, Redis can be scaled horizontally using multiple instances or clustering. An unexpected detail is that while the core request processing remains single-threaded, recent versions (since 4.0) have introduced multi-threading for tasks like background object deletion, improving performance further without changing the primary model.</p>

<hr />

<h3 id="survey-note-detailed-analysis-of-rediss-single-threaded-performance">Survey Note: Detailed Analysis of Redis’s Single-Threaded Performance</h3>

<p>This section provides a comprehensive analysis of why single-threaded Redis is so fast, based on the YouTube video “System Design: Why is single-threaded Redis so fast?” by ByteByteGo and related research. The video, published on August 13, 2022, is part of a series focused on system design, authored by the creators of bestselling System Design Interview books. Given the channel’s focus, the video likely provides detailed insights suitable for technical interviews and system design discussions.</p>

<h4 id="background-and-context">Background and Context</h4>
<p>Redis, an open-source in-memory key-value store, is widely used as a cache, message broker, and streaming engine. It supports data structures like strings, lists, sets, hashes, sorted sets, and probabilistic structures like Bloom Filter and HyperLogLog. The video’s title suggests an exploration of why Redis maintains high performance despite its single-threaded request processing, which is central to its design.</p>

<p>From related articles, Redis can handle up to 100,000 Queries Per Second (QPS) on a single machine, a figure often cited in performance benchmarks. This speed is surprising given the single-threaded model, but research indicates it’s due to several architectural choices.</p>

<h4 id="key-factors-contributing-to-rediss-speed">Key Factors Contributing to Redis’s Speed</h4>

<ol>
  <li>
    <p><strong>In-Memory Storage</strong><br />
Redis stores data in RAM, which is at least 1000 times faster than random disk access. This eliminates the latency of disk I/O, with RAM access times around 100-120 nanoseconds compared to 50-150 microseconds for SSDs and 1-10 milliseconds for HDDs. The video likely emphasizes this as a primary reason, as it aligns with the channel’s focus on system design fundamentals.</p>

    <table>
      <thead>
        <tr>
          <th>Aspect</th>
          <th>Details</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Storage Medium</td>
          <td>RAM (in-memory)</td>
        </tr>
        <tr>
          <td>Access Time</td>
          <td>~100-120 nanoseconds</td>
        </tr>
        <tr>
          <td>Comparison to Disk</td>
          <td>1000x faster than random disk access</td>
        </tr>
        <tr>
          <td>Impact on Performance</td>
          <td>Reduces latency, increases throughput</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p><strong>IO Multiplexing and Single-Threaded Execution Loop</strong><br />
IO multiplexing allows a single thread to monitor multiple I/O streams concurrently using system calls like <code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">poll</code>, <code class="language-plaintext highlighter-rouge">epoll</code> (Linux), <code class="language-plaintext highlighter-rouge">kqueue</code> (Mac OS), or <code class="language-plaintext highlighter-rouge">evport</code> (Solaris). This is crucial for handling multiple client connections without blocking, a point likely detailed in the video. The single-threaded execution loop avoids context switching and synchronization overhead, simplifying development and debugging.</p>

    <table>
      <thead>
        <tr>
          <th>Mechanism</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>epoll/kqueue</td>
          <td>Efficient for high concurrency, non-blocking</td>
        </tr>
        <tr>
          <td>select/poll</td>
          <td>Older, less scalable, O(n) complexity</td>
        </tr>
        <tr>
          <td>Impact</td>
          <td>Reduces connection overhead, enables pipelining</td>
        </tr>
      </tbody>
    </table>

    <p>However, client-blocking commands like <code class="language-plaintext highlighter-rouge">BLPOP</code> or <code class="language-plaintext highlighter-rouge">BRPOP</code> can delay traffic, a potential drawback mentioned in related articles. The video may discuss how this design choice balances simplicity with performance.</p>
  </li>
  <li>
    <p><strong>Efficient Lower-Level Data Structures</strong><br />
Redis leverages data structures like hash tables for O(1) key lookups, linked lists for lists, and skip lists for sorted sets. These are optimized for in-memory operations, minimizing memory usage and maximizing speed. The video likely includes diagrams or examples, such as how hash tables enable fast key-value operations, a common topic in system design interviews.</p>

    <table>
      <thead>
        <tr>
          <th>Data Structure</th>
          <th>Use Case</th>
          <th>Time Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Hash Table</td>
          <td>Key-value storage</td>
          <td>O(1) average</td>
        </tr>
        <tr>
          <td>Linked List</td>
          <td>Lists, efficient at ends</td>
          <td>O(1) for ends</td>
        </tr>
        <tr>
          <td>Skip List</td>
          <td>Sorted sets, ordered storage</td>
          <td>O(log n)</td>
        </tr>
      </tbody>
    </table>

    <p>This optimization is critical, as most Redis operations are memory-based, with bottlenecks typically in memory or network, not CPU.</p>
  </li>
</ol>

<h4 id="additional-considerations-and-evolution">Additional Considerations and Evolution</h4>
<p>While the core request processing is single-threaded, recent versions of Redis have introduced multi-threading for specific tasks. Since Redis 4.0, asynchronous memory release (lazy-free) has been implemented, and since 6.0, multi-threading for protocol parsing under high concurrency has been added. These changes, likely mentioned in the video, enhance performance without altering the single-threaded model for main operations.</p>

<p>For scaling beyond a single instance, Redis supports clustering and running multiple instances, a strategy that may be discussed to address high concurrency needs. This is an important aspect for system design, aligning with the channel’s focus on large-scale systems.</p>

<h4 id="potential-drawbacks-and-comparisons">Potential Drawbacks and Comparisons</h4>
<p>The single-threaded model has advantages like no lock contention and simpler debugging, but it can face challenges with blocking operations and memory/network bottlenecks under high load. Related articles suggest that for CPU-intensive tasks, multi-threaded databases might perform better, but for Redis’s typical use cases, the single-threaded design is optimal.</p>

<h4 id="conclusion">Conclusion</h4>
<p>The video “System Design: Why is single-threaded Redis so fast?” by ByteByteGo likely covers in-memory storage, IO multiplexing, and efficient data structures as key reasons for Redis’s speed. These factors enable it to handle high QPS, with recent versions adding multi-threading for specific optimizations. This analysis provides a comprehensive understanding, suitable for both technical learners and system design professionals.</p>

<hr />

<h3 id="key-citations">Key Citations</h3>
<ul>
  <li><a href="https://blog.bytebytego.com/p/why-is-redis-so-fast">Why is redis so fast blog post</a></li>
  <li><a href="https://medium.com/@aditimishra_541/why-is-redis-so-fast-despite-being-single-threaded-dc06ba33fc75">Why is Redis So Fast Despite Being Single-Threaded article</a></li>
  <li><a href="https://medium.com/javarevisited/interview-why-is-redis-so-fast-even-though-it-is-single-threaded-bfe663dabe08">Interview on Redis thread model article</a></li>
  <li><a href="https://www.pixelstech.net/article/1677580861-Why-is-single-threaded-Redis-so-fast">Why is single threaded Redis so fast article</a></li>
</ul>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
