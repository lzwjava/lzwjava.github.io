<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Rust's `mut` and `&mut` Explained</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Rust’s mut and &amp;mut Explained | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Rust’s mut and &amp;mut Explained" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-07-31-rust-mut-vs-&mut-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-07-31-rust-mut-vs-&mut-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Rust’s mut and &amp;mut Explained" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Rust’s mut and &amp;mut Explained","url":"https://lzwjava.github.io/notes/2025-07-31-rust-mut-vs-&mut-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=09f62c344bd589880bf0827a79e9d278536aef67">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=09f62c344bd589880bf0827a79e9d278536aef67" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Rust's `mut` and `&mut` Explained | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-07-31-rust-mut-vs-&mut-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-07-31-rust-mut-vs-&mut-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.09</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/rust-mut-vs-&mut-en" selected>English</option>
        <option value="/rust-mut-vs-&mut-zh" >中文</option>
        <option value="/rust-mut-vs-&mut-ja" >日本語</option>
        <option value="/rust-mut-vs-&mut-es" >Español</option>
        <option value="/rust-mut-vs-&mut-hi" >हिंदी</option>
        <option value="/rust-mut-vs-&mut-fr" >Français</option>
        <option value="/rust-mut-vs-&mut-de" >Deutsch</option>
        <option value="/rust-mut-vs-&mut-ar" >العربية</option>
        <option value="/rust-mut-vs-&mut-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>In Rust, the keywords <code class="language-plaintext highlighter-rouge">mut</code> and <code class="language-plaintext highlighter-rouge">&amp;mut</code> serve related but distinct purposes, and they’re not directly equivalent to Java’s deep/shallow copy concepts or C’s pointers—though there are some analogies we can draw for clarity. I’ll break this down step by step, explain the differences, and address your questions about value passing vs. reference passing, mutability, and how changes affect the original data. I’ll use examples based on your provided code to illustrate.</p>

<h3 id="1-understanding-mut-in-variable-declarations">1. <strong>Understanding <code class="language-plaintext highlighter-rouge">mut</code> in Variable Declarations</strong></h3>
<ul>
  <li>When you declare a variable with <code class="language-plaintext highlighter-rouge">let mut</code>, you’re making the <em>binding</em> (the variable name) mutable. This means you can reassign the variable or modify its contents directly, but only within the scope where it’s declared.</li>
  <li>Example from your code:
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
</code></pre></div>    </div>
    <p>Here, <code class="language-plaintext highlighter-rouge">arr</code> is mutable, so you could do <code class="language-plaintext highlighter-rouge">arr[0] = 99;</code> or even reassign <code class="language-plaintext highlighter-rouge">arr = [1, 2, 3];</code> later if you wanted. Without <code class="language-plaintext highlighter-rouge">mut</code>, Rust would complain about trying to modify an immutable variable (Rust defaults to immutability for safety).</p>
  </li>
  <li>This <code class="language-plaintext highlighter-rouge">mut</code> is about the variable itself, not about how it’s passed to functions. It doesn’t imply copying or referencing—it’s just permission to change the variable in place.</li>
</ul>

<h3 id="2-understanding-mut-in-function-parameters-and-references">2. <strong>Understanding <code class="language-plaintext highlighter-rouge">&amp;mut</code> in Function Parameters and References</strong></h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&amp;mut</code> creates a <em>mutable reference</em> (also called a mutable borrow). This is like a pointer in C that allows reading <em>and</em> writing to the pointed-to data, but with Rust’s strict borrow checker ensuring safety (no data races, no dangling pointers).</li>
  <li>In your code:
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>The parameter <code class="language-plaintext highlighter-rouge">arr</code> is a mutable reference to a slice of <code class="language-plaintext highlighter-rouge">i32</code>s (<code class="language-plaintext highlighter-rouge">&amp;mut [i32]</code>). Slices in Rust are views into arrays or vectors (like a pointer + length), and they’re almost always passed as references because slices are “unsized” types (their size isn’t known at compile time).</li>
      <li>When you call <code class="language-plaintext highlighter-rouge">quick_sort(&amp;mut arr);</code>, you’re passing a mutable reference to the original <code class="language-plaintext highlighter-rouge">arr</code>. This allows the function to modify the elements of the original array through the reference (e.g., via swaps in <code class="language-plaintext highlighter-rouge">partition</code>).</li>
      <li>Inside the function, operations like <code class="language-plaintext highlighter-rouge">arr.swap(i, j);</code> directly affect the original data because <code class="language-plaintext highlighter-rouge">arr</code> is a reference pointing back to it.</li>
    </ul>
  </li>
  <li>Without the <code class="language-plaintext highlighter-rouge">&amp;</code>, you couldn’t pass a slice like <code class="language-plaintext highlighter-rouge">[i32]</code> directly as a parameter in this way—Rust requires references for unsized types. But more generally, <code class="language-plaintext highlighter-rouge">&amp;mut</code> enables reference passing with mutation rights.</li>
</ul>

<h3 id="3-value-passing-vs-reference-passing-in-rust">3. <strong>Value Passing vs. Reference Passing in Rust</strong></h3>
<ul>
  <li>Rust uses <em>ownership</em> as its core model, which is different from Java (which is mostly reference-based with garbage collection) or C (manual pointers).
    <ul>
      <li><strong>Value passing (ownership transfer)</strong>: When you pass a value without <code class="language-plaintext highlighter-rouge">&amp;</code> (e.g., <code class="language-plaintext highlighter-rouge">fn foo(x: i32)</code> or <code class="language-plaintext highlighter-rouge">fn bar(mut v: Vec&lt;i32&gt;)</code>), ownership of the data moves to the function. The function can modify it locally, but changes don’t affect the caller’s original (because the caller no longer owns it). If the type implements <code class="language-plaintext highlighter-rouge">Copy</code> (like primitives such as <code class="language-plaintext highlighter-rouge">i32</code>), it’s automatically copied instead of moved—no deep copy unless you explicitly clone.
        <ul>
          <li>Example:
            <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Modifies local x, but caller's original is unchanged (or moved/copied).</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Inside: {}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nf">foo</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>  <span class="c1">// Passes by value (copy, since i32 is Copy).</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"After: {}"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">// Still 5.</span>
</code></pre></div>            </div>
          </li>
          <li>This is like “value passing” in other languages: primitives are copied, larger types (like arrays/vectors) are moved (efficient, no copy unless cloned).</li>
        </ul>
      </li>
      <li><strong>Reference passing (borrowing)</strong>: Using <code class="language-plaintext highlighter-rouge">&amp;</code> (immutable reference) or <code class="language-plaintext highlighter-rouge">&amp;mut</code> (mutable reference) “borrows” the data without transferring ownership. The function gets a temporary view (like a pointer), and the original owner retains control.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">&amp;</code>: Read-only borrow. Can’t modify the original.</li>
          <li><code class="language-plaintext highlighter-rouge">&amp;mut</code>: Read-write borrow. <em>Can</em> modify the original, like passing by reference in C++ or a mutable pointer in C.</li>
          <li>Example:
            <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Dereference and modify the original.</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">// Pass mutable reference.</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"After: {}"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  <span class="c1">// Now 6, original changed.</span>
</code></pre></div>            </div>
          </li>
          <li>In your quicksort code, it’s reference passing with <code class="language-plaintext highlighter-rouge">&amp;mut</code>, so swaps change the original array. If it were just <code class="language-plaintext highlighter-rouge">&amp; [i32]</code>, you couldn’t modify it (immutable borrow).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>To your point: Yes, <code class="language-plaintext highlighter-rouge">&amp;mut</code> allows changing the original values (reference passing with mutation), while passing without <code class="language-plaintext highlighter-rouge">&amp;</code> (value passing) either copies/moves the data, so modifications are local and don’t affect the original. But:
    <ul>
      <li>Not all types copy automatically—only those implementing <code class="language-plaintext highlighter-rouge">Copy</code> (e.g., <code class="language-plaintext highlighter-rouge">i32</code>, not arrays or vectors). For non-<code class="language-plaintext highlighter-rouge">Copy</code> types like your array, passing by value would <em>move</em> ownership, and you’d need to return it to “give back” to the caller.</li>
      <li>Rust avoids unnecessary copies for efficiency. Your array isn’t copied when passed as <code class="language-plaintext highlighter-rouge">&amp;mut [i32]</code>—it’s just a reference (shallow, like a pointer).</li>
    </ul>
  </li>
</ul>

<h3 id="4-comparison-to-java-and-c">4. <strong>Comparison to Java and C</strong></h3>
<ul>
  <li><strong>Java</strong>: Everything non-primitive is passed by reference (shallow—objects are shared, but reassigning the parameter doesn’t affect the caller). Primitives are passed by value (copy). No direct equivalent to <code class="language-plaintext highlighter-rouge">mut</code> or <code class="language-plaintext highlighter-rouge">&amp;mut</code>; mutability is controlled by class design (e.g., final fields). Java doesn’t have Rust’s ownership, so it’s more prone to shared mutable state issues. Deep copy requires manual cloning.</li>
  <li><strong>C</strong>: <code class="language-plaintext highlighter-rouge">&amp;mut</code> is like passing a pointer (<code class="language-plaintext highlighter-rouge">int*</code>) where you can dereference and modify (<code class="language-plaintext highlighter-rouge">*ptr = 10;</code>). Plain <code class="language-plaintext highlighter-rouge">mut</code> (in declarations) is like non-const variables. But C has no borrow checker, so you manage lifetimes manually (error-prone). Passing by value in C copies the data (shallow for structs unless you deep-copy).</li>
  <li>Key difference: Rust enforces “one mutable reference at a time” (or multiple immutable ones), preventing bugs. No nulls, no wild pointers.</li>
</ul>

<h3 id="5-why-mut-sometimes-and-mut-sometimes-in-your-code">5. <strong>Why <code class="language-plaintext highlighter-rouge">mut</code> Sometimes and <code class="language-plaintext highlighter-rouge">&amp;mut</code> Sometimes in Your Code?</strong></h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">mut</code> alone: Used for local variables that need to be changeable, like <code class="language-plaintext highlighter-rouge">let mut arr</code> (so you can pass <code class="language-plaintext highlighter-rouge">&amp;mut arr</code> later or modify it directly).</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;mut</code>: Used in parameters when the function needs to borrow and modify the caller’s data without taking ownership. In <code class="language-plaintext highlighter-rouge">quick_sort</code> and <code class="language-plaintext highlighter-rouge">partition</code>, <code class="language-plaintext highlighter-rouge">&amp;mut [i32]</code> lets them sort the array in place without moving/copying it.</li>
  <li>If you tried <code class="language-plaintext highlighter-rouge">fn quick_sort(mut arr: [i32])</code>, it wouldn’t compile—slices can’t be passed by value like that. You’d need a fixed-size array (e.g., <code class="language-plaintext highlighter-rouge">[i32; 7]</code>) and it would move ownership.</li>
  <li>In <code class="language-plaintext highlighter-rouge">partition</code>, the loop uses <code class="language-plaintext highlighter-rouge">mut i</code> internally—that’s a local mutable variable, unrelated to passing.</li>
</ul>

<h3 id="6-does-it-change-original-values">6. <strong>Does It Change Original Values?</strong></h3>
<ul>
  <li>Yes for <code class="language-plaintext highlighter-rouge">&amp;mut</code>: Changes propagate to the original (reference passing).</li>
  <li>No for value passing (without <code class="language-plaintext highlighter-rouge">&amp;</code>): Local changes only (unless you return the modified value).</li>
  <li>In your <code class="language-plaintext highlighter-rouge">quick_sort_interact()</code>, the <code class="language-plaintext highlighter-rouge">println!("After: {:?}", arr);</code> will show the sorted array because <code class="language-plaintext highlighter-rouge">&amp;mut</code> was used.</li>
</ul>

<p>If you run your code, it should output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Before: [3, 6, 8, 10, 1, 2, 1]
After: [1, 1, 2, 3, 6, 8, 10]
</code></pre></div></div>
<p>(The <code class="language-plaintext highlighter-rouge">mod simple;</code> and <code class="language-plaintext highlighter-rouge">simple::run_simple();</code> seem unrelated—perhaps a placeholder? If there’s an error there, it might be because <code class="language-plaintext highlighter-rouge">simple</code> isn’t defined.)</p>

<p>If this doesn’t clarify or you have a specific part of the code to tweak/test, let me know!</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
