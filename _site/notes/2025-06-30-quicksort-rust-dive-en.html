<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Quicksort in Rust for Experienced Devs</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Quicksort in Rust for Experienced Devs | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Quicksort in Rust for Experienced Devs" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-06-30-quicksort-rust-dive-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-06-30-quicksort-rust-dive-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Quicksort in Rust for Experienced Devs" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Quicksort in Rust for Experienced Devs","url":"https://lzwjava.github.io/notes/2025-06-30-quicksort-rust-dive-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=d23072e581336d3f2487c2557ba2cc8d2011bc71">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=d23072e581336d3f2487c2557ba2cc8d2011bc71" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Quicksort in Rust for Experienced Devs | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-06-30-quicksort-rust-dive-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-06-30-quicksort-rust-dive-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.10</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/quicksort-rust-dive-en" selected>English</option>
        <option value="/quicksort-rust-dive-zh" >中文</option>
        <option value="/quicksort-rust-dive-ja" >日本語</option>
        <option value="/quicksort-rust-dive-es" >Español</option>
        <option value="/quicksort-rust-dive-hi" >हिंदी</option>
        <option value="/quicksort-rust-dive-fr" >Français</option>
        <option value="/quicksort-rust-dive-de" >Deutsch</option>
        <option value="/quicksort-rust-dive-ar" >العربية</option>
        <option value="/quicksort-rust-dive-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Alright, given your strong background in algorithms, full-stack development, and even mobile engineering, you’ll find Rust’s approach to memory safety and explicit control quite familiar in concept, even if the syntax and strictness are new. Let’s break down this Quicksort implementation in Rust.</p>

<hr />

<h3 id="quicksort-in-rust-a-dive-for-experienced-devs">Quicksort in Rust: A Dive for Experienced Devs</h3>

<p>This Rust code implements the classic <strong>Quicksort algorithm</strong>. The core idea of Quicksort is to pick an element as a pivot and partition the array around it, such that elements smaller than the pivot are on one side, and elements greater are on the other. This process is then recursively applied to the sub-arrays.</p>

<p>Let’s go through the functions:</p>

<hr />

<h3 id="fn-quick_sortarr-mut-i32"><code class="language-plaintext highlighter-rouge">fn quick_sort(arr: &amp;mut [i32])</code></h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">arr</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">pivot_index</span> <span class="o">=</span> <span class="nf">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.split_at_mut</span><span class="p">(</span><span class="n">pivot_index</span><span class="p">);</span>
    <span class="nf">quick_sort</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
    <span class="nf">quick_sort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">right</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">arr: &amp;mut [i32]</code></strong>: This is where Rust’s type system immediately shows its colors.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&amp;mut</code> signifies a <strong>mutable reference</strong>. This means the <code class="language-plaintext highlighter-rouge">quick_sort</code> function gets a borrowed reference to the array <code class="language-plaintext highlighter-rouge">arr</code>, and it’s allowed to modify the contents of that array <em>in place</em>.</li>
      <li><code class="language-plaintext highlighter-rouge">[i32]</code> is a <strong>slice</strong> of <code class="language-plaintext highlighter-rouge">i32</code> integers. In Rust, <code class="language-plaintext highlighter-rouge">[T]</code> is the type for a slice, which is a view into a contiguous sequence of elements. It doesn’t own the data; it just points to a portion of an array or <code class="language-plaintext highlighter-rouge">Vec</code>. This is crucial for efficiency, as it avoids copying data around. You’re familiar with pointers and array sections from your C/C++/Java background; think of this as Rust’s safe and explicit way to manage that.</li>
    </ul>
  </li>
  <li><strong>Base Case <code class="language-plaintext highlighter-rouge">if arr.len() &lt;= 1</code></strong>: Standard recursive base case for Quicksort. If the slice has 0 or 1 element, it’s already sorted, so just return.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">let pivot_index = partition(arr);</code></strong>: This calls the <code class="language-plaintext highlighter-rouge">partition</code> function (which we’ll look at next) to rearrange the slice. It returns the final position of the pivot element.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">let (left, right) = arr.split_at_mut(pivot_index);</code></strong>: This is a key Rust feature for safe mutable aliasing.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">split_at_mut</code> is a method on mutable slices. It takes an index and splits the mutable slice into two <em>disjoint</em> mutable slices.</li>
      <li><code class="language-plaintext highlighter-rouge">left</code> will be <code class="language-plaintext highlighter-rouge">arr[0..pivot_index]</code> and <code class="language-plaintext highlighter-rouge">right</code> will be <code class="language-plaintext highlighter-rouge">arr[pivot_index..len]</code>.</li>
      <li>This is fundamental to Rust’s <strong>borrow checker</strong>. You cannot have two mutable references to the <em>same data</em> at the same time. <code class="language-plaintext highlighter-rouge">split_at_mut</code> ensures that <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code> refer to completely separate parts of the original array, satisfying the borrow checker and preventing data races in a multi-threaded context (even though this is single-threaded, the principle applies).</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">quick_sort(left);</code></strong>: Recursively sort the <code class="language-plaintext highlighter-rouge">left</code> sub-slice.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">quick_sort(&amp;mut right[1..]);</code></strong>: Recursively sort the <code class="language-plaintext highlighter-rouge">right</code> sub-slice.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">right[1..]</code> is important: The <code class="language-plaintext highlighter-rouge">right</code> slice starts at <code class="language-plaintext highlighter-rouge">pivot_index</code>. Since <code class="language-plaintext highlighter-rouge">arr[pivot_index]</code> is now the correctly positioned pivot element, we exclude it from the recursive call on the right side.</li>
      <li><code class="language-plaintext highlighter-rouge">&amp;mut</code> explicitly re-borrows a mutable slice from <code class="language-plaintext highlighter-rouge">right</code>.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="fn-partitionarr-mut-i32---usize"><code class="language-plaintext highlighter-rouge">fn partition(arr: &amp;mut [i32]) -&gt; usize</code></h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">i32</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span> <span class="p">{</span>
            <span class="n">arr</span><span class="nf">.swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">arr</span><span class="nf">.swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">i</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This function implements the Lomuto partition scheme, which is a common way to partition an array for Quicksort.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">let len = arr.len();</code></strong>: Gets the length of the current slice.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">let pivot = arr[len - 1];</code></strong>: The <strong>last element</strong> of the slice is chosen as the pivot.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">let mut i = 0;</code></strong>: <code class="language-plaintext highlighter-rouge">i</code> acts as a pointer to the “boundary” between elements smaller than or equal to the pivot and elements greater than the pivot. Elements to the left of <code class="language-plaintext highlighter-rouge">i</code> will be less than or equal to the pivot.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">for j in 0..len - 1</code></strong>: This loop iterates through all elements <em>except</em> the pivot (which is at <code class="language-plaintext highlighter-rouge">len - 1</code>).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">if arr[j] &lt;= pivot { ... }</code></strong>: If the current element <code class="language-plaintext highlighter-rouge">arr[j]</code> is less than or equal to the pivot:
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">arr.swap(i, j);</code></strong>: Swap <code class="language-plaintext highlighter-rouge">arr[j]</code> with <code class="language-plaintext highlighter-rouge">arr[i]</code>. This moves the smaller element into the “less than or equal” section.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">i += 1;</code></strong>: Increment <code class="language-plaintext highlighter-rouge">i</code> to extend the “less than or equal” section.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">arr.swap(i, len - 1);</code></strong>: After the loop, <code class="language-plaintext highlighter-rouge">i</code> is the correct position for the pivot. We swap the pivot (which is still at <code class="language-plaintext highlighter-rouge">len - 1</code>) into its final sorted position. Now, all elements to the left of <code class="language-plaintext highlighter-rouge">i</code> are less than or equal to <code class="language-plaintext highlighter-rouge">arr[i]</code> (the pivot), and all elements to the right are greater.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">i</code></strong>: The function returns <code class="language-plaintext highlighter-rouge">i</code>, which is the final index of the pivot element.</li>
</ul>

<hr />

<h3 id="fn-main"><code class="language-plaintext highlighter-rouge">fn main()</code></h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Before: {:?}"</span><span class="p">,</span> <span class="n">arr</span><span class="p">);</span>
    <span class="nf">quick_sort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">arr</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"After: {:?}"</span><span class="p">,</span> <span class="n">arr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">let mut arr = [3, 6, 8, 10, 1, 2, 1];</code></strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">let mut</code> declares a <strong>mutable variable</strong>. This allows you to reassign the variable or modify its contents (if it’s a mutable type).</li>
      <li><code class="language-plaintext highlighter-rouge">[3, ...]</code> creates a <strong>fixed-size array</strong> on the stack. Its size is known at compile time.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">println!("Before: {:?}", arr);</code></strong>: Uses the <code class="language-plaintext highlighter-rouge">println!</code> macro for output.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">{:?}</code> is the <strong>debug print</strong> format specifier. It uses the <code class="language-plaintext highlighter-rouge">Debug</code> trait to print a human-readable representation of the array.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">quick_sort(&amp;mut arr);</code></strong>: Calls the <code class="language-plaintext highlighter-rouge">quick_sort</code> function, passing a mutable reference to the <code class="language-plaintext highlighter-rouge">arr</code> array.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">println!("After: {:?}", arr);</code></strong>: Prints the array again after sorting.</li>
</ul>

<hr />

<h3 id="rust-specific-takeaways-for-you">Rust-Specific Takeaways for You</h3>

<ul>
  <li><strong>Ownership and Borrowing</strong>: This code is a prime example of Rust’s core concepts. You’re passing around <strong>references (<code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">&amp;mut</code>)</strong> rather than copying data. The <code class="language-plaintext highlighter-rouge">&amp;mut</code> references are critical for modifying the array in place, and the <strong>borrow checker</strong> (e.g., enforced by <code class="language-plaintext highlighter-rouge">split_at_mut</code>) ensures you never have multiple mutable references to the same data, eliminating a whole class of concurrency bugs at compile time. This is likely the biggest paradigm shift from languages like Java or Python, but it offers memory safety without a garbage collector.</li>
  <li><strong>Slices <code class="language-plaintext highlighter-rouge">[T]</code></strong>: These are incredibly powerful for working with contiguous data. They provide a safe, efficient view into parts of arrays or vectors without allocating new memory.</li>
  <li><strong>Macros (<code class="language-plaintext highlighter-rouge">println!</code>)</strong>: You’ll see <code class="language-plaintext highlighter-rouge">!</code> after many standard library functions (like <code class="language-plaintext highlighter-rouge">println!</code>, <code class="language-plaintext highlighter-rouge">vec!</code>, <code class="language-plaintext highlighter-rouge">format!</code>). These indicate that they are <strong>macros</strong>, not regular functions. Macros expand code at compile time, offering more flexibility and power (like variadic arguments or compile-time code generation) compared to regular functions.</li>
</ul>

<p>Given your background, you’ll likely appreciate the performance characteristics and safety guarantees that Rust offers, even if the “borrow checker dance” takes a bit of getting used to. It’s a different way of thinking about memory management, but one that leads to highly robust and efficient code.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
