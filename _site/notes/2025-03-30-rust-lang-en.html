<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Rust Programming Language</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Rust Programming Language | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Rust Programming Language" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-03-30-rust-lang-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-03-30-rust-lang-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Rust Programming Language" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Rust Programming Language","url":"https://lzwjava.github.io/notes/2025-03-30-rust-lang-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=9c75b91014892faaf916199462912a1432531359">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=9c75b91014892faaf916199462912a1432531359" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Rust Programming Language | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-03-30-rust-lang-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-03-30-rust-lang-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.10</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/rust-lang-en" selected>English</option>
        <option value="/rust-lang-zh" >中文</option>
        <option value="/rust-lang-ja" >日本語</option>
        <option value="/rust-lang-es" >Español</option>
        <option value="/rust-lang-hi" >हिंदी</option>
        <option value="/rust-lang-fr" >Français</option>
        <option value="/rust-lang-de" >Deutsch</option>
        <option value="/rust-lang-ar" >العربية</option>
        <option value="/rust-lang-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Okay, here’s a comprehensive guide to the Rust programming language, covering its core concepts, syntax, and advanced features. Rust is a systems programming language focused on safety, speed, and concurrency.</p>

<p><strong>I. Introduction to Rust</strong></p>

<ul>
  <li><strong>What is Rust?</strong>
    <ul>
      <li>Rust is a multi-paradigm, statically typed, compiled programming language designed for performance and safety, especially in areas like systems programming, game engines, web assembly, and embedded systems.</li>
      <li>It achieves memory safety without a garbage collector through a system of ownership, borrowing, and lifetimes.</li>
      <li>Rust emphasizes zero-cost abstractions, meaning you get high-level features without significant runtime overhead.</li>
    </ul>
  </li>
  <li><strong>Key Features and Design Principles:</strong>
    <ul>
      <li><strong>Memory Safety:</strong> Prevents common bugs like null pointer dereferences, data races, and buffer overflows at compile time.</li>
      <li><strong>Concurrency without Data Races:</strong> The ownership system makes it easier to write safe concurrent code.</li>
      <li><strong>Performance:</strong> Low-level control, zero-cost abstractions, and efficient compilation lead to excellent performance, often comparable to C++.</li>
      <li><strong>Expressive Type System:</strong> Powerful type inference, generics, traits (similar to interfaces or type classes), and algebraic data types.</li>
      <li><strong>Excellent Tooling:</strong> Cargo (build system and package manager), rustfmt (code formatter), clippy (linter).</li>
      <li><strong>Growing Ecosystem:</strong> A vibrant and active community with a growing number of libraries and frameworks.</li>
    </ul>
  </li>
  <li><strong>Use Cases:</strong>
    <ul>
      <li>Operating Systems</li>
      <li>Game Engines</li>
      <li>Web Assembly (Wasm)</li>
      <li>Embedded Systems</li>
      <li>Command-Line Tools</li>
      <li>Network Programming</li>
      <li>Cryptocurrencies</li>
      <li>High-Performance Computing</li>
    </ul>
  </li>
</ul>

<p><strong>II. Setting Up Your Rust Environment</strong></p>

<ul>
  <li><strong>Installation:</strong>
    <ul>
      <li>The recommended way to install Rust is using <code class="language-plaintext highlighter-rouge">rustup</code>, the official Rust toolchain installer.</li>
      <li>Visit <a href="https://rustup.rs/">https://rustup.rs/</a> and follow the instructions for your operating system.</li>
      <li>On Unix-like systems, you’ll typically run a command like: <code class="language-plaintext highlighter-rouge">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li>
    </ul>
  </li>
  <li><strong>Verifying Installation:</strong>
    <ul>
      <li>Open your terminal or command prompt and run:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">rustc --version</code>: Shows the Rust compiler version.</li>
          <li><code class="language-plaintext highlighter-rouge">cargo --version</code>: Shows the Cargo version.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Cargo: The Rust Build System and Package Manager:</strong>
    <ul>
      <li>Cargo is essential for managing Rust projects. It handles:
        <ul>
          <li>Building your code.</li>
          <li>Managing dependencies (crates).</li>
          <li>Running tests.</li>
          <li>Publishing libraries.</li>
        </ul>
      </li>
      <li><strong>Creating a New Project:</strong> <code class="language-plaintext highlighter-rouge">cargo new &lt;project_name&gt;</code> (creates a binary project). <code class="language-plaintext highlighter-rouge">cargo new --lib &lt;library_name&gt;</code> (creates a library project).</li>
      <li><strong>Project Structure:</strong> A typical Cargo project has:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">Cargo.toml</code>: The manifest file containing project metadata and dependencies.</li>
          <li><code class="language-plaintext highlighter-rouge">src/main.rs</code>: The entry point for binary projects.</li>
          <li><code class="language-plaintext highlighter-rouge">src/lib.rs</code>: The entry point for library projects.</li>
          <li><code class="language-plaintext highlighter-rouge">Cargo.lock</code>: Records the exact versions of dependencies used in the project.</li>
        </ul>
      </li>
      <li><strong>Building:</strong> <code class="language-plaintext highlighter-rouge">cargo build</code> (builds the project in debug mode). <code class="language-plaintext highlighter-rouge">cargo build --release</code> (builds the project with optimizations for release).</li>
      <li><strong>Running:</strong> <code class="language-plaintext highlighter-rouge">cargo run</code> (builds and runs the binary).</li>
      <li><strong>Adding Dependencies:</strong> Add crate names and versions to the <code class="language-plaintext highlighter-rouge">[dependencies]</code> section of <code class="language-plaintext highlighter-rouge">Cargo.toml</code>. Cargo will automatically download and build them.</li>
      <li><strong>Updating Dependencies:</strong> <code class="language-plaintext highlighter-rouge">cargo update</code>.</li>
    </ul>
  </li>
</ul>

<p><strong>III. Basic Rust Syntax and Concepts</strong></p>

<ul>
  <li><strong>Hello, World!</strong>
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">fn main()</code>: The main function where program execution begins.</li>
      <li><code class="language-plaintext highlighter-rouge">println!()</code>: A macro (indicated by the <code class="language-plaintext highlighter-rouge">!</code>) that prints text to the console.</li>
    </ul>
  </li>
  <li><strong>Variables and Mutability:</strong>
    <ul>
      <li>Variables are immutable by default. To make a variable mutable, use the <code class="language-plaintext highlighter-rouge">mut</code> keyword.</li>
      <li>Declaration: <code class="language-plaintext highlighter-rouge">let variable_name = value;</code> (type inference). <code class="language-plaintext highlighter-rouge">let variable_name: Type = value;</code> (explicit type annotation).</li>
      <li>Mutable variable: <code class="language-plaintext highlighter-rouge">let mut counter = 0; counter = 1;</code></li>
      <li>Constants: Declared with <code class="language-plaintext highlighter-rouge">const</code>, must have a type annotation, and their value must be known at compile time. <code class="language-plaintext highlighter-rouge">const MAX_POINTS: u32 = 100_000;</code></li>
      <li>Shadowing: You can declare a new variable with the same name as a previous one; the new variable shadows the old one.</li>
    </ul>
  </li>
  <li><strong>Data Types:</strong>
    <ul>
      <li><strong>Scalar Types:</strong> Represent a single value.
        <ul>
          <li><strong>Integers:</strong> <code class="language-plaintext highlighter-rouge">i8</code>, <code class="language-plaintext highlighter-rouge">i16</code>, <code class="language-plaintext highlighter-rouge">i32</code>, <code class="language-plaintext highlighter-rouge">i64</code>, <code class="language-plaintext highlighter-rouge">i128</code>, <code class="language-plaintext highlighter-rouge">isize</code> (pointer-sized signed); <code class="language-plaintext highlighter-rouge">u8</code>, <code class="language-plaintext highlighter-rouge">u16</code>, <code class="language-plaintext highlighter-rouge">u32</code>, <code class="language-plaintext highlighter-rouge">u64</code>, <code class="language-plaintext highlighter-rouge">u128</code>, <code class="language-plaintext highlighter-rouge">usize</code> (pointer-sized unsigned). Integer literals can have suffixes (e.g., <code class="language-plaintext highlighter-rouge">10u32</code>).</li>
          <li><strong>Floating-Point Numbers:</strong> <code class="language-plaintext highlighter-rouge">f32</code> (single-precision), <code class="language-plaintext highlighter-rouge">f64</code> (double-precision).</li>
          <li><strong>Booleans:</strong> <code class="language-plaintext highlighter-rouge">bool</code> (<code class="language-plaintext highlighter-rouge">true</code>, <code class="language-plaintext highlighter-rouge">false</code>).</li>
          <li><strong>Characters:</strong> <code class="language-plaintext highlighter-rouge">char</code> (Unicode scalar values, 4 bytes).</li>
          <li><strong>Unit Type:</strong> <code class="language-plaintext highlighter-rouge">()</code> (represents an empty tuple or the absence of a value).</li>
        </ul>
      </li>
      <li><strong>Compound Types:</strong> Group multiple values.
        <ul>
          <li><strong>Tuples:</strong> Fixed-size ordered sequences of elements with potentially different types. <code class="language-plaintext highlighter-rouge">let my_tuple = (1, "hello", 3.14); let (x, y, z) = my_tuple; let first = my_tuple.0;</code></li>
          <li><strong>Arrays:</strong> Fixed-size collections of elements of the same type. <code class="language-plaintext highlighter-rouge">let my_array = [1, 2, 3, 4, 5]; let months: [&amp;str; 12] = ["...", "..."]; let first = my_array[0];</code></li>
          <li><strong>Slices:</strong> Dynamically sized views into a contiguous sequence of elements in an array or another slice. <code class="language-plaintext highlighter-rouge">let slice = &amp;my_array[1..3];</code></li>
        </ul>
      </li>
      <li><strong>Other Important Types:</strong>
        <ul>
          <li><strong>Strings:</strong>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">String</code>: Growable, mutable, owned string data. Created using <code class="language-plaintext highlighter-rouge">String::from("...")</code> or by converting other string types.</li>
              <li><code class="language-plaintext highlighter-rouge">&amp;str</code>: String slice, an immutable view into string data. Often referred to as a “string literal” when directly embedded in code (e.g., <code class="language-plaintext highlighter-rouge">"hello"</code>).</li>
            </ul>
          </li>
          <li><strong>Vectors (<code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>):</strong> Resizable arrays that can grow or shrink. <code class="language-plaintext highlighter-rouge">let mut my_vec: Vec&lt;i32&gt; = Vec::new(); my_vec.push(1); let another_vec = vec![1, 2, 3];</code></li>
          <li><strong>Hash Maps (<code class="language-plaintext highlighter-rouge">HashMap&lt;K, V&gt;</code>):</strong> Store key-value pairs where keys are unique and of a hashable type. Requires <code class="language-plaintext highlighter-rouge">use std::collections::HashMap;</code>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Operators:</strong>
    <ul>
      <li><strong>Arithmetic:</strong> <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">%</code>.</li>
      <li><strong>Comparison:</strong> <code class="language-plaintext highlighter-rouge">==</code>, <code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>.</li>
      <li><strong>Logical:</strong> <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> (AND), <code class="language-plaintext highlighter-rouge">||</code> (OR), <code class="language-plaintext highlighter-rouge">!</code> (NOT).</li>
      <li><strong>Bitwise:</strong> <code class="language-plaintext highlighter-rouge">&amp;</code> (AND), <code class="language-plaintext highlighter-rouge">|</code> (OR), <code class="language-plaintext highlighter-rouge">^</code> (XOR), <code class="language-plaintext highlighter-rouge">!</code> (NOT), <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> (Left Shift), <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> (Right Shift).</li>
      <li><strong>Assignment:</strong> <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">+=</code>, <code class="language-plaintext highlighter-rouge">-=</code>, <code class="language-plaintext highlighter-rouge">*=</code>, <code class="language-plaintext highlighter-rouge">/=</code>, <code class="language-plaintext highlighter-rouge">%=</code>, <code class="language-plaintext highlighter-rouge">&amp;=</code>, <code class="language-plaintext highlighter-rouge">|=</code>, <code class="language-plaintext highlighter-rouge">^=</code>, <code class="language-plaintext highlighter-rouge">&lt;&lt;=</code>, <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code>.</li>
    </ul>
  </li>
  <li><strong>Control Flow:</strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">else if</code>, <code class="language-plaintext highlighter-rouge">else</code>:</strong> Conditional execution.
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">number</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"condition was true"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">number</span> <span class="o">==</span> <span class="mi">7</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"number is seven"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"condition was false"</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">loop</code>:</strong> Infinite loop (use <code class="language-plaintext highlighter-rouge">break</code> to exit).
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">loop</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"again!"</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">while</code>:</strong> Loop that continues as long as a condition is true.
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="k">mut</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"counter is {}"</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
      <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">for</code>:</strong> Iterating over collections.
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">];</span>
  <span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">a</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"the value is: {}"</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span> <span class="c1">// Iterates from 1 up to (but not including) 5</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">match</code>:</strong> Powerful control flow construct that compares a value against a series of patterns.
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">match</span> <span class="n">number</span> <span class="p">{</span>
      <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"one"</span><span class="p">),</span>
      <span class="mi">2</span> <span class="p">|</span> <span class="mi">3</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"two or three"</span><span class="p">),</span>
      <span class="mi">4</span><span class="o">..=</span><span class="mi">6</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"four, five, or six"</span><span class="p">),</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"something else"</span><span class="p">),</span> <span class="c1">// The wildcard pattern</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">if let</code>:</strong> A more concise way to handle enums or options where you only care about one or a few variants.
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="n">some_value</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">some_value</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"The value is: {}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p><strong>IV. Ownership, Borrowing, and Lifetimes</strong></p>

<p>This is the core of Rust’s memory safety guarantees.</p>

<ul>
  <li><strong>Ownership:</strong>
    <ul>
      <li>Each value in Rust has a variable that’s its <em>owner</em>.</li>
      <li>There can only be one owner of a value at a time.</li>
      <li>When the owner goes out of scope, the value will be dropped (its memory is deallocated).</li>
    </ul>
  </li>
  <li><strong>Borrowing:</strong>
    <ul>
      <li>Instead of transferring ownership, you can create references to a value. This is called <em>borrowing</em>.</li>
      <li><strong>Immutable Borrowing (<code class="language-plaintext highlighter-rouge">&amp;</code>):</strong> You can have multiple immutable references to a value at the same time. Immutable borrows do not allow modification of the borrowed value.</li>
      <li><strong>Mutable Borrowing (<code class="language-plaintext highlighter-rouge">&amp;mut</code>):</strong> You can have at most one mutable reference to a value at a time. Mutable borrows allow modification of the borrowed value.</li>
      <li><strong>Rules of Borrowing:</strong>
        <ol>
          <li>At any given time, you can have <em>either</em> one mutable reference <em>or</em> any number of immutable references.</li>
          <li>References must always be valid.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>Lifetimes:</strong>
    <ul>
      <li>Lifetimes are annotations that describe the scope for which a reference is valid. The Rust compiler uses lifetime information to ensure that references do not outlive the data they point to (dangling pointers).</li>
      <li>In many cases, the compiler can infer lifetimes automatically (lifetime elision).</li>
      <li>You may need to explicitly annotate lifetimes in function signatures or struct definitions when the lifetimes of references are not clear.</li>
      <li>Example of explicit lifetime annotation:
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">y</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">x</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">y</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>        </div>
        <p>The <code class="language-plaintext highlighter-rouge">'a</code> indicates that the returned string slice will live at least as long as both input string slices.</p>
      </li>
    </ul>
  </li>
</ul>

<p><strong>V. Structs, Enums, and Modules</strong></p>

<ul>
  <li><strong>Structs:</strong> User-defined data types that group together named fields.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
      <span class="n">active</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
      <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
      <span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
      <span class="n">sign_in_count</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">user1</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
          <span class="n">active</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
          <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someusername123"</span><span class="p">),</span>
          <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someone@example.com"</span><span class="p">),</span>
          <span class="n">sign_in_count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="p">};</span>

      <span class="n">user1</span><span class="py">.email</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"another@example.com"</span><span class="p">);</span>

      <span class="k">let</span> <span class="n">user2</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
          <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"another@example.com"</span><span class="p">),</span>
          <span class="o">..</span><span class="n">user1</span> <span class="c1">// Struct update syntax, remaining fields from user1</span>
      <span class="p">};</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>Tuple structs: Named tuples without named fields. <code class="language-plaintext highlighter-rouge">struct Color(i32, i32, i32);</code></li>
      <li>Unit-like structs: Structs with no fields. <code class="language-plaintext highlighter-rouge">struct AlwaysEqual;</code></li>
    </ul>
  </li>
  <li><strong>Enums (Enumerations):</strong> Define a type by enumerating its possible variants.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
      <span class="n">Quit</span><span class="p">,</span>
      <span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span> <span class="c1">// Anonymous struct</span>
      <span class="nf">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
      <span class="nf">ChangeColor</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">),</span> <span class="c1">// Tuple-like</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">::</span><span class="n">Quit</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">::</span><span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">5</span> <span class="p">};</span>
      <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">::</span><span class="nf">Write</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span>

      <span class="k">match</span> <span class="n">m</span> <span class="p">{</span>
          <span class="nn">Message</span><span class="p">::</span><span class="n">Quit</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Quit"</span><span class="p">),</span>
          <span class="nn">Message</span><span class="p">::</span><span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Move to x={}, y={}"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
          <span class="nn">Message</span><span class="p">::</span><span class="nf">Write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Write: {}"</span><span class="p">,</span> <span class="n">text</span><span class="p">),</span>
          <span class="nn">Message</span><span class="p">::</span><span class="nf">ChangeColor</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Change color to r={}, g={}, b={}"</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>Enums can hold data directly within their variants.</li>
    </ul>
  </li>
  <li><strong>Modules:</strong> Organize code within crates (packages).
    <ul>
      <li>Use the <code class="language-plaintext highlighter-rouge">mod</code> keyword to define a module.</li>
      <li>Modules can contain other modules, structs, enums, functions, etc.</li>
      <li>Control visibility with <code class="language-plaintext highlighter-rouge">pub</code> (public) and private (default).</li>
      <li>Access items within modules using the module path (e.g., <code class="language-plaintext highlighter-rouge">my_module::my_function()</code>).</li>
      <li>Bring items into the current scope with the <code class="language-plaintext highlighter-rouge">use</code> keyword (e.g., <code class="language-plaintext highlighter-rouge">use std::collections::HashMap;</code>).</li>
      <li>Separate modules into different files (convention: a module named <code class="language-plaintext highlighter-rouge">my_module</code> goes in <code class="language-plaintext highlighter-rouge">src/my_module.rs</code> or <code class="language-plaintext highlighter-rouge">src/my_module/mod.rs</code>).</li>
    </ul>
  </li>
</ul>

<p><strong>VI. Traits and Generics</strong></p>

<ul>
  <li><strong>Traits:</strong> Similar to interfaces or type classes in other languages. They define a set of methods that a type must implement to fulfill a certain contract.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">pub</span> <span class="k">trait</span> <span class="n">Summary</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">struct</span> <span class="n">NewsArticle</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="n">headline</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">location</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">author</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">impl</span> <span class="n">Summary</span> <span class="k">for</span> <span class="n">NewsArticle</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
          <span class="nd">format!</span><span class="p">(</span><span class="s">"{}, by {} ({})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.headline</span><span class="p">,</span> <span class="k">self</span><span class="py">.author</span><span class="p">,</span> <span class="k">self</span><span class="py">.location</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">struct</span> <span class="n">Tweet</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">reply</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">retweet</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">impl</span> <span class="n">Summary</span> <span class="k">for</span> <span class="n">Tweet</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
          <span class="nd">format!</span><span class="p">(</span><span class="s">"{}: {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.username</span><span class="p">,</span> <span class="k">self</span><span class="py">.content</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">tweet</span> <span class="o">=</span> <span class="n">Tweet</span> <span class="p">{</span>
          <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"horse_ebooks"</span><span class="p">),</span>
          <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"of course, as you probably already know, people"</span><span class="p">),</span>
          <span class="n">reply</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
          <span class="n">retweet</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
      <span class="p">};</span>

      <span class="nd">println!</span><span class="p">(</span><span class="s">"New tweet available! {}"</span><span class="p">,</span> <span class="n">tweet</span><span class="nf">.summarize</span><span class="p">());</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>Traits can have default implementations for methods.</li>
      <li>Traits can be used as bounds for generic types.</li>
    </ul>
  </li>
  <li><strong>Generics:</strong> Write code that can work with multiple types without knowing the specific types at compile time.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="n">largest</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">PartialOrd</span> <span class="o">+</span> <span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

      <span class="k">for</span> <span class="o">&amp;</span><span class="n">item</span> <span class="k">in</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
              <span class="n">largest</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>

      <span class="n">largest</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">number_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">65</span><span class="p">];</span>
      <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest number is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

      <span class="k">let</span> <span class="n">char_list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="sc">'y'</span><span class="p">,</span> <span class="sc">'m'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'q'</span><span class="p">];</span>
      <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char_list</span><span class="p">);</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"The largest char is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>Type parameters are declared within angle brackets <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>.</li>
      <li>Trait bounds (<code class="language-plaintext highlighter-rouge">T: PartialOrd + Copy</code>) specify what functionality the generic type must implement.</li>
      <li><code class="language-plaintext highlighter-rouge">PartialOrd</code> allows comparison using <code class="language-plaintext highlighter-rouge">&gt;</code>, and <code class="language-plaintext highlighter-rouge">Copy</code> means the type can be copied by value.</li>
    </ul>
  </li>
</ul>

<p><strong>VII. Error Handling</strong></p>

<p>Rust emphasizes explicit error handling.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Result</code> Enum:</strong> Represents either success (<code class="language-plaintext highlighter-rouge">Ok</code>) or failure (<code class="language-plaintext highlighter-rouge">Err</code>).
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="nf">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
      <span class="nf">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">T</code> is the type of the success value.</li>
      <li><code class="language-plaintext highlighter-rouge">E</code> is the type of the error value.</li>
      <li>Commonly used for operations that might fail (e.g., file I/O, network requests).</li>
      <li>The <code class="language-plaintext highlighter-rouge">?</code> operator is syntactic sugar for handling <code class="language-plaintext highlighter-rouge">Result</code> values. If the <code class="language-plaintext highlighter-rouge">Result</code> is <code class="language-plaintext highlighter-rouge">Ok</code>, it unwraps the value; if it’s <code class="language-plaintext highlighter-rouge">Err</code>, it returns the error early from the current function.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">panic!</code> Macro:</strong> Causes the program to crash immediately. Generally used for unrecoverable errors.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
      <span class="c1">// v[99]; // This will cause a panic at runtime</span>
      <span class="nd">panic!</span><span class="p">(</span><span class="s">"Crash and burn!"</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Option</code> Enum:</strong> Represents a value that may or may not be present.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
      <span class="nb">None</span><span class="p">,</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>Used to avoid null pointers.</li>
      <li>Methods like <code class="language-plaintext highlighter-rouge">unwrap()</code>, <code class="language-plaintext highlighter-rouge">unwrap_or()</code>, <code class="language-plaintext highlighter-rouge">map()</code>, and <code class="language-plaintext highlighter-rouge">and_then()</code> are used to work with <code class="language-plaintext highlighter-rouge">Option</code> values.
  ```rust
  fn divide(a: i32, b: i32) -&gt; Option<i32> {
  if b == 0 {
      None
  } else {
      Some(a / b)
  }
  }</i32></li>
    </ul>

    <p>fn main() {
      let result1 = divide(10, 2);
      match result1 {
          Some(value) =&gt; println!(“Result: {}”, value),
          None =&gt; println!(“Cannot divide by zero”),
      }</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  let result2 = divide(5, 0);
  println!("Result 2: {:?}", result2.unwrap_or(-1)); // Returns -1 if None   }   ```
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>VIII. Closures and Iterators</strong></p>

<ul>
  <li><strong>Closures:</strong> Anonymous functions that can capture variables from their surrounding scope.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">equal_to_x</span> <span class="o">=</span> <span class="p">|</span><span class="n">z</span><span class="p">|</span> <span class="n">z</span> <span class="o">==</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// Closure that captures x</span>

      <span class="nd">println!</span><span class="p">(</span><span class="s">"Is 5 equal to x? {}"</span><span class="p">,</span> <span class="nf">equal_to_x</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>Closure syntax: <code class="language-plaintext highlighter-rouge">|parameters| -&gt; return_type { body }</code> (return type can often be inferred).</li>
      <li>Closures can capture variables by reference (<code class="language-plaintext highlighter-rouge">&amp;</code>), by mutable reference (<code class="language-plaintext highlighter-rouge">&amp;mut</code>), or by value (moving ownership). Rust infers the capture type. Use the <code class="language-plaintext highlighter-rouge">move</code> keyword to force ownership transfer.</li>
    </ul>
  </li>
  <li><strong>Iterators:</strong> Provide a way to process a sequence of elements.
    <ul>
      <li>Created by calling the <code class="language-plaintext highlighter-rouge">iter()</code> method on collections like vectors, arrays, and hash maps (for immutable iteration), <code class="language-plaintext highlighter-rouge">iter_mut()</code> for mutable iteration, and <code class="language-plaintext highlighter-rouge">into_iter()</code> to consume the collection and take ownership of its elements.</li>
      <li>Iterators are lazy; they only produce values when explicitly consumed.</li>
      <li>Common iterator adaptors (methods that transform iterators): <code class="language-plaintext highlighter-rouge">map()</code>, <code class="language-plaintext highlighter-rouge">filter()</code>, <code class="language-plaintext highlighter-rouge">take()</code>, <code class="language-plaintext highlighter-rouge">skip()</code>, <code class="language-plaintext highlighter-rouge">zip()</code>, <code class="language-plaintext highlighter-rouge">enumerate()</code>, etc.</li>
      <li>Common iterator consumers (methods that produce a final value): <code class="language-plaintext highlighter-rouge">collect()</code>, <code class="language-plaintext highlighter-rouge">sum()</code>, <code class="language-plaintext highlighter-rouge">product()</code>, <code class="language-plaintext highlighter-rouge">fold()</code>, <code class="language-plaintext highlighter-rouge">any()</code>, <code class="language-plaintext highlighter-rouge">all()</code>, etc.
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">v1</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

  <span class="k">let</span> <span class="n">v1_iter</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.iter</span><span class="p">();</span> <span class="c1">// Creates an iterator over v1</span>

  <span class="k">for</span> <span class="n">val</span> <span class="k">in</span> <span class="n">v1_iter</span> <span class="p">{</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"Got: {}"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">v2</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span> <span class="c1">// Transform and collect</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"v2: {:?}"</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">sum</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.sum</span><span class="p">();</span> <span class="c1">// Consume the iterator to get a sum</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"Sum of v1: {}"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p><strong>IX. Smart Pointers</strong></p>

<p>Smart pointers are data structures that act like pointers but also have additional metadata and capabilities. They enforce different sets of rules than regular references.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code>:</strong> The simplest smart pointer. It allocates memory on the heap and provides ownership of the value. When the <code class="language-plaintext highlighter-rouge">Box</code> goes out of scope, the value on the heap is dropped. Useful for:
    <ul>
      <li>Data whose size isn’t known at compile time.</li>
      <li>Transferring ownership of large amounts of data.</li>
      <li>Creating recursive data structures.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> (Reference Counting):</strong> Enables multiple parts of the program to have read-only access to the same data. The data is only cleaned up when the last <code class="language-plaintext highlighter-rouge">Rc</code> pointer goes out of scope. Not thread-safe.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> (Atomically Reference Counted):</strong> Similar to <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> but thread-safe for use in concurrent scenarios. Has some performance overhead compared to <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> (Interior Mutability):</strong> Allow modifying data even when there are immutable references to it. This violates Rust’s usual borrowing rules and is used in specific, controlled situations.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code>: For types that are <code class="language-plaintext highlighter-rouge">Copy</code>. Allows setting and getting the value.</li>
      <li><code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>: For types that are not <code class="language-plaintext highlighter-rouge">Copy</code>. Provides runtime borrowing checks (panics if borrowing rules are violated at runtime).</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">RwLock&lt;T&gt;</code> (Concurrency Primitives):</strong> Provide mechanisms for safe shared mutable access across threads.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code>: Allows only one thread to hold the lock and access the data at a time.</li>
      <li><code class="language-plaintext highlighter-rouge">RwLock&lt;T&gt;</code>: Allows multiple readers or a single writer to access the data.</li>
    </ul>
  </li>
</ul>

<p><strong>X. Concurrency</strong></p>

<p>Rust has excellent built-in support for concurrency.</p>

<ul>
  <li><strong>Threads:</strong> Spawn new OS threads using <code class="language-plaintext highlighter-rouge">std::thread::spawn</code>.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
  <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="p">{</span>
          <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span>
              <span class="nd">println!</span><span class="p">(</span><span class="s">"hi number {} from the spawned thread!"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
              <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
          <span class="p">}</span>
      <span class="p">});</span>

      <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
          <span class="nd">println!</span><span class="p">(</span><span class="s">"hi number {} from the main thread!"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
          <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
      <span class="p">}</span>

      <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span> <span class="c1">// Wait for the spawned thread to finish</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Message Passing:</strong> Use channels (provided by <code class="language-plaintext highlighter-rouge">std::sync::mpsc</code>) to send data between threads.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">mpsc</span><span class="p">;</span>
  <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
  <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nf">channel</span><span class="p">();</span>

      <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
          <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hi"</span><span class="p">);</span>
          <span class="n">tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
          <span class="c1">// println!("val is {}", val); // Error: val has been moved</span>
      <span class="p">});</span>

      <span class="k">let</span> <span class="n">received</span> <span class="o">=</span> <span class="n">rx</span><span class="nf">.recv</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"Got: {}"</span><span class="p">,</span> <span class="n">received</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Shared State Concurrency:</strong> Use smart pointers like <code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> for safe shared mutable access across multiple threads.</li>
</ul>

<p><strong>XI. Macros</strong></p>

<p>Macros are a form of metaprogramming in Rust. They allow you to write code that writes other code.</p>

<ul>
  <li><strong>Declarative Macros (<code class="language-plaintext highlighter-rouge">macro_rules!</code>):</strong> Match against patterns and replace them with other code. Powerful for reducing boilerplate.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">macro_rules!</span> <span class="n">vec</span> <span class="p">{</span>
      <span class="p">(</span> <span class="nv">$</span><span class="p">(</span> <span class="nv">$x:expr</span> <span class="p">),</span><span class="o">*</span> <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
          <span class="p">{</span>
              <span class="k">let</span> <span class="k">mut</span> <span class="n">temp_vec</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
              <span class="nv">$</span><span class="p">(</span>
                  <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
              <span class="p">)</span><span class="o">*</span>
              <span class="n">temp_vec</span>
          <span class="p">}</span>
      <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">my_vec</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">my_vec</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Procedural Macros:</strong> More powerful and complex than declarative macros. They operate on the abstract syntax tree (AST) of Rust code. There are three types:
    <ul>
      <li><strong>Function-like macros:</strong> Look like function calls.</li>
      <li><strong>Attribute-like macros:</strong> Used with the <code class="language-plaintext highlighter-rouge">#[...]</code> syntax.</li>
      <li><strong>Derive macros:</strong> Used with <code class="language-plaintext highlighter-rouge">#[derive(...)]</code> to automatically implement traits.</li>
    </ul>
  </li>
</ul>

<p><strong>XII. Testing</strong></p>

<p>Rust has built-in support for writing and running tests.</p>

<ul>
  <li><strong>Unit Tests:</strong> Test individual units of code (functions, modules). Typically placed in the same file as the code they are testing, within a <code class="language-plaintext highlighter-rouge">#[cfg(test)]</code> module.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">left</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
      <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
  <span class="p">}</span>

  <span class="nd">#[cfg(test)]</span>
  <span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
      <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

      <span class="nd">#[test]</span>
      <span class="k">fn</span> <span class="nf">it_works</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
          <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Integration Tests:</strong> Test how different parts of your library or binary work together. Placed in a separate <code class="language-plaintext highlighter-rouge">tests</code> directory at the top level of your project.</li>
  <li><strong>Running Tests:</strong> Use the <code class="language-plaintext highlighter-rouge">cargo test</code> command.</li>
</ul>

<p><strong>XIII. Unsafe Rust</strong></p>

<p>Rust’s safety guarantees are enforced by the compiler. However, there are situations where you might need to bypass these guarantees. This is done using the <code class="language-plaintext highlighter-rouge">unsafe</code> keyword.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">unsafe</code> Block:</strong> Code within an <code class="language-plaintext highlighter-rouge">unsafe</code> block can perform operations that the compiler cannot guarantee to be safe, such as:
    <ul>
      <li>Dereferencing raw pointers (<code class="language-plaintext highlighter-rouge">*const T</code>, <code class="language-plaintext highlighter-rouge">*mut T</code>).</li>
      <li>Calling <code class="language-plaintext highlighter-rouge">unsafe</code> functions or methods.</li>
      <li>Accessing fields of <code class="language-plaintext highlighter-rouge">union</code>s.</li>
      <li>Linking to external (non-Rust) code.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">unsafe</code> Functions:</strong> Functions that contain <code class="language-plaintext highlighter-rouge">unsafe</code> operations are themselves marked as <code class="language-plaintext highlighter-rouge">unsafe</code>. Calling an <code class="language-plaintext highlighter-rouge">unsafe</code> function requires an <code class="language-plaintext highlighter-rouge">unsafe</code> block.</li>
  <li><strong>Reasons to Use <code class="language-plaintext highlighter-rouge">unsafe</code>:</strong> Interfacing with C libraries, low-level systems programming, performance-critical code where the safety invariants are manually maintained.</li>
  <li><strong>Important Note:</strong> <code class="language-plaintext highlighter-rouge">unsafe</code> should be used sparingly and with extreme caution. It’s your responsibility to ensure memory safety within <code class="language-plaintext highlighter-rouge">unsafe</code> blocks.</li>
</ul>

<p><strong>XIV. The Rust Ecosystem</strong></p>

<ul>
  <li><strong>Crates (Packages):</strong> Libraries or executables that can be used in Rust projects. Found on <a href="https://crates.io/">https://crates.io/</a>.</li>
  <li><strong>Popular Crates:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">serde</code>: Serialization and deserialization.</li>
      <li><code class="language-plaintext highlighter-rouge">tokio</code>, <code class="language-plaintext highlighter-rouge">async-std</code>: Asynchronous programming.</li>
      <li><code class="language-plaintext highlighter-rouge">actix-web</code>, <code class="language-plaintext highlighter-rouge">rocket</code>: Web frameworks.</li>
      <li><code class="language-plaintext highlighter-rouge">diesel</code>, <code class="language-plaintext highlighter-rouge">sea-orm</code>: Object-relational mappers (ORMs).</li>
      <li><code class="language-plaintext highlighter-rouge">clap</code>, <code class="language-plaintext highlighter-rouge">structopt</code>: Command-line argument parsing.</li>
      <li><code class="language-plaintext highlighter-rouge">log</code>, <code class="language-plaintext highlighter-rouge">env_logger</code>: Logging.</li>
      <li><code class="language-plaintext highlighter-rouge">rand</code>: Random number generation.</li>
    </ul>
  </li>
  <li><strong>Rust Standard Library (<code class="language-plaintext highlighter-rouge">std</code>):</strong> Provides essential functionalities.</li>
</ul>

<p><strong>XV. Learning Resources</strong></p>

<ul>
  <li><strong>The Rust Programming Language Book:</strong> The official and comprehensive guide (<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>).</li>
  <li><strong>Rust by Example:</strong> A collection of runnable examples illustrating various Rust features (<a href="https://doc.rust-lang.org/rust-by-example/">https://doc.rust-lang.org/rust-by-example/</a>).</li>
  <li><strong>The Rustlings Course:</strong> A set of small exercises to get you used to reading and writing Rust code (<a href="https://github.com/rust-lang/rustlings">https://github.com/rust-lang/rustlings</a>).</li>
  <li><strong>Rust Documentation:</strong> The official API documentation (<a href="https://doc.rust-lang.org/std/">https://doc.rust-lang.org/std/</a>).</li>
  <li><strong>The Rust Blog:</strong> Official announcements and updates (<a href="https://blog.rust-lang.org/">https://blog.rust-lang.org/</a>).</li>
  <li><strong>Reddit (r/rust), Discord, and other community platforms.</strong></li>
</ul>

<p>This guide provides a solid foundation for learning Rust. The best way to become proficient is to practice writing Rust code, explore the ecosystem, and engage with the community. Good luck on your Rust journey!</p>



  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
