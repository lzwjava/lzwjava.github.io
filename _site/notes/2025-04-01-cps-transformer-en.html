<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>CPS Transformer</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>CPS Transformer | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="CPS Transformer" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-04-01-cps-transformer-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-04-01-cps-transformer-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="CPS Transformer" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"CPS Transformer","url":"https://lzwjava.github.io/notes/2025-04-01-cps-transformer-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=56a48ebaacc832679645e94f166d29e2d66cd1fe">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=56a48ebaacc832679645e94f166d29e2d66cd1fe" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       CPS Transformer | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-04-01-cps-transformer-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-04-01-cps-transformer-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.09</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/cps-transformer-en" selected>English</option>
        <option value="/cps-transformer-zh" >中文</option>
        <option value="/cps-transformer-ja" >日本語</option>
        <option value="/cps-transformer-es" >Español</option>
        <option value="/cps-transformer-hi" >हिंदी</option>
        <option value="/cps-transformer-fr" >Français</option>
        <option value="/cps-transformer-de" >Deutsch</option>
        <option value="/cps-transformer-ar" >العربية</option>
        <option value="/cps-transformer-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; A simple CPS transformer which does proper tail-call and does not</span>
<span class="c1">;; duplicate contexts for if-expressions.</span>
<span class="c1">;; author: Yin Wang (yw21@cs.indiana.edu)</span>
<span class="p">(</span><span class="nb">load</span> <span class="s">"pmatch.scm"</span><span class="p">)</span> <span class="c1">; Loads a pattern matching library for Scheme, making it easier to handle different expression structures.</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">cps</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">exp</span><span class="p">)</span>
    <span class="p">(</span><span class="k">letrec</span>
        <span class="p">([</span><span class="nf">trivial?</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">memq</span> <span class="nv">x</span> <span class="o">'</span><span class="p">(</span><span class="nb">zero?</span> <span class="nv">add1</span> <span class="nv">sub1</span><span class="p">)))]</span> <span class="c1">; Checks if a given symbol is one of the primitive operators: zero?, add1, sub1. These are treated specially in the transformation.</span>
         <span class="p">[</span><span class="nf">id</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">v</span><span class="p">)</span> <span class="nv">v</span><span class="p">)]</span> <span class="c1">; The identity function, used as the initial continuation for the top-level expression.</span>
         <span class="p">[</span><span class="nf">ctx0</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">v</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nf">k</span> <span class="o">,</span><span class="nv">v</span><span class="p">))]</span>      <span class="c1">; tail context. This creates a continuation that simply applies the current continuation 'k' to a value 'v'. It's used when the current call is in tail position.</span>
         <span class="p">[</span><span class="nf">fv</span> <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">n</span> <span class="mi">-1</span><span class="p">])</span> <span class="c1">; Creates a generator for fresh variable names.</span>
               <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
                 <span class="p">(</span><span class="k">set!</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">string-&gt;symbol</span> <span class="p">(</span><span class="nb">string-append</span> <span class="s">"v"</span> <span class="p">(</span><span class="nb">number-&gt;string</span> <span class="nv">n</span><span class="p">)))))]</span>
         <span class="p">[</span><span class="nf">cps1</span>
          <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">exp</span> <span class="nv">ctx</span><span class="p">)</span> <span class="c1">; The core recursive function that performs the CPS transformation. It takes an expression 'exp' and a continuation 'ctx' as arguments. The continuation represents what to do with the result of evaluating 'exp'.</span>
            <span class="p">(</span><span class="nf">pmatch</span> <span class="nv">exp</span> <span class="c1">; Uses pattern matching to analyze the structure of the expression.</span>
              <span class="p">[</span><span class="nf">,x</span> <span class="p">(</span><span class="nf">guard</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">pair?</span> <span class="nv">x</span><span class="p">)))</span> <span class="p">(</span><span class="nf">ctx</span> <span class="nv">x</span><span class="p">)]</span> <span class="c1">; Base case: If the expression 'x' is not a pair (i.e., it's a literal or a variable), it means it's already a value. Apply the current continuation 'ctx' to this value.</span>

              <span class="p">[(</span><span class="k">if</span> <span class="o">,</span><span class="nv">test</span> <span class="o">,</span><span class="nv">conseq</span> <span class="o">,</span><span class="nv">alt</span><span class="p">)</span> <span class="c1">; Matches an 'if' expression with a test, consequent, and alternative.</span>
               <span class="p">(</span><span class="nf">cps1</span> <span class="nv">test</span> <span class="c1">; Recursively transform the 'test' expression.</span>
                     <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">t</span><span class="p">)</span> <span class="c1">; The continuation for the 'test' expression. It takes the result of the test (which will be a boolean value) as 't'.</span>
                       <span class="p">(</span><span class="k">cond</span>
                        <span class="p">[(</span><span class="nb">memq</span> <span class="nv">ctx</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">ctx0</span> <span class="nv">id</span><span class="p">))</span> <span class="c1">; If the current context 'ctx' is either the tail context 'ctx0' or the initial identity context 'id', it means the 'if' expression itself is in a tail position.</span>
                         <span class="o">`</span><span class="p">(</span><span class="k">if</span> <span class="o">,</span><span class="nv">t</span> <span class="o">,</span><span class="p">(</span><span class="nf">cps1</span> <span class="nv">conseq</span> <span class="nv">ctx</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nf">cps1</span> <span class="nv">alt</span> <span class="nv">ctx</span><span class="p">))]</span> <span class="c1">; In this case, the 'if' expression remains an 'if' expression in the CPSed code. The consequent and alternative are CPSed with the same context 'ctx'. This avoids duplicating contexts.</span>
                        <span class="p">[</span><span class="k">else</span> <span class="c1">; If the current context is not a tail context, it means the result of the 'if' expression needs to be passed to some further computation.</span>
                         <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">u</span> <span class="p">(</span><span class="nf">fv</span><span class="p">)])</span> <span class="c1">; Generate a fresh variable name 'u' to hold the result of the 'if' expression.</span>
                           <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">k</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,u</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nf">ctx</span> <span class="nv">u</span><span class="p">))])</span> <span class="c1">; Create a new continuation 'k' that takes the result 'u' and applies the original context 'ctx' to it.</span>
                              <span class="p">(</span><span class="k">if</span> <span class="o">,</span><span class="nv">t</span> <span class="o">,</span><span class="p">(</span><span class="nf">cps1</span> <span class="nv">conseq</span> <span class="nv">ctx0</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nf">cps1</span> <span class="nv">alt</span> <span class="nv">ctx0</span><span class="p">))))])))]</span> <span class="c1">; The 'if' expression is wrapped in a 'let' that introduces the new continuation 'k'. The consequent and alternative are CPSed with the tail context 'ctx0', as their results will be immediately passed to 'k'.</span>

              <span class="p">[(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,x</span><span class="p">)</span> <span class="o">,</span><span class="nv">body</span><span class="p">)</span> <span class="c1">; Matches a lambda expression with a single argument 'x' and a body.</span>
               <span class="p">(</span><span class="nf">ctx</span> <span class="o">`</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,x</span> <span class="nv">k</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nf">cps1</span> <span class="nv">body</span> <span class="nv">ctx0</span><span class="p">)))]</span> <span class="c1">; The lambda expression is transformed into a new lambda expression that takes an additional argument 'k' (the continuation). The body of the original lambda is CPSed with the tail context 'ctx0', as its result will be passed to this continuation 'k'.</span>

              <span class="p">[(</span><span class="nf">,op</span> <span class="o">,</span><span class="nv">a</span> <span class="o">,</span><span class="nv">b</span><span class="p">)</span> <span class="c1">; Matches an expression with a binary operator 'op' and two operands 'a' and 'b'.</span>
               <span class="p">(</span><span class="nf">cps1</span> <span class="nv">a</span> <span class="c1">; Recursively transform the first operand 'a'.</span>
                     <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">v1</span><span class="p">)</span> <span class="c1">; The continuation for 'a'. It takes the result 'v1'.</span>
                       <span class="p">(</span><span class="nf">cps1</span> <span class="nv">b</span> <span class="c1">; Recursively transform the second operand 'b'.</span>
                             <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">v2</span><span class="p">)</span> <span class="c1">; The continuation for 'b'. It takes the result 'v2'.</span>
                                   <span class="p">(</span><span class="nf">ctx</span> <span class="o">`</span><span class="p">(</span><span class="nf">,op</span> <span class="o">,</span><span class="nv">v1</span> <span class="o">,</span><span class="nv">v2</span><span class="p">))))))]</span> <span class="c1">; Apply the original context 'ctx' to the expression formed by the operator 'op' and the CPSed results of the operands 'v1' and 'v2'.</span>

              <span class="p">[(</span><span class="nf">,rator</span> <span class="o">,</span><span class="nv">rand</span><span class="p">)</span> <span class="c1">; Matches a function application with a rator (the function) and a rand (the argument).</span>
               <span class="p">(</span><span class="nf">cps1</span> <span class="nv">rator</span> <span class="c1">; Recursively transform the rator.</span>
                     <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">r</span><span class="p">)</span> <span class="c1">; The continuation for the rator. It takes the result 'r' (the function).</span>
                       <span class="p">(</span><span class="nf">cps1</span> <span class="nv">rand</span> <span class="c1">; Recursively transform the operand.</span>
                             <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">d</span><span class="p">)</span> <span class="c1">; The continuation for the operand. It takes the result 'd' (the argument).</span>
                               <span class="p">(</span><span class="k">cond</span>
                                <span class="p">[(</span><span class="nf">trivial?</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="nf">ctx</span> <span class="o">`</span><span class="p">(</span><span class="nf">,r</span> <span class="o">,</span><span class="nv">d</span><span class="p">))]</span> <span class="c1">; If the rator 'r' is a trivial operator (like zero?, add1, sub1), apply the current context 'ctx' to the application of the operator to the operand.</span>
                                <span class="p">[(</span><span class="nb">eq?</span> <span class="nv">ctx</span> <span class="nv">ctx0</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nf">,r</span> <span class="o">,</span><span class="nv">d</span> <span class="nv">k</span><span class="p">)]</span>  <span class="c1">; tail call. If the current context is the tail context 'ctx0', it means this function application is in a tail position. The CPSed function 'r' is called with the CPSed argument 'd' and the current continuation 'k'.</span>
                                <span class="p">[</span><span class="k">else</span> <span class="c1">; If the function application is not in a tail position.</span>
                                 <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">u</span> <span class="p">(</span><span class="nf">fv</span><span class="p">)])</span> <span class="c1">; Generate a fresh variable name 'u' for the result.</span>
                                   <span class="o">`</span><span class="p">(</span><span class="nf">,r</span> <span class="o">,</span><span class="nv">d</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,u</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nf">ctx</span> <span class="nv">u</span><span class="p">))))])))))]))])</span> <span class="c1">; The CPSed function 'r' is called with the CPSed argument 'd' and a new continuation that takes the result 'u' and applies the original context 'ctx' to it.</span>

      <span class="p">(</span><span class="nf">cps1</span> <span class="nv">exp</span> <span class="nv">id</span><span class="p">))))</span><span class="c1">;; Starts the CPS transformation by calling 'cps1' with the input expression 'exp' and the initial identity continuation 'id'.</span>

<span class="c1">;;; tests</span>
<span class="c1">;; var</span>
<span class="p">(</span><span class="nf">cps</span> <span class="ss">'x</span><span class="p">)</span> <span class="c1">; Transforms the variable 'x'. The result will be '(k x)' because the initial context is 'id', and 'id' is applied to 'x'.</span>

<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span> <span class="c1">; Transforms a simple identity lambda function. The result will be '(lambda (x k) (k x))'.</span>

<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">x</span> <span class="mi">1</span><span class="p">)))</span> <span class="c1">; Transforms a lambda function that applies its argument to 1. The result will be '(lambda (x k) (x 1 k))'.</span>

<span class="c1">;; no lambda (will generate identity functions to return to the toplevel)</span>
<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span> <span class="c1">; Transforms an if expression where the test is a function call.</span>

<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">))</span> <span class="c1">; Transforms an if expression where the test is a variable.</span>

<span class="c1">;; if stand-alone (tail)</span>
<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">))</span> <span class="c1">; Here, the 'if' is at the top level, so it's in a tail context.</span>

<span class="c1">;; if inside if-test (non-tail)</span>
<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span> <span class="c1">; The 'if' is inside a lambda, and its result is used by the lambda (implicitly returned), so it's not in a tail context.</span>

<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)))</span> <span class="c1">; Nested 'if' expressions. The inner 'if' is in the test of the outer 'if'.</span>

<span class="c1">;; both branches are trivial, should do some more optimizations</span>
<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">zero?</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)))</span>

<span class="c1">;; if inside if-branch (tail)</span>
<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="nv">t</span> <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">c</span><span class="p">)))</span> <span class="c1">; The inner 'if' is in the consequent branch of the outer 'if'. If the outer 'if' is in a tail context, the inner one will also be.</span>

<span class="c1">;; if inside if-branch, but again inside another if-test (non-tail)</span>
<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="k">if</span> <span class="nv">t</span> <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">e</span> <span class="nv">w</span><span class="p">)))</span>

<span class="c1">;; if as operand (non-tail)</span>
<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">h</span> <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">))))</span> <span class="c1">; The result of the 'if' expression is used as an argument to 'h'.</span>

<span class="c1">;; if as operator (non-tail)</span>
<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">((</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">g</span><span class="p">)</span> <span class="nv">h</span><span class="p">)</span> <span class="nv">c</span><span class="p">)))</span> <span class="c1">; The result of the 'if' expression is used as the function to be called.</span>

<span class="c1">;; why we need more than two names</span>
<span class="p">(</span><span class="nf">cps</span> <span class="o">'</span><span class="p">(((</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">b</span><span class="p">))</span> <span class="p">((</span><span class="nf">f</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">d</span><span class="p">))))</span> <span class="c1">; This example likely demonstrates the need for the fresh variable name generator ('fv') to avoid naming conflicts when transforming complex nested expressions.</span>

<span class="c1">;; factorial</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">fact-cps</span>
  <span class="p">(</span><span class="nf">cps</span>
   <span class="o">'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span>
      <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">fact</span><span class="p">)</span>
         <span class="p">((</span><span class="nf">fact</span> <span class="nv">fact</span><span class="p">)</span> <span class="nv">n</span><span class="p">))</span>
       <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">fact</span><span class="p">)</span>
         <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span>
           <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zero?</span> <span class="nv">n</span><span class="p">)</span>
               <span class="mi">1</span>
               <span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="p">((</span><span class="nf">fact</span> <span class="nv">fact</span><span class="p">)</span> <span class="p">(</span><span class="nf">sub1</span> <span class="nv">n</span><span class="p">))))))))))</span><span class="c1">;; print out CPSed function</span>

<span class="p">(</span><span class="nf">pretty-print</span> <span class="nv">fact-cps</span><span class="p">)</span><span class="c1">;; =&gt;</span>
<span class="c1">;; '(lambda (n k)</span>
<span class="c1">;;    ((lambda (fact k) (fact fact (lambda (v0) (v0 n k))))</span>
<span class="c1">;;     (lambda (fact k)</span>
<span class="c1">;;       (k</span>
<span class="c1">;;        (lambda (n k)</span>
<span class="c1">;;          (if (zero? n)</span>
<span class="c1">;;            (k 1)</span>
<span class="c1">;;            (fact</span>
<span class="c1">;;             fact</span>
<span class="c1">;;             (lambda (v1) (v1 (sub1 n) (lambda (v2) (k (* n v2))))))))));</span>
<span class="c1">;;     k))</span>

<span class="p">((</span><span class="nb">eval</span> <span class="nv">fact-cps</span><span class="p">)</span> <span class="mi">5</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">v</span><span class="p">)</span> <span class="nv">v</span><span class="p">))</span><span class="c1">;; =&gt; 120</span>
</code></pre></div></div>

<p><strong>Explanation of the CPS Transformer:</strong></p>

<p>This Scheme code implements a Continuation-Passing Style (CPS) transformation for a simple subset of the Scheme language. Here’s a breakdown of the key concepts and how the code works:</p>

<p><strong>1. Continuation-Passing Style (CPS):</strong></p>

<ul>
  <li>In CPS, a function doesn’t return a value directly. Instead, it takes an extra argument called a <strong>continuation</strong>.</li>
  <li>The continuation is a function that represents the rest of the computation to be performed with the result of the current function.</li>
  <li>When a CPS function finishes its computation, it calls the continuation with the result.</li>
</ul>

<p><strong>Why use CPS?</strong></p>

<ul>
  <li><strong>Explicit Control Flow:</strong> CPS makes the flow of control explicit. Function calls and returns are replaced by calls to continuations.</li>
  <li><strong>Tail-Call Optimization:</strong> CPS enables easy implementation of proper tail-call optimization. In the transformed code, function calls in tail position become the last operation, allowing for efficient execution without increasing the stack depth.</li>
  <li><strong>Implementing Advanced Control Structures:</strong> CPS can be used as an intermediate representation in compilers to implement features like exceptions, coroutines, and backtracking.</li>
</ul>

<p><strong>2. The <code class="language-plaintext highlighter-rouge">cps</code> Function:</strong></p>

<ul>
  <li>The main entry point for the transformation. It takes an expression <code class="language-plaintext highlighter-rouge">exp</code> as input.</li>
  <li>It uses <code class="language-plaintext highlighter-rouge">letrec</code> to define several mutually recursive helper functions.</li>
  <li>It initializes the transformation by calling <code class="language-plaintext highlighter-rouge">cps1</code> with the input expression and the identity function <code class="language-plaintext highlighter-rouge">id</code> as the initial continuation. This means that the final result of the transformed expression will be returned directly.</li>
</ul>

<p><strong>3. Helper Functions:</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">trivial?</code>:</strong> Identifies primitive operators like <code class="language-plaintext highlighter-rouge">zero?</code>, <code class="language-plaintext highlighter-rouge">add1</code>, and <code class="language-plaintext highlighter-rouge">sub1</code>. These are handled specially in the transformation.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">id</code>:</strong> The identity function <code class="language-plaintext highlighter-rouge">(lambda (v) v)</code>. It’s the initial continuation, meaning “just return the value”.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ctx0</code>:</strong> Creates a “tail context”. Given a value <code class="language-plaintext highlighter-rouge">v</code>, it returns <code class="language-plaintext highlighter-rouge">(k v)</code>, where <code class="language-plaintext highlighter-rouge">k</code> is the current continuation. This signifies that the current computation is in a tail position, and the result should be passed directly to the awaiting continuation.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fv</code>:</strong> Generates fresh variable names (e.g., <code class="language-plaintext highlighter-rouge">v0</code>, <code class="language-plaintext highlighter-rouge">v1</code>, <code class="language-plaintext highlighter-rouge">v2</code>, …). This is crucial to avoid variable capture when introducing new continuations.</li>
</ul>

<p><strong>4. The <code class="language-plaintext highlighter-rouge">cps1</code> Function (The Core Transformation):</strong></p>

<ul>
  <li>This function recursively traverses the input expression and transforms it into CPS.</li>
  <li>It takes two arguments: the expression <code class="language-plaintext highlighter-rouge">exp</code> to be transformed and the current continuation <code class="language-plaintext highlighter-rouge">ctx</code>.</li>
  <li>
    <p>It uses the <code class="language-plaintext highlighter-rouge">pmatch</code> library for pattern matching to handle different types of expressions:</p>

    <ul>
      <li>
        <p><strong>Literals and Variables:</strong> If the expression is not a pair (a literal or a variable), it’s already a value. The current continuation <code class="language-plaintext highlighter-rouge">ctx</code> is applied to this value: <code class="language-plaintext highlighter-rouge">(ctx x)</code>.</p>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">if</code> Expressions:</strong> This is a key part of the transformer that handles tail calls and avoids context duplication.
        <ul>
          <li>It first transforms the <code class="language-plaintext highlighter-rouge">test</code> expression with a continuation that takes the result of the test (<code class="language-plaintext highlighter-rouge">t</code>).</li>
          <li>If the current context <code class="language-plaintext highlighter-rouge">ctx</code> is a tail context (<code class="language-plaintext highlighter-rouge">ctx0</code>) or the initial identity context (<code class="language-plaintext highlighter-rouge">id</code>), it means the <code class="language-plaintext highlighter-rouge">if</code> expression itself is in a tail position. In this case, the <code class="language-plaintext highlighter-rouge">if</code> structure is preserved, and the <code class="language-plaintext highlighter-rouge">conseq</code> and <code class="language-plaintext highlighter-rouge">alt</code> branches are CPSed with the same context <code class="language-plaintext highlighter-rouge">ctx</code>.</li>
          <li>If the current context is not a tail context, it means the result of the <code class="language-plaintext highlighter-rouge">if</code> expression needs to be used later. A new continuation <code class="language-plaintext highlighter-rouge">k</code> is created that takes the result of the <code class="language-plaintext highlighter-rouge">if</code> and applies the original context <code class="language-plaintext highlighter-rouge">ctx</code> to it. The <code class="language-plaintext highlighter-rouge">conseq</code> and <code class="language-plaintext highlighter-rouge">alt</code> branches are then CPSed with the tail context <code class="language-plaintext highlighter-rouge">ctx0</code>, and the entire <code class="language-plaintext highlighter-rouge">if</code> expression is wrapped in a <code class="language-plaintext highlighter-rouge">let</code> that introduces <code class="language-plaintext highlighter-rouge">k</code>.</li>
        </ul>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">lambda</code> Expressions:</strong> A <code class="language-plaintext highlighter-rouge">lambda</code> expression <code class="language-plaintext highlighter-rouge">(lambda (x) body)</code> is transformed into a new <code class="language-plaintext highlighter-rouge">lambda</code> expression that takes an additional argument <code class="language-plaintext highlighter-rouge">k</code> (the continuation): <code class="language-plaintext highlighter-rouge">(lambda (x k) (cps1 body ctx0))</code>. The body of the original lambda is CPSed with the tail context <code class="language-plaintext highlighter-rouge">ctx0</code>.</p>
      </li>
      <li>
        <p><strong>Binary Operations (<code class="language-plaintext highlighter-rouge">op a b</code>):</strong> The operands <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are CPSed sequentially. The continuation for <code class="language-plaintext highlighter-rouge">a</code> takes its result <code class="language-plaintext highlighter-rouge">v1</code>, and then CPSes <code class="language-plaintext highlighter-rouge">b</code> with a continuation that takes its result <code class="language-plaintext highlighter-rouge">v2</code>. Finally, the original context <code class="language-plaintext highlighter-rouge">ctx</code> is applied to the expression formed by the operator <code class="language-plaintext highlighter-rouge">op</code> and the CPSed results <code class="language-plaintext highlighter-rouge">v1</code> and <code class="language-plaintext highlighter-rouge">v2</code>.</p>
      </li>
      <li><strong>Function Applications (<code class="language-plaintext highlighter-rouge">rator rand</code>):</strong> The <code class="language-plaintext highlighter-rouge">rator</code> (function) and <code class="language-plaintext highlighter-rouge">rand</code> (argument) are CPSed sequentially.
        <ul>
          <li>If the <code class="language-plaintext highlighter-rouge">rator</code> is a <code class="language-plaintext highlighter-rouge">trivial?</code> operator, the current context <code class="language-plaintext highlighter-rouge">ctx</code> is directly applied to the result of applying the operator to the operand.</li>
          <li>If the current context is a tail context (<code class="language-plaintext highlighter-rouge">ctx0</code>), the CPSed function <code class="language-plaintext highlighter-rouge">r</code> is called with the CPSed argument <code class="language-plaintext highlighter-rouge">d</code> and the current continuation <code class="language-plaintext highlighter-rouge">k</code>. This ensures proper tail calls.</li>
          <li>Otherwise (non-tail call), a new continuation is created that takes the result of the function call and applies the original context <code class="language-plaintext highlighter-rouge">ctx</code> to it. The CPSed function <code class="language-plaintext highlighter-rouge">r</code> is called with the CPSed argument <code class="language-plaintext highlighter-rouge">d</code> and this new continuation.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>5. Tests:</strong></p>

<ul>
  <li>The code includes several test cases that demonstrate the transformation of different types of expressions, including variables, lambda functions, <code class="language-plaintext highlighter-rouge">if</code> expressions in various contexts, and function applications.</li>
</ul>

<p><strong>6. Factorial Example:</strong></p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">fact-cps</code> definition shows how the CPS transformer can be applied to a recursive factorial function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">pretty-print</code> output shows the CPSed version of the factorial function, which now takes an extra continuation argument <code class="language-plaintext highlighter-rouge">k</code>.</li>
  <li>The final line evaluates the CPSed factorial function with the input <code class="language-plaintext highlighter-rouge">5</code> and a top-level continuation <code class="language-plaintext highlighter-rouge">(lambda (v) v)</code> that simply returns the final value.</li>
</ul>

<p><strong>In summary, this code implements a CPS transformation that aims to:</strong></p>

<ul>
  <li>Convert expressions into continuation-passing style.</li>
  <li>Ensure proper tail-call optimization by passing the current continuation explicitly.</li>
  <li>Handle <code class="language-plaintext highlighter-rouge">if</code> expressions efficiently without duplicating the surrounding context when the <code class="language-plaintext highlighter-rouge">if</code> itself is in a tail position. This is achieved by keeping the <code class="language-plaintext highlighter-rouge">if</code> structure and CPSing the branches with the same context. When the <code class="language-plaintext highlighter-rouge">if</code> is not in a tail position, it introduces a new continuation to handle the result.</li>
</ul>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
