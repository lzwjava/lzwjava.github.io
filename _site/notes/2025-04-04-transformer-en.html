<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Transformer</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Transformer | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Transformer" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-04-04-transformer-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-04-04-transformer-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Transformer" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Transformer","url":"https://lzwjava.github.io/notes/2025-04-04-transformer-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=b06a4552b6e4e838cc94f0f9fabe3ebd8f430840">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=b06a4552b6e4e838cc94f0f9fabe3ebd8f430840" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Transformer | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-04-04-transformer-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-04-04-transformer-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.10</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/transformer-en" selected>English</option>
        <option value="/transformer-zh" >中文</option>
        <option value="/transformer-ja" >日本語</option>
        <option value="/transformer-es" >Español</option>
        <option value="/transformer-hi" >हिंदी</option>
        <option value="/transformer-fr" >Français</option>
        <option value="/transformer-de" >Deutsch</option>
        <option value="/transformer-ar" >العربية</option>
        <option value="/transformer-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>The <strong>Transformer</strong> is a revolutionary neural network architecture that has become the foundation of most modern Large Language Models (LLMs). It was introduced in the seminal 2017 paper “Attention Is All You Need” by Vaswani et al. and has since fundamentally changed the field of Natural Language Processing (NLP).</p>

<p>Unlike previous dominant architectures like Recurrent Neural Networks (RNNs), which process sequential data step-by-step, the Transformer processes entire input sequences <strong>in parallel</strong>. This key difference allows for significant improvements in training speed and the ability to capture long-range dependencies within the text.</p>

<p>Here’s a deep dive into the key components and concepts of the Transformer architecture in the context of LLMs:</p>

<p><strong>1. Core Idea: Attention Mechanism</strong></p>

<p>The central innovation of the Transformer is the <strong>attention mechanism</strong>, particularly <strong>self-attention</strong>. This mechanism allows the model to weigh the importance of different words (or tokens) in the input sequence when processing a specific word. Instead of just relying on the immediately preceding words (like RNNs), self-attention enables the model to consider the entire context to understand the meaning and relationships between words.</p>

<p>Think of it like this: when you read a sentence, you don’t process each word in isolation. Your brain simultaneously considers all the words to understand the overall meaning and how each word contributes to it. The self-attention mechanism mimics this behavior.</p>

<p><strong>How Self-Attention Works (Simplified):</strong></p>

<p>For each word in the input sequence, the Transformer calculates three vectors:</p>

<ul>
  <li><strong>Query (Q):</strong> Represents what the current word is “looking for” in the other words.</li>
  <li><strong>Key (K):</strong> Represents what information each other word “contains”.</li>
  <li><strong>Value (V):</strong> Represents the actual information each other word holds that might be relevant.</li>
</ul>

<p>The self-attention mechanism then performs the following steps:</p>

<ol>
  <li><strong>Calculate Attention Scores:</strong> The dot product between the Query vector of a word and the Key vector of every other word in the sequence is computed. These scores indicate how much each other word’s information is relevant to the current word.</li>
  <li><strong>Scale the Scores:</strong> The scores are divided by the square root of the dimension of the Key vectors (<code class="language-plaintext highlighter-rouge">sqrt(d_k)</code>). This scaling helps to stabilize gradients during training.</li>
  <li><strong>Apply Softmax:</strong> The scaled scores are passed through a softmax function, which normalizes them into probabilities between 0 and 1. These probabilities represent the <strong>attention weights</strong> – how much “attention” the current word should pay to each of the other words.</li>
  <li><strong>Calculate Weighted Values:</strong> The Value vector of each word is multiplied by its corresponding attention weight.</li>
  <li><strong>Sum the Weighted Values:</strong> The weighted Value vectors are summed up to produce the <strong>output vector</strong> for the current word. This output vector now contains information from all other relevant words in the input sequence, weighted by their importance.</li>
</ol>

<p><strong>2. Multi-Head Attention</strong></p>

<p>To further enhance the model’s ability to capture different types of relationships, the Transformer employs <strong>multi-head attention</strong>. Instead of performing the self-attention mechanism only once, it does it multiple times in parallel with different sets of Query, Key, and Value weight matrices. Each “head” learns to focus on different aspects of the relationships between the words (e.g., grammatical dependencies, semantic connections). The outputs of all the attention heads are then concatenated and linearly transformed to produce the final output of the multi-head attention layer.</p>

<p><strong>3. Positional Encoding</strong></p>

<p>Since the Transformer processes all words in parallel, it loses information about the <strong>order</strong> of the words in the sequence. To address this, a <strong>positional encoding</strong> is added to the input embeddings. These encodings are vectors that represent the position of each word in the sequence. They are typically fixed patterns (e.g., sinusoidal functions) or learned embeddings. By adding positional encodings, the Transformer can understand the sequential nature of language.</p>

<p><strong>4. Encoder and Decoder Stacks</strong></p>

<p>The Transformer architecture typically consists of two main parts: an <strong>encoder</strong> and a <strong>decoder</strong>, both composed of multiple identical layers stacked on top of each other.</p>

<ul>
  <li><strong>Encoder:</strong> The encoder’s role is to process the input sequence and create a rich representation of it. Each encoder layer typically contains:
    <ul>
      <li>A <strong>multi-head self-attention</strong> sub-layer.</li>
      <li>A <strong>feed-forward neural network</strong> sub-layer.</li>
      <li><strong>Residual connections</strong> around each sub-layer, followed by <strong>layer normalization</strong>. Residual connections help with gradient flow during training, and layer normalization stabilizes the activations.</li>
    </ul>
  </li>
  <li><strong>Decoder:</strong> The decoder’s role is to generate the output sequence (e.g., in machine translation or text generation). Each decoder layer typically contains:
    <ul>
      <li>A <strong>masked multi-head self-attention</strong> sub-layer. The “masking” prevents the decoder from looking ahead at future tokens in the target sequence during training, ensuring that it only uses previously generated tokens to predict the next one.</li>
      <li>A <strong>multi-head attention</strong> sub-layer that attends to the output of the encoder. This allows the decoder to focus on the relevant parts of the input sequence while generating the output.</li>
      <li>A <strong>feed-forward neural network</strong> sub-layer.</li>
      <li><strong>Residual connections</strong> and <strong>layer normalization</strong> similar to the encoder.</li>
    </ul>
  </li>
</ul>

<p><strong>5. Feed-Forward Networks</strong></p>

<p>Each encoder and decoder layer contains a feed-forward neural network (FFN). This network is applied to each token independently and helps to further process the representations learned by the attention mechanisms. It typically consists of two linear transformations with a non-linear activation function (e.g., ReLU) in between.</p>

<p><strong>How Transformers are Used in LLMs:</strong></p>

<p>LLMs are primarily based on the <strong>decoder-only</strong> Transformer architecture (like GPT models) or the <strong>encoder-decoder</strong> architecture (like T5).</p>

<ul>
  <li>
    <p><strong>Decoder-only models:</strong> These models are trained to predict the next token in a sequence given the preceding tokens. They stack multiple decoder layers. The input prompt is passed through the layers, and the final layer predicts the probability distribution over the vocabulary for the next token. By autoregressively sampling from this distribution, the model can generate coherent and contextually relevant text.</p>
  </li>
  <li>
    <p><strong>Encoder-decoder models:</strong> These models take an input sequence and generate an output sequence. They use the full encoder-decoder architecture. The encoder processes the input, and the decoder uses the encoder’s output to generate the target sequence. These are well-suited for tasks like translation, summarization, and question answering.</p>
  </li>
</ul>

<p><strong>Deeply Understanding the Significance:</strong></p>

<p>The Transformer architecture’s impact on LLMs is profound:</p>

<ul>
  <li><strong>Handling Long-Range Dependencies:</strong> The self-attention mechanism allows the model to directly connect words that are far apart in the sequence, overcoming the limitations of RNNs in capturing long-range context.</li>
  <li><strong>Parallel Processing:</strong> Processing the entire sequence in parallel significantly reduces training time and allows for the use of much larger datasets and models.</li>
  <li><strong>Scalability:</strong> The Transformer architecture scales well with increasing data and model size, leading to the development of extremely powerful LLMs with billions or even trillions of parameters.</li>
  <li><strong>Contextual Understanding:</strong> The attention mechanism enables the model to understand the context of words in a more nuanced way, leading to better language understanding and generation.</li>
  <li><strong>Foundation for Innovation:</strong> The Transformer architecture has served as a foundation for numerous advancements and variations, leading to the diverse landscape of modern LLMs.</li>
</ul>

<p>In summary, the Transformer architecture, with its core self-attention mechanism, parallel processing capabilities, and encoder-decoder structure (or decoder-only variations), has revolutionized the field of NLP and is the driving force behind the remarkable capabilities of modern Large Language Models.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
