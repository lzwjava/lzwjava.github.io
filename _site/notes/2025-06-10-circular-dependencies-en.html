<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Circular Dependencies in Spring</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Circular Dependencies in Spring | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Circular Dependencies in Spring" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="李智维" />
<meta property="og:description" content="李智维" />
<link rel="canonical" href="https://lzwjava.github.io/notes/2025-06-10-circular-dependencies-en" />
<meta property="og:url" content="https://lzwjava.github.io/notes/2025-06-10-circular-dependencies-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Circular Dependencies in Spring" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Zhiwei Li"},"description":"李智维","headline":"Circular Dependencies in Spring","url":"https://lzwjava.github.io/notes/2025-06-10-circular-dependencies-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=5dc6bde1e9a37ea9c508461e5a5cdae981a42eb8">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=5dc6bde1e9a37ea9c508461e5a5cdae981a42eb8" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Circular Dependencies in Spring | Generated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="notes/2025-06-10-circular-dependencies-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>notes2025-06-10-circular-dependencies-en.md</span> -->
      

      <!-- <span></span> -->

      
        <a href="#" class="button">2025.09</a>
      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/circular-dependencies-en" selected>English</option>
        <option value="/circular-dependencies-zh" >中文</option>
        <option value="/circular-dependencies-ja" >日本語</option>
        <option value="/circular-dependencies-es" >Español</option>
        <option value="/circular-dependencies-hi" >हिंदी</option>
        <option value="/circular-dependencies-fr" >Français</option>
        <option value="/circular-dependencies-de" >Deutsch</option>
        <option value="/circular-dependencies-ar" >العربية</option>
        <option value="/circular-dependencies-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Circular dependencies in Spring or Spring Boot occur when two or more beans depend on each other, either directly or indirectly, during initialization. This creates a cycle where Spring’s dependency injection mechanism cannot resolve the dependencies because each bean requires the other to be fully initialized first. This issue typically arises during bean creation in the Spring Application Context, leading to a <code class="language-plaintext highlighter-rouge">BeanCurrentlyInCreationException</code>.</p>

<h3 id="why-circular-dependencies-happen">Why Circular Dependencies Happen</h3>
<p>Spring manages beans in a dependency injection container, and beans are typically created in a specific order based on their dependencies. When beans reference each other in a cyclic manner (e.g., Bean A depends on Bean B, and Bean B depends on Bean A), Spring cannot instantiate them because it gets stuck in an infinite loop during initialization. This is especially common in complex applications with tightly coupled components.</p>

<p>The problem is more likely to occur in the following scenarios:</p>
<ol>
  <li><strong>Constructor Injection</strong>: When beans are wired via constructors, Spring must resolve dependencies at instantiation time, which can lead to circularity issues if beans reference each other.</li>
  <li><strong>Field or Setter Injection with Eager Initialization</strong>: If beans are eagerly initialized (default behavior for singleton beans), Spring tries to resolve dependencies immediately, exposing circular dependencies.</li>
  <li><strong>Misconfigured or Overly Complex Bean Relationships</strong>: Poor design or lack of separation of concerns can lead to unintended cycles.</li>
  <li><strong>Annotations like <code class="language-plaintext highlighter-rouge">@Autowired</code> or <code class="language-plaintext highlighter-rouge">@Component</code></strong>: Automatic dependency injection in tightly coupled components can inadvertently create cycles.</li>
</ol>

<h3 id="common-examples-of-circular-dependencies">Common Examples of Circular Dependencies</h3>

<h4 id="example-1-constructor-injection-cycle">Example 1: Constructor Injection Cycle</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanA</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">BeanB</span> <span class="n">beanB</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="nf">BeanA</span><span class="o">(</span><span class="nc">BeanB</span> <span class="n">beanB</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">beanB</span> <span class="o">=</span> <span class="n">beanB</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanB</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">BeanA</span> <span class="n">beanA</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="nf">BeanB</span><span class="o">(</span><span class="nc">BeanA</span> <span class="n">beanA</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">beanA</span> <span class="o">=</span> <span class="n">beanA</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>Problem</strong>: <code class="language-plaintext highlighter-rouge">BeanA</code> requires <code class="language-plaintext highlighter-rouge">BeanB</code> in its constructor, and <code class="language-plaintext highlighter-rouge">BeanB</code> requires <code class="language-plaintext highlighter-rouge">BeanA</code> in its constructor. Spring cannot create either bean because each depends on the other being fully initialized first.</p>

<p><strong>Error</strong>: <code class="language-plaintext highlighter-rouge">BeanCurrentlyInCreationException: Error creating bean with name 'beanA': Requested bean is currently in creation: Is there an unresolvable circular reference?</code></p>

<h4 id="example-2-field-injection-cycle">Example 2: Field Injection Cycle</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanA</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">BeanB</span> <span class="n">beanB</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanB</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">BeanA</span> <span class="n">beanA</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>Problem</strong>: Both <code class="language-plaintext highlighter-rouge">BeanA</code> and <code class="language-plaintext highlighter-rouge">BeanB</code> use <code class="language-plaintext highlighter-rouge">@Autowired</code> to inject each other via fields. Even though field injection is more flexible than constructor injection, Spring still detects the cycle during bean initialization if both are singleton beans (default scope).</p>

<h4 id="example-3-indirect-circular-dependency">Example 3: Indirect Circular Dependency</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanA</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">BeanB</span> <span class="n">beanB</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanB</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">BeanC</span> <span class="n">beanC</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanC</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">BeanA</span> <span class="n">beanA</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>Problem</strong>: <code class="language-plaintext highlighter-rouge">BeanA</code> depends on <code class="language-plaintext highlighter-rouge">BeanB</code>, <code class="language-plaintext highlighter-rouge">BeanB</code> depends on <code class="language-plaintext highlighter-rouge">BeanC</code>, and <code class="language-plaintext highlighter-rouge">BeanC</code> depends on <code class="language-plaintext highlighter-rouge">BeanA</code>, forming a cycle. This indirect dependency is harder to spot but still causes the same issue.</p>

<h4 id="example-4-configuration-classes-with-circular-references">Example 4: <code class="language-plaintext highlighter-rouge">@Configuration</code> Classes with Circular References</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConfigA</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ConfigB</span> <span class="n">configB</span><span class="o">;</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ServiceA</span> <span class="nf">serviceA</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ServiceA</span><span class="o">(</span><span class="n">configB</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConfigB</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ConfigA</span> <span class="n">configA</span><span class="o">;</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ServiceB</span> <span class="nf">serviceB</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ServiceB</span><span class="o">(</span><span class="n">configA</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>Problem</strong>: The <code class="language-plaintext highlighter-rouge">@Configuration</code> classes <code class="language-plaintext highlighter-rouge">ConfigA</code> and <code class="language-plaintext highlighter-rouge">ConfigB</code> depend on each other, creating a cycle when Spring tries to initialize the beans defined in these classes.</p>

<h3 id="common-causes-in-spring-boot">Common Causes in Spring Boot</h3>
<ul>
  <li><strong>Auto-Configuration</strong>: Spring Boot’s auto-configuration can sometimes introduce dependencies that lead to cycles, especially when custom beans interact with auto-configured ones.</li>
  <li><strong>Component Scanning</strong>: Overuse of <code class="language-plaintext highlighter-rouge">@ComponentScan</code> or misconfigured packages can pick up unintended beans, leading to cyclic dependencies.</li>
  <li><strong>Tightly Coupled Design</strong>: Business logic that tightly couples services, repositories, or controllers can inadvertently create cycles.</li>
  <li><strong>Prototype Scope Misuse</strong>: While prototype-scoped beans can sometimes avoid circular dependencies, combining them with singleton beans in a cyclic manner can still cause issues.</li>
</ul>

<h3 id="how-to-resolve-circular-dependencies">How to Resolve Circular Dependencies</h3>
<ol>
  <li><strong>Use <code class="language-plaintext highlighter-rouge">@Lazy</code> Annotation</strong>:
    <ul>
      <li>Annotate one of the dependencies with <code class="language-plaintext highlighter-rouge">@Lazy</code> to delay its initialization until it’s actually needed.
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanA</span> <span class="o">{</span>
  <span class="nd">@Autowired</span>
  <span class="nd">@Lazy</span>
  <span class="kd">private</span> <span class="nc">BeanB</span> <span class="n">beanB</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>        </div>
        <p>This breaks the cycle by allowing <code class="language-plaintext highlighter-rouge">BeanA</code> to be partially initialized before <code class="language-plaintext highlighter-rouge">BeanB</code> is resolved.</p>
      </li>
    </ul>
  </li>
  <li><strong>Switch to Setter or Field Injection</strong>:
    <ul>
      <li>Instead of constructor injection, use setter or field injection for one of the beans to allow Spring to initialize the bean first and inject dependencies later.
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanA</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">BeanB</span> <span class="n">beanB</span><span class="o">;</span>

  <span class="nd">@Autowired</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setBeanB</span><span class="o">(</span><span class="nc">BeanB</span> <span class="n">beanB</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">beanB</span> <span class="o">=</span> <span class="n">beanB</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>Refactor Code to Break the Cycle</strong>:
    <ul>
      <li>Introduce an interface or intermediate component to decouple the beans.</li>
      <li>Example: Extract a common dependency into a third bean or use a service layer to mediate interactions.
```java
public interface Service {
  void performAction();
}</li>
    </ul>

    <p>@Component
public class BeanA implements Service {
    @Autowired
    private BeanB beanB;</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void performAction() {
    // Logic
} }
</code></pre></div>    </div>

    <p>@Component
public class BeanB {
    @Autowired
    private Service service; // Depends on interface, not BeanA directly
}
```</p>
  </li>
  <li><strong>Use <code class="language-plaintext highlighter-rouge">@DependsOn</code> Annotation</strong>:
    <ul>
      <li>Explicitly control the order of bean initialization to avoid cycles in specific cases.
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@DependsOn</span><span class="o">(</span><span class="s">"beanB"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanA</span> <span class="o">{</span>
  <span class="nd">@Autowired</span>
  <span class="kd">private</span> <span class="nc">BeanB</span> <span class="n">beanB</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>Enable Proxying with <code class="language-plaintext highlighter-rouge">@EnableAspectJAutoProxy</code></strong>:
    <ul>
      <li>Ensure Spring uses proxies (CGLIB or JDK dynamic proxies) to handle dependencies, which can resolve some circularity issues by injecting a proxy instead of the actual bean.</li>
    </ul>
  </li>
  <li><strong>Reevaluate Design</strong>:
    <ul>
      <li>Circular dependencies often indicate a design flaw. Consider refactoring to adhere to the Single Responsibility Principle or Dependency Inversion Principle.</li>
    </ul>
  </li>
</ol>

<h3 id="how-to-debug-circular-dependencies">How to Debug Circular Dependencies</h3>
<ul>
  <li><strong>Check Stack Trace</strong>: The <code class="language-plaintext highlighter-rouge">BeanCurrentlyInCreationException</code> stack trace will indicate the beans involved in the cycle.</li>
  <li><strong>Enable Debug Logging</strong>: Set <code class="language-plaintext highlighter-rouge">spring.main.lazy-initialization=true</code> or enable debug logging for <code class="language-plaintext highlighter-rouge">org.springframework</code> to see bean creation details.</li>
  <li><strong>Use Tools</strong>: Tools like Spring Boot Actuator or IDE plugins (e.g., Spring Tools Suite) can visualize bean dependencies.</li>
</ul>

<h3 id="preventing-circular-dependencies">Preventing Circular Dependencies</h3>
<ul>
  <li><strong>Follow Best Practices</strong>: Use dependency injection patterns like interfaces or abstractions to reduce tight coupling.</li>
  <li><strong>Modularize Code</strong>: Break down large applications into smaller, loosely coupled modules.</li>
  <li><strong>Test Early</strong>: Run integration tests to catch circular dependencies during development.</li>
  <li><strong>Limit Component Scanning</strong>: Be specific with <code class="language-plaintext highlighter-rouge">@ComponentScan</code> to avoid picking up unnecessary beans.</li>
</ul>

<h3 id="when-circular-dependencies-are-less-likely">When Circular Dependencies Are Less Likely</h3>
<ul>
  <li><strong>Prototype Scope</strong>: Beans with prototype scope are created on demand, reducing the likelihood of circularity (but not eliminating it entirely).</li>
  <li><strong>Lazy Initialization</strong>: Enabling global lazy initialization (<code class="language-plaintext highlighter-rouge">spring.main.lazy-initialization=true</code>) can defer bean creation, though it may only mask the issue.</li>
</ul>

<h3 id="conclusion">Conclusion</h3>
<p>Circular dependencies in Spring/Spring Boot arise from tight coupling between beans, often exacerbated by constructor injection or complex configurations. Common solutions include using <code class="language-plaintext highlighter-rouge">@Lazy</code>, switching to setter/field injection, or refactoring to break the cycle. By understanding the root cause and applying best practices, you can prevent or resolve these issues effectively. If you encounter a specific circular dependency, share the relevant code or error details, and I can help analyze it further!</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
