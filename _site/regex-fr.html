<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Expressions régulières complexes</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Expressions régulières complexes | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Expressions régulières complexes" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="fr" />
<meta name="description" content="Récemment, en étudiant l’analyse HTML, je suis tombé sur une expression régulière :" />
<meta property="og:description" content="Récemment, en étudiant l’analyse HTML, je suis tombé sur une expression régulière :" />
<link rel="canonical" href="https://lzwjava.github.io/regex-fr" />
<meta property="og:url" content="https://lzwjava.github.io/regex-fr" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-25T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Expressions régulières complexes" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-25T00:00:00+08:00","datePublished":"2016-05-25T00:00:00+08:00","description":"Récemment, en étudiant l’analyse HTML, je suis tombé sur une expression régulière :","headline":"Expressions régulières complexes","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/regex-fr"},"url":"https://lzwjava.github.io/regex-fr"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=944c9c94e3348c16f42e030e4e790dc26029288e">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=944c9c94e3348c16f42e030e4e790dc26029288e" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Expressions régulières complexes | Original, traduit par l'IA
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/fr/2016-05-25-regex-fr.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsfr2016-05-25-regex-fr.md</span> -->
      

      <!-- <span>2016-05-25-regex-fr.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/regex-en" >English</option>
        <option value="/regex-zh" >中文</option>
        <option value="/regex-ja" >日本語</option>
        <option value="/regex-es" >Español</option>
        <option value="/regex-hi" >हिंदी</option>
        <option value="/regex-fr" selected>Français</option>
        <option value="/regex-de" >Deutsch</option>
        <option value="/regex-ar" >العربية</option>
        <option value="/regex-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Récemment, en étudiant l’analyse HTML, je suis tombé sur une expression régulière :</p>

<p><code class="language-plaintext highlighter-rouge">/([\w-:\*&gt;]*)(?:\#([\w-]+)|\.([\w-]+))?(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?([\/, ]+)/is</code></p>

<p>Ce code est une expression régulière (regex) utilisée pour analyser des chaînes de caractères. Voici une explication en français de ce qu’elle fait :</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> : Capture une séquence de caractères alphanumériques (<code class="language-plaintext highlighter-rouge">\w</code>), tirets (<code class="language-plaintext highlighter-rouge">-</code>), deux-points (<code class="language-plaintext highlighter-rouge">:</code>), astérisques (<code class="language-plaintext highlighter-rouge">*</code>), ou chevrons (<code class="language-plaintext highlighter-rouge">&gt;</code>). Cette séquence peut être vide.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code> : Capture optionnellement soit un identifiant (commençant par <code class="language-plaintext highlighter-rouge">#</code>) soit une classe (commençant par <code class="language-plaintext highlighter-rouge">.</code>). Les caractères capturés peuvent être alphanumériques ou des tirets.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?</code> : Capture optionnellement un attribut entre crochets. L’attribut peut commencer par un <code class="language-plaintext highlighter-rouge">@</code> ou un <code class="language-plaintext highlighter-rouge">!</code>, suivi de caractères alphanumériques, tirets ou deux-points. Il peut également contenir un opérateur de comparaison (<code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">*=</code>, <code class="language-plaintext highlighter-rouge">^=</code>, <code class="language-plaintext highlighter-rouge">$=</code>) et une valeur entre guillemets simples ou doubles.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">([\/, ]+)</code> : Capture une séquence de caractères composée de barres obliques (<code class="language-plaintext highlighter-rouge">/</code>), virgules (<code class="language-plaintext highlighter-rouge">,</code>), ou espaces (<code class="language-plaintext highlighter-rouge"> </code>). Cette séquence doit contenir au moins un caractère.</p>
  </li>
  <li>
    <p>Le modificateur <code class="language-plaintext highlighter-rouge">is</code> à la fin signifie que l’expression régulière est insensible à la casse (<code class="language-plaintext highlighter-rouge">i</code>) et que le point (<code class="language-plaintext highlighter-rouge">.</code>) correspond également aux sauts de ligne (<code class="language-plaintext highlighter-rouge">s</code>).</p>
  </li>
</ol>

<p>Cette expression régulière est souvent utilisée pour analyser des sélecteurs CSS ou des fragments de code HTML.</p>

<p>Il est utilisé pour correspondre à des sélecteurs CSS, comme par exemple <code class="language-plaintext highlighter-rouge">div &gt; ul</code>.</p>

<p>J’ai souvent rencontré des expressions aussi complexes dans le passé, et j’ai toujours instinctivement reculé. Aujourd’hui, je vais enfin les comprendre à fond ! Un homme doit savoir se montrer dur envers lui-même !</p>

<h3 id="correspondance-de-div--ul">Correspondance de <code class="language-plaintext highlighter-rouge">div &gt; ul</code></h3>

<p>La sélection <code class="language-plaintext highlighter-rouge">div &gt; ul</code> en CSS ou dans un sélecteur jQuery cible tous les éléments <code class="language-plaintext highlighter-rouge">&lt;ul&gt;</code> qui sont des enfants directs d’un élément <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>. Cela signifie que seuls les éléments <code class="language-plaintext highlighter-rouge">&lt;ul&gt;</code> qui sont immédiatement imbriqués dans un <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> seront sélectionnés, et non ceux qui sont imbriqués plus profondément dans d’autres éléments.</p>

<h4 id="exemple-en-html-">Exemple en HTML :</h4>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div&gt;</span>
  <span class="nt">&lt;ul&gt;</span> <span class="c">&lt;!-- Ce ul sera sélectionné --&gt;</span>
    <span class="nt">&lt;li&gt;</span>Item 1<span class="nt">&lt;/li&gt;</span>
    <span class="nt">&lt;li&gt;</span>Item 2<span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>
  <span class="nt">&lt;div&gt;</span>
    <span class="nt">&lt;ul&gt;</span> <span class="c">&lt;!-- Ce ul ne sera PAS sélectionné --&gt;</span>
      <span class="nt">&lt;li&gt;</span>Item 3<span class="nt">&lt;/li&gt;</span>
      <span class="nt">&lt;li&gt;</span>Item 4<span class="nt">&lt;/li&gt;</span>
    <span class="nt">&lt;/ul&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<h4 id="exemple-en-css-">Exemple en CSS :</h4>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span> <span class="o">&gt;</span> <span class="nt">ul</span> <span class="p">{</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="no">yellow</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="exemple-en-jquery-">Exemple en jQuery :</h4>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">div &gt; ul</span><span class="dl">'</span><span class="p">).</span><span class="nx">css</span><span class="p">(</span><span class="dl">'</span><span class="s1">background-color</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">yellow</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>Dans cet exemple, seul le premier <code class="language-plaintext highlighter-rouge">&lt;ul&gt;</code> sera mis en surbrillance en jaune, car il est un enfant direct du <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>. Le deuxième <code class="language-plaintext highlighter-rouge">&lt;ul&gt;</code> ne sera pas affecté car il est imbriqué dans un autre <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>.</p>

<p>J’ai trouvé un site web, https://regex101.com/, qui permet de faire des correspondances en ligne et fournit également des explications.</p>

<p>Bien que les explications à droite aient clarifié certaines choses, il reste encore des incertitudes sur la manière exacte dont les correspondances fonctionnent. Alors, prenons quelques exemples et analysons-les un par un.</p>

<p>Le code spécifique où cette expression régulière apparaît est :</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$matches</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nb">preg_match_all</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">trim</span><span class="p">(</span><span class="nv">$selector</span><span class="p">)</span><span class="mf">.</span><span class="s1">' '</span><span class="p">,</span> <span class="nv">$matches</span><span class="p">,</span> <span class="no">PREG_SET_ORDER</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">preg_match_all</code> signifie récupérer toutes les chaînes qui correspondent au motif. Par exemple, si vous avez :</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">preg_match_all</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">,</span> <span class="s2">"abcdabc"</span><span class="p">,</span> <span class="nv">$matches</span><span class="p">)</span>
</code></pre></div></div>

<p><em>Note : Le code reste en anglais car il s’agit d’une syntaxe PHP spécifique qui ne doit pas être traduite.</em></p>

<p>Le premier paramètre est le motif, le deuxième paramètre est la chaîne à comparer, et le troisième paramètre est la référence du résultat. Après l’exécution, le tableau <code class="language-plaintext highlighter-rouge">$matches</code> contiendra deux occurrences de <code class="language-plaintext highlighter-rouge">abc</code>.</p>

<p>Avec cette compréhension, dans l’image ci-dessus, <code class="language-plaintext highlighter-rouge">div &gt; ul</code> ne correspond qu’aux quatre premiers caractères <code class="language-plaintext highlighter-rouge">div &gt;</code>. <code class="language-plaintext highlighter-rouge">regex101</code> ne supporte pas <code class="language-plaintext highlighter-rouge">preg_match_all</code> ? Heureusement, il suffit d’ajouter un modificateur appelé <code class="language-plaintext highlighter-rouge">g</code> :</p>

<p>En ajoutant <code class="language-plaintext highlighter-rouge">g</code>, cela correspondra à tous les éléments, plutôt que de retourner uniquement le premier trouvé.</p>

<p>Après l’avoir ajouté, nous avons trouvé une correspondance pour <code class="language-plaintext highlighter-rouge">div &gt; ul</code> :</p>

<p>À droite, on voit que dans le premier match, c’est-à-dire <code class="language-plaintext highlighter-rouge">div</code>, nous avons utilisé les règles du premier groupe pour matcher <code class="language-plaintext highlighter-rouge">div</code>, puis les règles du septième groupe pour matcher l’espace ` `.</p>

<p>Passons maintenant à l’explication du premier ensemble de règles :</p>

<p>Dans cette longue expression, la première partie entre parenthèses est appelée le premier groupe de règles. Il s’agit d’un groupe de capture. Les parenthèses elles-mêmes ne correspondent à rien, mais servent à regrouper des éléments. <code class="language-plaintext highlighter-rouge">[]</code> représente un ensemble de caractères, et les règles à l’intérieur définissent la nature de cet ensemble de caractères. Cet ensemble de caractères contient :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\w</code> représente les lettres majuscules et minuscules, les chiffres de 0 à 9 ainsi que le tiret bas.</li>
  <li><code class="language-plaintext highlighter-rouge">-:</code> représente directement ces deux caractères dans l’ensemble.</li>
  <li><code class="language-plaintext highlighter-rouge">\*</code> : comme <code class="language-plaintext highlighter-rouge">*</code> est un caractère réservé dans les expressions régulières avec une signification spéciale, il faut utiliser <code class="language-plaintext highlighter-rouge">\</code> pour l’échapper, indiquant qu’il s’agit d’un caractère <code class="language-plaintext highlighter-rouge">*</code> ordinaire.</li>
  <li><code class="language-plaintext highlighter-rouge">&gt;</code> représente simplement le caractère <code class="language-plaintext highlighter-rouge">&gt;</code>.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">[\w-:\*&gt;]*</code> Le dernier <code class="language-plaintext highlighter-rouge">*</code> signifie que le caractère précédent peut apparaître 0 fois ou un nombre illimité de fois, mais il essaiera de correspondre autant de fois que possible. La raison pour laquelle il correspond à <code class="language-plaintext highlighter-rouge">div</code> est que <code class="language-plaintext highlighter-rouge">\w</code> correspond à <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">v</code>. La raison pour laquelle il ne continue pas à correspondre à l’espace qui suit est que l’espace n’est pas présent dans <code class="language-plaintext highlighter-rouge">[]</code>. Un groupe de capture signifie que cette correspondance apparaîtra dans le tableau des résultats. En revanche, il existe également des groupes non capturants, dont la syntaxe est <code class="language-plaintext highlighter-rouge">(?:)</code>. Si vous n’avez pas besoin du résultat du groupe dans <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code>, vous pouvez l’écrire comme <code class="language-plaintext highlighter-rouge">(?:[\w-:\*&gt;]*)</code>.</p>

<p>Alors, si cela n’apparaît pas dans le résultat, ne pas utiliser de parenthèses ne suffirait-il pas ? Les parenthèses servent à regrouper, et le regroupement a tout son sens. Vous pouvez vous référer à <a href="http://stackoverflow.com/questions/3512471/what-is-a-non-capturing-group">《What is a non capturing group? (?:) - StackOverflow》</a>.</p>

<p>Après avoir expliqué pourquoi <code class="language-plaintext highlighter-rouge">div</code> satisfait la première série de règles, parlons maintenant de pourquoi l’espace ` ` satisfait les règles du septième groupe.</p>

<p><code class="language-plaintext highlighter-rouge">[\/, ]</code> signifie qu’il correspond à l’un de ces quatre caractères, et <code class="language-plaintext highlighter-rouge">+</code> indique que la correspondance précédente apparaît une ou plusieurs fois, autant que possible. Par conséquent, puisque ces quatre caractères incluent un espace, il correspond à notre espace. De plus, comme le caractère suivant après <code class="language-plaintext highlighter-rouge">div </code> est <code class="language-plaintext highlighter-rouge">&gt;</code>, il ne satisfait plus la règle du septième groupe et ne continue pas à correspondre.</p>

<p>J’ai compris la correspondance du <code class="language-plaintext highlighter-rouge">div</code>. Mais pourquoi les règles des groupes deux à six n’ont pas capturé les espaces ici, les laissant plutôt au septième groupe ?</p>

<p>Explication de la deuxième partie :</p>

<p>D’abord, <code class="language-plaintext highlighter-rouge">(?:)</code> indique qu’il s’agit d’un groupe non capturant. Le <code class="language-plaintext highlighter-rouge">?</code> à la fin signifie que la correspondance précédente peut apparaître 0 ou 1 fois. Donc, dans l’expression <code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code>, cette partie peut être présente ou non. Si on enlève les modificateurs externes, il reste <code class="language-plaintext highlighter-rouge">\#([\w-]+)|\.([\w-]+)</code>, où le <code class="language-plaintext highlighter-rouge">|</code> au milieu signifie “ou”, c’est-à-dire que l’une ou l’autre des deux parties peut être satisfaite. Dans <code class="language-plaintext highlighter-rouge">\#([\w-]+)</code>, le <code class="language-plaintext highlighter-rouge">\#</code> correspond au caractère <code class="language-plaintext highlighter-rouge">#</code>, et <code class="language-plaintext highlighter-rouge">[\w-]+</code> correspond à d’autres caractères. Ensuite, dans la seconde partie, <code class="language-plaintext highlighter-rouge">\.([\w-]+)</code>, le <code class="language-plaintext highlighter-rouge">\.</code> correspond au caractère <code class="language-plaintext highlighter-rouge">.</code>.</p>

<p>Ainsi, les groupes 2 à 6 peuvent ne pas être satisfaits car l’espace n’est pas un caractère de début requis pour ces groupes. De plus, comme ces groupes ont un modificateur <code class="language-plaintext highlighter-rouge">?</code>, il est acceptable qu’ils ne soient pas satisfaits, ce qui permet de passer directement au septième groupe.</p>

<p>Ensuite, le <code class="language-plaintext highlighter-rouge">&gt;</code> qui suit <code class="language-plaintext highlighter-rouge">div &gt; ul</code> reste le même :</p>

<p>Le premier ensemble de règles <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> correspond à <code class="language-plaintext highlighter-rouge">&gt;</code>, et le septième ensemble de règles <code class="language-plaintext highlighter-rouge">([\/, ]+)</code> correspond à un espace. Ensuite, <code class="language-plaintext highlighter-rouge">ul</code> fonctionne comme <code class="language-plaintext highlighter-rouge">div</code>.</p>

<h3 id="correspondance-de-answer-4185009--table--tbody--tdanswercell--div--pre">Correspondance de <code class="language-plaintext highlighter-rouge">#answer-4185009 &gt; table &gt; tbody &gt; td.answercell &gt; div &gt; pre</code></h3>

<p>Ce sélecteur CSS est utilisé pour cibler un élément spécifique dans une structure HTML. Voici une explication détaillée de chaque partie du sélecteur :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">#answer-4185009</code> : Cible un élément avec l’ID <code class="language-plaintext highlighter-rouge">answer-4185009</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; table</code> : Sélectionne un élément <code class="language-plaintext highlighter-rouge">table</code> qui est un enfant direct de l’élément précédent.</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; tbody</code> : Sélectionne un élément <code class="language-plaintext highlighter-rouge">tbody</code> qui est un enfant direct de l’élément <code class="language-plaintext highlighter-rouge">table</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; td.answercell</code> : Sélectionne un élément <code class="language-plaintext highlighter-rouge">td</code> avec la classe <code class="language-plaintext highlighter-rouge">answercell</code> qui est un enfant direct de l’élément <code class="language-plaintext highlighter-rouge">tbody</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; div</code> : Sélectionne un élément <code class="language-plaintext highlighter-rouge">div</code> qui est un enfant direct de l’élément <code class="language-plaintext highlighter-rouge">td</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; pre</code> : Sélectionne un élément <code class="language-plaintext highlighter-rouge">pre</code> qui est un enfant direct de l’élément <code class="language-plaintext highlighter-rouge">div</code>.</li>
</ul>

<p>En résumé, ce sélecteur cible un élément <code class="language-plaintext highlighter-rouge">pre</code> qui se trouve à l’intérieur d’une structure spécifique de table dans un élément avec l’ID <code class="language-plaintext highlighter-rouge">answer-4185009</code>.</p>

<p>Ensuite, voici un sélecteur un peu plus complexe : <code class="language-plaintext highlighter-rouge">#answer-4185009 &gt; table &gt; tbody &gt; td.answercell &gt; div &gt; pre</code> (vous pouvez également ouvrir https://regex101.com/ et coller cela là-bas pour tester) :</p>

<p>Voici ce qui a été copié-collé depuis Chrome :</p>

<p>Première correspondance :</p>

<p>Parce que dans la règle du premier groupe <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code>, aucun des caractères dans <code class="language-plaintext highlighter-rouge">[]</code> ne peut correspondre à <code class="language-plaintext highlighter-rouge">#</code>, et ensuite, parce que le <code class="language-plaintext highlighter-rouge">*</code> à la fin permet de correspondre 0 fois ou un nombre illimité de fois, ici c’est 0 fois. Ensuite, la description de la règle du deuxième groupe est :</p>

<p>Comme nous l’avons déjà analysé, examinons directement la partie <code class="language-plaintext highlighter-rouge">\#([\w-]+)</code> avant le <code class="language-plaintext highlighter-rouge">|</code>. Ici, <code class="language-plaintext highlighter-rouge">\#</code> correspond au caractère <code class="language-plaintext highlighter-rouge">#</code>, et <code class="language-plaintext highlighter-rouge">[\w-]+</code> correspond à <code class="language-plaintext highlighter-rouge">answer-4185009</code>. Ensuite, pour la partie <code class="language-plaintext highlighter-rouge">\.([\w-]+)</code>, si nous avons <code class="language-plaintext highlighter-rouge">.answer-4185009</code>, cette correspondance sera appliquée.</p>

<p>Ensuite, examinons la correspondance <code class="language-plaintext highlighter-rouge">td.answercell</code>,</p>

<p>La première partie de la règle <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> correspond à <code class="language-plaintext highlighter-rouge">td</code>, et la deuxième partie de la règle <code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code>, plus précisément <code class="language-plaintext highlighter-rouge">\.([\w-]+)</code>, correspond à <code class="language-plaintext highlighter-rouge">.answercell</code>.</p>

<p>L’analyse de ce sélecteur s’achève ici.</p>

<h3 id="correspondre-à-ahrefhttpgooglecom">Correspondre à <code class="language-plaintext highlighter-rouge">a[href="http://google.com/"]</code></h3>

<p>Ensuite, nous allons faire correspondre le sélecteur <code class="language-plaintext highlighter-rouge">a[href="http://google.com/"]</code> :</p>

<p>Regardons le troisième bloc :</p>

<p>La troisième grande partie de l’expression est <code class="language-plaintext highlighter-rouge">(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?</code>. Tout d’abord, la partie la plus externe <code class="language-plaintext highlighter-rouge">(?:)</code> indique qu’il s’agit d’un groupe non capturant, et le <code class="language-plaintext highlighter-rouge">?</code> à la fin signifie que cette grande partie peut correspondre 0 ou 1 fois. Si on l’enlève, on obtient <code class="language-plaintext highlighter-rouge">\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\]</code>. <code class="language-plaintext highlighter-rouge">\[</code> correspond au caractère <code class="language-plaintext highlighter-rouge">[</code>. <code class="language-plaintext highlighter-rouge">@?</code> signifie que le caractère <code class="language-plaintext highlighter-rouge">@</code> est optionnel. Ensuite, le groupe <code class="language-plaintext highlighter-rouge">(!?[\w-:]+)</code> indique que <code class="language-plaintext highlighter-rouge">!</code> est optionnel, et <code class="language-plaintext highlighter-rouge">[\w-:]+</code> correspond à <code class="language-plaintext highlighter-rouge">href</code>. Le groupe suivant <code class="language-plaintext highlighter-rouge">(?:([!*^$]?=)["']?(.*?)["']?)</code> est un groupe non capturant. Si on enlève la couche la plus externe, on obtient <code class="language-plaintext highlighter-rouge">([!*^$]?=)["']?(.*?)["']?</code>. Ici, <code class="language-plaintext highlighter-rouge">([!*^$]?=)</code> signifie que <code class="language-plaintext highlighter-rouge">[!*^$]?</code> correspond à 0 ou 1 caractère parmi ceux entre <code class="language-plaintext highlighter-rouge">[]</code>. Ensuite, <code class="language-plaintext highlighter-rouge">=</code> correspond directement. Puis, <code class="language-plaintext highlighter-rouge">["']?(.*?)["']?</code> correspond à <code class="language-plaintext highlighter-rouge">"http://google.com/"</code>. <code class="language-plaintext highlighter-rouge">["']?</code> signifie qu’il correspond à <code class="language-plaintext highlighter-rouge">"</code> ou <code class="language-plaintext highlighter-rouge">'</code> ou aucun des deux. Si on enlève cette couche externe, on obtient <code class="language-plaintext highlighter-rouge">(.*?)</code> qui correspond à <code class="language-plaintext highlighter-rouge">http://google.com/</code>. Ici, <code class="language-plaintext highlighter-rouge">*?</code> signifie qu’il correspond à aussi peu de caractères que possible, c’est-à-dire que s’il y a <code class="language-plaintext highlighter-rouge">"</code> ou <code class="language-plaintext highlighter-rouge">'</code>, il doit être laissé pour l’expression suivante <code class="language-plaintext highlighter-rouge">["']?</code> à correspondre. Ainsi, il ne correspondra pas à <code class="language-plaintext highlighter-rouge">http://google.com/"</code>, mais seulement à <code class="language-plaintext highlighter-rouge">http://google.com/</code>. Donc, le sélecteur entier <code class="language-plaintext highlighter-rouge">a[href="http://google.com/</code></p>

<p><code class="language-plaintext highlighter-rouge">"]</code> marque la fin de la correspondance.</p>

<h3 id="résumé">Résumé</h3>

<p>Enfin, j’ai compris ! Reprenons une fois de plus pour clarifier. L’expression complexe <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)(?:\#([\w-]+)|\.([\w-]+))?(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?([\/, ]+)</code> est composée de quatre grandes parties :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code></li>
  <li><code class="language-plaintext highlighter-rouge">(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?</code></li>
  <li><code class="language-plaintext highlighter-rouge">([\/, ]+)</code></li>
</ul>

<p>La troisième partie, la plus complexe, est elle-même composée des éléments suivants :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\[</code></li>
  <li><code class="language-plaintext highlighter-rouge">(!?[\w-:]+)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(?:([!*^$]?=)["']?(.*?)["']?)?</code></li>
  <li><code class="language-plaintext highlighter-rouge">\]</code></li>
</ul>

<p>Ainsi, ces parties suffisamment petites peuvent être résolues une par une. Ensuite, cherchez plus d’exemples pour voir comment chaque exemple correspond, tout en utilisant les explications de https://regex101.com/ pour analyser. De cette manière, vous comprendrez cette expression régulière qui semble complexe, et vous réaliserez qu’elle n’est en fait qu’un tigre de papier !</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-fr" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
