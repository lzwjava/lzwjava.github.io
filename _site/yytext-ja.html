<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>YYText はどのように動作するのか</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>YYText はどのように動作するのか | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="YYText はどのように動作するのか" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="ja" />
<meta name="description" content="上の影の効果は、以下のコードで実現されています：" />
<meta property="og:description" content="上の影の効果は、以下のコードで実現されています：" />
<link rel="canonical" href="https://lzwjava.github.io/yytext-ja" />
<meta property="og:url" content="https://lzwjava.github.io/yytext-ja" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-24T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="YYText はどのように動作するのか" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-24T00:00:00+08:00","datePublished":"2016-05-24T00:00:00+08:00","description":"上の影の効果は、以下のコードで実現されています：","headline":"YYText はどのように動作するのか","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/yytext-ja"},"url":"https://lzwjava.github.io/yytext-ja"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=67019ec42c305e1671ac5de8a01c0c0c06cb6601">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=67019ec42c305e1671ac5de8a01c0c0c06cb6601" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       YYText はどのように動作するのか | オリジナル、AI翻訳
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/ja/2016-05-24-yytext-ja.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsja2016-05-24-yytext-ja.md</span> -->
      

      <!-- <span>2016-05-24-yytext-ja.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/yytext-en" >English</option>
        <option value="/yytext-zh" >中文</option>
        <option value="/yytext-ja" selected>日本語</option>
        <option value="/yytext-es" >Español</option>
        <option value="/yytext-hi" >हिंदी</option>
        <option value="/yytext-fr" >Français</option>
        <option value="/yytext-de" >Deutsch</option>
        <option value="/yytext-ar" >العربية</option>
        <option value="/yytext-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>上の影の効果は、以下のコードで実現されています：</p>

<p>先生が <code class="language-plaintext highlighter-rouge">YYTextShadow</code> を生成し、それを <code class="language-plaintext highlighter-rouge">attributedString</code> の <code class="language-plaintext highlighter-rouge">yy_textShadow</code> に代入し、その後 <code class="language-plaintext highlighter-rouge">attributedString</code> を <code class="language-plaintext highlighter-rouge">YYLabel</code> に代入し、さらに <code class="language-plaintext highlighter-rouge">YYLabel</code> を <code class="language-plaintext highlighter-rouge">UIView</code> に追加して表示していることがわかります。<code class="language-plaintext highlighter-rouge">yy_textShadow</code> を追跡すると、主に <code class="language-plaintext highlighter-rouge">textShadow</code> が <code class="language-plaintext highlighter-rouge">NSAttributedString</code> の attribute にバインドされており、キーは <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code>、値は <code class="language-plaintext highlighter-rouge">textShadow</code> であることがわかります。つまり、最初に shadow を保存し、後で使用するという流れです。Shift + Command + J を使って定義に素早くジャンプできます。</p>

<p>ここに <code class="language-plaintext highlighter-rouge">addAttribute</code> というものがあります。これは <code class="language-plaintext highlighter-rouge">NSAttributedString.h</code> で定義されています：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAttribute</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">value</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">range</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</code></pre></div></div>

<p>このメソッドは、指定された属性を指定された範囲のテキストに追加します。<code class="language-plaintext highlighter-rouge">name</code>は属性の名前を表し、<code class="language-plaintext highlighter-rouge">value</code>はその属性の値です。<code class="language-plaintext highlighter-rouge">range</code>は、属性を適用するテキストの範囲を指定します。</p>

<p>説明によると、任意のキーと値のペアを代入することができます。そして、<code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> の定義は普通の文字列であり、これは最初に shadow の情報を保存し、後で使用することを意味します。<code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> をグローバルに検索してみましょう。</p>

<p>次に、<code class="language-plaintext highlighter-rouge">YYTextLayout</code> 内の <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> 関数を見ていきましょう：</p>

<p><code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> は、コンテキスト内の原点座標を変更することを意味します。したがって、</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>このコードは、Core Graphicsのコンテキスト（<code class="language-plaintext highlighter-rouge">context</code>）に対して、指定された点（<code class="language-plaintext highlighter-rouge">point.x</code>と<code class="language-plaintext highlighter-rouge">point.y</code>）に基づいて座標系を平行移動（translate）します。具体的には、描画コンテキストの原点が<code class="language-plaintext highlighter-rouge">point.x</code>と<code class="language-plaintext highlighter-rouge">point.y</code>だけ移動されます。これにより、その後の描画操作は新しい原点を基準として行われます。</p>

<p>描画のコンテキストを <code class="language-plaintext highlighter-rouge">point</code> 点に移動することを意味します。まず、どこで <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> が呼び出されているのかを確認し、それが <code class="language-plaintext highlighter-rouge">drawInContext</code> 内で呼び出されていることを発見しました。</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext</code> 内では、順番にブロックの枠線を描画し、その後、背景の枠線、影、下線、テキスト、装飾、内側の影、取り消し線、テキストの枠線、デバッグ用の線を描画します。</p>

<p>では、実際にどこで <code class="language-plaintext highlighter-rouge">drawInContext</code> が使われているのでしょうか？その中に <code class="language-plaintext highlighter-rouge">YYTextDebugOption</code> というパラメータがあることがわかります。したがって、この関数はシステムのコールバックではなく、YYText 内部で独自に呼び出されていることが確実です。</p>

<p>Ctrl + 1 を押してショートカットを表示すると、4つの場所で呼び出されていることがわかります。</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext:size:debug</code> は依然として YYText 自身の呼び出しです。なぜなら、<code class="language-plaintext highlighter-rouge">debug</code> の型は <code class="language-plaintext highlighter-rouge">YYTextDebugOption *</code> であり、これは YY 自身のものだからです。<code class="language-plaintext highlighter-rouge">newAsyncTask</code> はシステムの呼び出しには見えず、<code class="language-plaintext highlighter-rouge">addAttachmentToView:layer:</code> も同様です。したがって、これらはおそらく <code class="language-plaintext highlighter-rouge">drawRect:</code> の呼び出しである可能性が高いです。</p>

<p>確かに、右側のクイックヘルプを見ると、詳細な説明があり、ヘルプの下には <code class="language-plaintext highlighter-rouge">UIView</code> で定義されていると書かれています。さらに <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> を見ると、これは <code class="language-plaintext highlighter-rouge">UIView</code> を継承しています。</p>

<p><code class="language-plaintext highlighter-rouge">YYLabel</code> は <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> を使っているのですか？そしてシステムに <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> 内の <code class="language-plaintext highlighter-rouge">drawRect:</code> を呼び出させて描画させているのですか？</p>

<p>奇妙ですね、<code class="language-plaintext highlighter-rouge">YYLabel</code> は <code class="language-plaintext highlighter-rouge">UIView</code> を継承しています。つまり、YYText には2つのセットが存在するはずです！1つは <code class="language-plaintext highlighter-rouge">YYLabel</code>、もう1つは <code class="language-plaintext highlighter-rouge">YYTextView</code> で、<code class="language-plaintext highlighter-rouge">UILabel</code> と <code class="language-plaintext highlighter-rouge">UITextView</code> のように。それでは、先ほどの <code class="language-plaintext highlighter-rouge">YYLabel</code> の <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code> をもう一度見てみましょう。</p>

<p>長いコードの中間で <code class="language-plaintext highlighter-rouge">YYTextLayout</code> の <code class="language-plaintext highlighter-rouge">drawInContext</code> が呼び出されています。<code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code> はどこで呼び出されているのでしょうか？</p>

<p>2行目で呼び出されました。したがって、簡単に理解すると、<code class="language-plaintext highlighter-rouge">YYLabel</code>はテキストを描画するために非同期を使用していると言えます。そして、<code class="language-plaintext highlighter-rouge">_displayAsync</code>は上記の<code class="language-plaintext highlighter-rouge">display</code>によって呼び出されています。<code class="language-plaintext highlighter-rouge">display</code>のドキュメントを見ると、システムが適切なタイミングで呼び出してレイヤーの内容を更新すると書かれています。直接呼び出すべきではありません。また、ブレークポイントを設定することもできます。</p>

<p><code class="language-plaintext highlighter-rouge">display</code> は <code class="language-plaintext highlighter-rouge">CALayer</code> のトランザクション中に呼び出されることを説明します。なぜトランザクションを使うのかというと、おそらく更新をバッチ処理して効率を上げるためでしょう。データベースのようなロールバックの必要性はなさそうです。</p>

<p><code class="language-plaintext highlighter-rouge">display</code> のシステムドキュメントには、もしあなたのレイヤーを異なる方法で描画したい場合、このメソッドをオーバーライドして独自の描画を実装できると書かれています。</p>

<p>したがって、簡単にいくつかのアイデアを得ました。<code class="language-plaintext highlighter-rouge">YYLabel</code> は <code class="language-plaintext highlighter-rouge">UIView</code> の <code class="language-plaintext highlighter-rouge">display</code> メソッドをオーバーライドして、自身の影などの効果を非同期に描画します。影の効果はまず <code class="language-plaintext highlighter-rouge">YYLabel</code> の <code class="language-plaintext highlighter-rouge">attributedText</code> の属性に保存され、<code class="language-plaintext highlighter-rouge">display</code> メソッドで描画する際に取り出されます。描画時にはシステムの CoreGraphics フレームワークが使用されます。</p>

<p>いくつかの考えを整理した後、本当に強力なものは何かがわかります。一方では、これだけの効果や非同期呼び出しなどを組織化する能力であり、もう一方では、基盤となるCoreGraphicsフレームワークの熟練した運用です。したがって、前のコードの組織化について少し理解した後、CoreGraphicsフレームワークに深く入り込んでいきます。どのように描画されているのかを見てみましょう。</p>

<p><code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> に戻りましょう。</p>

<p>ここでは、<code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> と <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> が描画コードの一部を囲んでいます。<code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> の意味は、現在の描画状態をコピーして、描画スタックにプッシュすることです。各描画コンテキストは、描画スタックを維持しています。スタックの内部操作については詳しくはわかりませんが、とりあえず、描画コンテキストの前に <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> を呼び出し、描画コンテキストの後に <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> を呼び出すことで、その間の描画がコンテキストに有効に表示されると理解しておきます。<code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> は、コンテキストを対応する位置に移動します。まず <code class="language-plaintext highlighter-rouge">point.x</code> と <code class="language-plaintext highlighter-rouge">point.y</code> に移動し、描画の対応位置に移動します。その後、0 と <code class="language-plaintext highlighter-rouge">size.height</code> に移動する理由はまだわからないので、後でまた確認します。次に <code class="language-plaintext highlighter-rouge">lines</code> を取り出し、<code class="language-plaintext highlighter-rouge">for</code> ループを実行します。</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> とは何ですか？<code class="language-plaintext highlighter-rouge">YYTextLayout</code> 内の <code class="language-plaintext highlighter-rouge">(YYTextLayout *)layoutWithContainer:(YYTextContainer *)container text:(NSAttributedString *)text range:(NSRange)range</code> で値が設定されているのを見つけました。</p>

<p>次に、この関数の定義部分に移動します：</p>

<p>この関数は非常に長く、367行から861行まで、500行ものコードがあります！最初と最後を見ると、その目的はこれらの変数を取得することだとわかります。<code class="language-plaintext highlighter-rouge">lines</code>はどのように取得されるのでしょうか？</p>

<p>大きな <code class="language-plaintext highlighter-rouge">for</code> ループの中で、1行ずつ <code class="language-plaintext highlighter-rouge">line</code> を <code class="language-plaintext highlighter-rouge">lines</code> に追加しているのが見られます。では、<code class="language-plaintext highlighter-rouge">lineCount</code> はどのように得られるのでしょうか？</p>

<p>472行目では、<code class="language-plaintext highlighter-rouge">framesetter</code>オブジェクトが作成され、<code class="language-plaintext highlighter-rouge">text</code>パラメータは<code class="language-plaintext highlighter-rouge">NSAttributedString</code>です。その後、<code class="language-plaintext highlighter-rouge">frameSetter</code>オブジェクト内に<code class="language-plaintext highlighter-rouge">CTFrameRef</code>が作成され、<code class="language-plaintext highlighter-rouge">CTFrameRef</code>から<code class="language-plaintext highlighter-rouge">lines</code>が取得されます。<code class="language-plaintext highlighter-rouge">line</code>とは一体何でしょうか？ここにブレークポイントを設定して確認してみましょう。</p>

<p>発見しましたが、<code class="language-plaintext highlighter-rouge">shadow</code> という単語の <code class="language-plaintext highlighter-rouge">lineCount = 2</code> は、私たちが想像していた文字数ではありませんでした。</p>

<p>なので、白い <code class="language-plaintext highlighter-rouge">Shadow</code> 全体が一つの <code class="language-plaintext highlighter-rouge">line</code> で、影も一つの <code class="language-plaintext highlighter-rouge">line</code> だと推測していますか？</p>

<p>YYText にはいくつかの例がありますが、そのうちの1つの効果だけを表示し、他のコードをコメントアウトしています。奇妙なことに、Shadow の <code class="language-plaintext highlighter-rouge">lineCount = 2</code> で、Multiple Shadows の <code class="language-plaintext highlighter-rouge">lineCount</code> も 2 です。しかし、Multiple Shadows には内側の影もあるので、3 つになるはずですよね？</p>

<p>CTLine の Apple ドキュメントを調べると、CTLine は一行のテキストを表し、CTLine オブジェクトは一連の <code class="language-plaintext highlighter-rouge">glyph runs</code> を含んでいると書かれています。つまり、単純に行数のことです！上のブレークポイントのスクリーンショットを見ると、先ほど <code class="language-plaintext highlighter-rouge">shadow</code> が 2 だったのは、そのテキストが <code class="language-plaintext highlighter-rouge">shadow\n\n</code> だったからです。先ほど、<code class="language-plaintext highlighter-rouge">\n\n</code> は意図的に追加され、見た目を良くするためでした：</p>

<p>したがって、<code class="language-plaintext highlighter-rouge">shadow\n\n</code> は2行のテキストです。CTLine は、私たちが普段「行」と呼んでいるものです。次に、<code class="language-plaintext highlighter-rouge">lineCount</code> を見てみましょう：</p>

<p>ここで <code class="language-plaintext highlighter-rouge">CTLines</code> 配列を取得し、その中の要素数を取得します。そして、<code class="language-plaintext highlighter-rouge">lineCount</code> が 0 より大きい場合、各行の座標原点を取得します。さて、<code class="language-plaintext highlighter-rouge">lineCount</code> が得られたので、次に <code class="language-plaintext highlighter-rouge">for</code> ループを見ていきましょう。</p>

<p><code class="language-plaintext highlighter-rouge">ctLines</code> 配列から <code class="language-plaintext highlighter-rouge">CTLine</code> を取得し、次に <code class="language-plaintext highlighter-rouge">YYTextLine</code> オブジェクトを取得して、それを <code class="language-plaintext highlighter-rouge">lines</code> 配列に追加します。その後、<code class="language-plaintext highlighter-rouge">line</code> のフレーム計算を行います。<code class="language-plaintext highlighter-rouge">YYTextLine</code> のコンストラクタはシンプルで、位置、垂直レイアウトかどうか、<code class="language-plaintext highlighter-rouge">CTLine</code> オブジェクトを保存します：</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> を理解した後、以前の <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> に戻りましょう：</p>

<p>これでコードがシンプルになりました。まず行数を取得し、それを走査します。次に <code class="language-plaintext highlighter-rouge">GlyphRuns</code> 配列を取得し、それを走査します。<code class="language-plaintext highlighter-rouge">GlyphRun</code> は図形や描画単位と理解できます。その後、<code class="language-plaintext highlighter-rouge">attributes</code> 配列を取得し、以前の <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> を使用して、最初に割り当てた <code class="language-plaintext highlighter-rouge">shadow</code> を取得します。そして、影の描画を開始します：</p>

<p><code class="language-plaintext highlighter-rouge">while</code> ループを使用して、サブシャドウを繰り返し描画します。<code class="language-plaintext highlighter-rouge">CGContextSetShadowWithColor</code> を呼び出して、シャドウのオフセット、半径、色を設定します。その後、<code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> を呼び出して実際に描画を行います。<code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> は3つの場所で呼び出されます：</p>

<p>内側の影やテキストの影、テキスト自体を描画するために使用されます。これは、<code class="language-plaintext highlighter-rouge">Run</code> オブジェクトを描画するための汎用的なメソッドであることを示しています。</p>

<p>最初にテキストの変換行列を取得し、<code class="language-plaintext highlighter-rouge">runTextMatrixIsID</code>を使用してそれが変更されていないかどうかを確認します。もし垂直レイアウトでないか、または図形変換が設定されていない場合は、直接描画を開始します。<code class="language-plaintext highlighter-rouge">CTRunDraw</code>を呼び出して<code class="language-plaintext highlighter-rouge">run</code>オブジェクトを描画します。その後、ブレークポイントを設定して、最初の影を描画する際に<code class="language-plaintext highlighter-rouge">if</code>文の中に入るが、<code class="language-plaintext highlighter-rouge">else</code>文には入らないことを確認します。</p>

<p>以上で、私たちの影の描画は終了です！</p>

<p>まとめると、<code class="language-plaintext highlighter-rouge">YYLabel</code> はまず、影などの効果を <code class="language-plaintext highlighter-rouge">attributedText</code> の attributes に保存し、<code class="language-plaintext highlighter-rouge">UIView</code> の <code class="language-plaintext highlighter-rouge">display</code> メソッドをオーバーライドします。<code class="language-plaintext highlighter-rouge">display</code> メソッド内で非同期描画を行い、<code class="language-plaintext highlighter-rouge">CoreText</code> フレームワークを使用して <code class="language-plaintext highlighter-rouge">CTLine</code> や <code class="language-plaintext highlighter-rouge">CTRun</code> オブジェクトを取得します。<code class="language-plaintext highlighter-rouge">CTRun</code> から attributes を取得し、その後、attributes 内の各プロパティに基づいて、<code class="language-plaintext highlighter-rouge">CoreGraphics</code> フレームワークを使用して <code class="language-plaintext highlighter-rouge">CTRun</code> オブジェクトを Context に描画します。</p>

<p>理解がまだ十分でないので、後でまた読み返してみようと思います。YYの強さに改めて感嘆せざるを得ません！今日は考えを整理し、コードを書きながら読み進めることで、単調さを避けつつ、皆さんの参考にもなるようにしました。そろそろ寝る時間です。</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-ja" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
