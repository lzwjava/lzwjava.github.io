<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Comment fonctionne YYText</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Comment fonctionne YYText | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Comment fonctionne YYText" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="fr" />
<meta name="description" content="L’effet d’ombre ci-dessus est réalisé avec le code suivant :" />
<meta property="og:description" content="L’effet d’ombre ci-dessus est réalisé avec le code suivant :" />
<link rel="canonical" href="https://lzwjava.github.io/yytext-fr" />
<meta property="og:url" content="https://lzwjava.github.io/yytext-fr" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-24T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Comment fonctionne YYText" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-24T00:00:00+08:00","datePublished":"2016-05-24T00:00:00+08:00","description":"L’effet d’ombre ci-dessus est réalisé avec le code suivant :","headline":"Comment fonctionne YYText","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/yytext-fr"},"url":"https://lzwjava.github.io/yytext-fr"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=5ed887fe3ef5334418d51fd3c91878d0831fcb62">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=5ed887fe3ef5334418d51fd3c91878d0831fcb62" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Comment fonctionne YYText | Original, traduit par l'IA
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/fr/2016-05-24-yytext-fr.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsfr2016-05-24-yytext-fr.md</span> -->
      

      <!-- <span>2016-05-24-yytext-fr.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/yytext-en" >English</option>
        <option value="/yytext-zh" >中文</option>
        <option value="/yytext-ja" >日本語</option>
        <option value="/yytext-es" >Español</option>
        <option value="/yytext-hi" >हिंदी</option>
        <option value="/yytext-fr" selected>Français</option>
        <option value="/yytext-de" >Deutsch</option>
        <option value="/yytext-ar" >العربية</option>
        <option value="/yytext-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>L’effet d’ombre ci-dessus est réalisé avec le code suivant :</p>

<p>On peut voir que <code class="language-plaintext highlighter-rouge">YYTextShadow</code> est d’abord généré, puis assigné à <code class="language-plaintext highlighter-rouge">yy_textShadow</code> de <code class="language-plaintext highlighter-rouge">attributedString</code>. Ensuite, <code class="language-plaintext highlighter-rouge">attributedString</code> est assigné à <code class="language-plaintext highlighter-rouge">YYLabel</code>, et enfin, <code class="language-plaintext highlighter-rouge">YYLabel</code> est ajouté à <code class="language-plaintext highlighter-rouge">UIView</code> pour être affiché. En suivant <code class="language-plaintext highlighter-rouge">yy_textShadow</code>, on découvre que cela consiste principalement à lier <code class="language-plaintext highlighter-rouge">textShadow</code> à l’attribut de <code class="language-plaintext highlighter-rouge">NSAttributedString</code>, avec la clé <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> et la valeur <code class="language-plaintext highlighter-rouge">textShadow</code>. Cela signifie que le shadow est d’abord stocké, puis utilisé ultérieurement. Utilisez Shift + Command + J pour accéder rapidement à la définition :</p>

<p>Il y a ici une fonction <code class="language-plaintext highlighter-rouge">addAttribute</code>, qui est définie dans le fichier <code class="language-plaintext highlighter-rouge">NSAttributedString.h</code> :</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAttribute</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">value</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">range</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</code></pre></div></div>

<p>Cela signifie que vous pouvez lui assigner n’importe quelle paire clé-valeur. La définition de <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> est une chaîne de caractères ordinaire, ce qui signifie que les informations de l’ombre sont d’abord stockées, puis utilisées ultérieurement. Faisons une recherche globale de <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code>.</p>

<p>Ensuite, nous arrivons à la fonction <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> dans <code class="language-plaintext highlighter-rouge">YYTextLayout</code> :</p>

<p><code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> est utilisé pour modifier les coordonnées de l’origine dans un contexte, donc…</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>Cela signifie qu’il faut déplacer le contexte de dessin vers le point <code class="language-plaintext highlighter-rouge">point</code>. Nous devons d’abord comprendre où <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> est appelé, et nous constatons qu’il est appelé dans <code class="language-plaintext highlighter-rouge">drawInContext</code>.</p>

<p>Dans <code class="language-plaintext highlighter-rouge">drawInContext</code>, dessinez successivement la bordure du bloc, puis la bordure de fond, l’ombre, le soulignement, le texte, les accessoires, l’ombre intérieure, la ligne de suppression, la bordure du texte et les lignes de débogage.</p>

<p>Alors, où est-ce que <code class="language-plaintext highlighter-rouge">drawInContext</code> est utilisé exactement ? On peut voir qu’il y a un paramètre <code class="language-plaintext highlighter-rouge">YYTextDebugOption</code>, donc cette fonction n’est certainement pas un rappel système, mais plutôt une fonction appelée par YYText lui-même.</p>

<p>Maintenez la touche Ctrl + 1 enfoncée pour afficher les raccourcis clavier, et vous constaterez qu’il y a quatre endroits où ils sont utilisés.</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext:size:debug</code> reste un appel propre à YYText, car le type de <code class="language-plaintext highlighter-rouge">debug</code> est <code class="language-plaintext highlighter-rouge">YYTextDebugOption *</code>, qui est spécifique à YY. <code class="language-plaintext highlighter-rouge">newAsyncTask</code> ne ressemble pas à un appel système, et <code class="language-plaintext highlighter-rouge">addAttachmentToView:layer:</code> est similaire, donc il est fort probable que ce soit <code class="language-plaintext highlighter-rouge">drawRect:</code>.</p>

<p>En effet, en regardant l’aide rapide à droite, il y a une explication détaillée, et en dessous de l’aide, il est également indiqué que cela est défini dans <code class="language-plaintext highlighter-rouge">UIView</code>. Ensuite, en examinant <code class="language-plaintext highlighter-rouge">YYTextContainerView</code>, on voit qu’il hérite de <code class="language-plaintext highlighter-rouge">UIView</code>.</p>

<p>Donc <code class="language-plaintext highlighter-rouge">YYLabel</code> utilise <code class="language-plaintext highlighter-rouge">YYTextContainerView</code>, c’est ça ? Et ensuite, il laisse le système appeler <code class="language-plaintext highlighter-rouge">drawRect:</code> dans <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> pour dessiner ?</p>

<p>Étrange, <code class="language-plaintext highlighter-rouge">YYLabel</code> hérite de <code class="language-plaintext highlighter-rouge">UIView</code>. Donc, dans YYText, il devrait y avoir deux ensembles de choses ! Un ensemble <code class="language-plaintext highlighter-rouge">YYLabel</code>, et un ensemble <code class="language-plaintext highlighter-rouge">YYTextView</code>, comme <code class="language-plaintext highlighter-rouge">UILabel</code> et <code class="language-plaintext highlighter-rouge">UITextView</code>. Ensuite, revenons à la méthode <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code> de <code class="language-plaintext highlighter-rouge">YYLabel</code> que nous avons vue précédemment,</p>

<p>Très long, au milieu, il appelle <code class="language-plaintext highlighter-rouge">drawInContext</code> dans <code class="language-plaintext highlighter-rouge">YYTextLayout</code>. <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code>, où est-il appelé à son tour ?</p>

<p>Sur la deuxième ligne, il est appelé. On peut donc simplement comprendre que <code class="language-plaintext highlighter-rouge">YYLabel</code> utilise un processus asynchrone pour dessiner le texte. Et <code class="language-plaintext highlighter-rouge">_displayAsync</code> est appelé par la méthode <code class="language-plaintext highlighter-rouge">display</code> ci-dessus. En regardant la documentation de <code class="language-plaintext highlighter-rouge">display</code>, il est dit que le système l’appellera au moment approprié pour mettre à jour le contenu du layer, et il ne faut pas l’appeler directement. Nous pouvons également y ajouter un point d’arrêt.</p>

<p>L’explication est que <code class="language-plaintext highlighter-rouge">display</code> est appelé dans une transaction de <code class="language-plaintext highlighter-rouge">CALayer</code>. Pourquoi utiliser une transaction ? Probablement pour mettre à jour en masse, ce qui serait plus efficace, non ? Cela ne ressemble pas à un besoin de rollback comme dans une base de données.</p>

<p>La documentation système de <code class="language-plaintext highlighter-rouge">display</code> mentionne également que si vous souhaitez que votre layer soit dessiné différemment, vous pouvez surcharger cette méthode pour implémenter votre propre dessin.</p>

<p>Ainsi, nous avons une idée simple. <code class="language-plaintext highlighter-rouge">YYLabel</code> utilise la méthode <code class="language-plaintext highlighter-rouge">display</code> de <code class="language-plaintext highlighter-rouge">UIView</code> pour dessiner de manière asynchrone ses effets tels que les ombres, etc. Les effets d’ombre sont d’abord stockés dans les attributs de <code class="language-plaintext highlighter-rouge">attributedText</code> de <code class="language-plaintext highlighter-rouge">YYLabel</code>, puis récupérés lors du dessin dans la méthode <code class="language-plaintext highlighter-rouge">display</code>. Pour le dessin, le framework CoreGraphics du système est utilisé.</p>

<p>Après avoir clarifié certaines idées, on se rend compte de ce qui est vraiment puissant : d’un côté, c’est la capacité à organiser autant d’effets, d’appels asynchrones, etc., et de l’autre, c’est la maîtrise approfondie du framework CoreGraphics sous-jacent. Ainsi, après avoir acquis une certaine compréhension de l’organisation du code précédent, nous allons maintenant plonger plus profondément dans le framework CoreGraphics. Voyons comment le dessin est effectué.</p>

<p>Revenons à <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>.</p>

<p>Ici, <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> et <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> encadrent un bloc de code de dessin. <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> signifie que l’état actuel du dessin est copié et placé dans la pile de dessin. Chaque contexte de dessin maintient une pile de dessin. Je ne suis pas sûr de la manière exacte dont la pile est gérée. Pour l’instant, comprenons simplement qu’il faut appeler <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> avant de dessiner dans le contexte, et <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> après, afin que le dessin intermédiaire apparaisse correctement dans le contexte. <code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> déplace le contexte à une position spécifique. Il se déplace d’abord à <code class="language-plaintext highlighter-rouge">point.x</code> et <code class="language-plaintext highlighter-rouge">point.y</code>, les coordonnées de dessin, puis à 0 et <code class="language-plaintext highlighter-rouge">size.height</code>, ce qui n’est pas clair pour le moment, nous verrons cela plus tard. Ensuite, les <code class="language-plaintext highlighter-rouge">lines</code> sont récupérées et une boucle <code class="language-plaintext highlighter-rouge">for</code> est exécutée.</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> est un tableau qui contient les lignes de texte générées lors de la création d’une mise en page de texte (<code class="language-plaintext highlighter-rouge">YYTextLayout</code>). Dans la méthode <code class="language-plaintext highlighter-rouge">(YYTextLayout *)layoutWithContainer:(YYTextContainer *)container text:(NSAttributedString *)text range:(NSRange)range</code>, ce tableau est rempli avec les lignes de texte qui sont calculées en fonction du conteneur (<code class="language-plaintext highlighter-rouge">container</code>), du texte (<code class="language-plaintext highlighter-rouge">text</code>) et de la plage spécifiée (<code class="language-plaintext highlighter-rouge">range</code>).</p>

<p>Chaque élément du tableau <code class="language-plaintext highlighter-rouge">lines</code> représente une ligne de texte dans la mise en page, et ces lignes sont utilisées pour afficher le texte correctement formaté à l’écran.</p>

<p>Ensuite, naviguez jusqu’à la définition de cette fonction :</p>

<p>Cette fonction est très longue, de la ligne 367 à la ligne 861, soit 500 lignes de code ! En regardant le début et la fin, on peut voir que son utilité est d’obtenir ces variables. Comment <code class="language-plaintext highlighter-rouge">lines</code> est-il obtenu ?</p>

<p>On peut voir que dans une grande boucle <code class="language-plaintext highlighter-rouge">for</code>, chaque <code class="language-plaintext highlighter-rouge">line</code> est ajoutée une par une dans <code class="language-plaintext highlighter-rouge">lines</code>. Mais comment est obtenu le <code class="language-plaintext highlighter-rouge">lineCount</code> ?</p>

<p>À la ligne 472, un objet <code class="language-plaintext highlighter-rouge">framesetter</code> est créé, avec le paramètre <code class="language-plaintext highlighter-rouge">text</code> étant un <code class="language-plaintext highlighter-rouge">NSAttributedString</code>. Ensuite, un <code class="language-plaintext highlighter-rouge">CTFrameRef</code> est créé à partir de l’objet <code class="language-plaintext highlighter-rouge">frameSetter</code>, puis les <code class="language-plaintext highlighter-rouge">lines</code> sont obtenues à partir du <code class="language-plaintext highlighter-rouge">CTFrameRef</code>. Mais qu’est-ce exactement qu’une <code class="language-plaintext highlighter-rouge">line</code> ? Mettons un point d’arrêt pour l’examiner.</p>

<p>On a découvert que pour le mot <code class="language-plaintext highlighter-rouge">shadow</code>, la valeur de <code class="language-plaintext highlighter-rouge">lineCount = 2</code> ne correspond pas au nombre de lettres comme on pourrait s’y attendre.</p>

<p>Donc, on peut supposer que le <code class="language-plaintext highlighter-rouge">Shadow</code> blanc est en fait une seule <code class="language-plaintext highlighter-rouge">line</code>, et l’ombre est également une seule <code class="language-plaintext highlighter-rouge">line</code> ?</p>

<p>Dans YYText, il y a plusieurs exemples, mais un seul effet est affiché, les autres codes étant commentés. J’ai remarqué quelque chose d’étrange : pour <code class="language-plaintext highlighter-rouge">Shadow</code>, <code class="language-plaintext highlighter-rouge">lineCount = 2</code>, et pour <code class="language-plaintext highlighter-rouge">Multiple Shadows</code>, <code class="language-plaintext highlighter-rouge">lineCount</code> est également égal à 2. Cependant, <code class="language-plaintext highlighter-rouge">Multiple Shadows</code> a également une ombre intérieure, donc cela devrait être 3, non ?</p>

<p>En consultant la documentation Apple pour <code class="language-plaintext highlighter-rouge">CTLine</code>, il est indiqué que <code class="language-plaintext highlighter-rouge">CTLine</code> représente une ligne de texte, et un objet <code class="language-plaintext highlighter-rouge">CTLine</code> contient un ensemble de <code class="language-plaintext highlighter-rouge">glyph runs</code>. Donc, il s’agit simplement du nombre de lignes ! En regardant la capture d’écran du point d’arrêt ci-dessus, la raison pour laquelle <code class="language-plaintext highlighter-rouge">shadow</code> avait une valeur de 2 est que son texte était <code class="language-plaintext highlighter-rouge">shadow\n\n</code>. Comme vous pouvez le voir, <code class="language-plaintext highlighter-rouge">\n\n</code> a été ajouté intentionnellement pour des raisons esthétiques :</p>

<p>Donc, <code class="language-plaintext highlighter-rouge">shadow\n\n</code> représente deux lignes de texte. CTLine correspond à ce que nous appelons habituellement une ligne. Revenons maintenant à notre <code class="language-plaintext highlighter-rouge">lineCount</code> :</p>

<p>Ici, nous obtenons un tableau de <code class="language-plaintext highlighter-rouge">CTLines</code>, puis nous comptons le nombre d’éléments dans ce tableau. Si <code class="language-plaintext highlighter-rouge">lineCount</code> est supérieur à 0, nous obtenons l’origine des coordonnées pour chaque ligne. Maintenant que nous avons <code class="language-plaintext highlighter-rouge">lineCount</code>, passons à la boucle <code class="language-plaintext highlighter-rouge">for</code>.</p>

<p>Depuis le tableau <code class="language-plaintext highlighter-rouge">ctLines</code>, on obtient un <code class="language-plaintext highlighter-rouge">CTLine</code>, puis on crée un objet <code class="language-plaintext highlighter-rouge">YYTextLine</code> qui est ensuite ajouté au tableau <code class="language-plaintext highlighter-rouge">lines</code>. Ensuite, on effectue quelques calculs de frame pour la <code class="language-plaintext highlighter-rouge">line</code>. Le constructeur de <code class="language-plaintext highlighter-rouge">YYTextLine</code> est assez simple : il sauvegarde d’abord la position, si le texte est en mode vertical, et l’objet <code class="language-plaintext highlighter-rouge">CTLine</code> :</p>

<pre><code class="language-objective-c">- (instancetype)initWithCTLine:(CTLineRef)ctLine position:(CGPoint)position vertical:(BOOL)vertical {
    self = [super init];
    if (self) {
        _ctLine = CFRetain(ctLine);
        _position = position;
        _vertical = vertical;
    }
    return self;
}
</code></pre>

<p>Une fois que vous avez bien compris <code class="language-plaintext highlighter-rouge">lines</code>, revenons à la fonction <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> précédente :</p>

<p>Le code est maintenant plus simple. D’abord, on récupère le nombre de lignes, on les parcourt, puis on obtient le tableau <code class="language-plaintext highlighter-rouge">GlyphRuns</code>, qu’on parcourt également. Un <code class="language-plaintext highlighter-rouge">GlyphRun</code> peut être considéré comme un élément graphique ou une unité de dessin. Ensuite, on extrait le tableau <code class="language-plaintext highlighter-rouge">attributes</code>, on utilise notre <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> précédemment défini pour récupérer l’ombre (<code class="language-plaintext highlighter-rouge">shadow</code>) que nous avons attribuée au départ, et enfin on commence à dessiner l’ombre :</p>

<p>Une boucle <code class="language-plaintext highlighter-rouge">while</code> qui dessine continuellement des ombres portées. Appelle <code class="language-plaintext highlighter-rouge">CGContextSetShadowWithColor</code> pour définir le déplacement, le rayon et la couleur de l’ombre. Ensuite, appelle <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> pour effectuer le dessin réel. <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> est appelé à trois endroits :</p>

<p>Utilisé pour dessiner des ombres intérieures, des ombres de texte ainsi que le texte lui-même. Cela indique qu’il s’agit d’une méthode générique utilisée pour dessiner l’objet <code class="language-plaintext highlighter-rouge">Run</code>.</p>

<p>On commence par obtenir la matrice de transformation du texte, puis on utilise <code class="language-plaintext highlighter-rouge">runTextMatrixIsID</code> pour vérifier si elle reste inchangée. Si ce n’est pas une mise en page verticale ou si aucune transformation graphique n’est définie, on passe directement au dessin. On appelle <code class="language-plaintext highlighter-rouge">CTRunDraw</code> pour dessiner l’objet <code class="language-plaintext highlighter-rouge">run</code>. Ensuite, en mettant un point d’arrêt, on constate que lors du dessin de l’ombre initiale, le programme n’entre que dans le bloc <code class="language-plaintext highlighter-rouge">if</code> et ne passe pas dans le bloc <code class="language-plaintext highlighter-rouge">else</code>.</p>

<p>Ainsi, notre dessin d’ombres est terminé !</p>

<p>En résumé, <code class="language-plaintext highlighter-rouge">YYLabel</code> stocke d’abord les effets tels que les ombres dans les attributs de <code class="language-plaintext highlighter-rouge">attributedText</code>, puis redéfinit la méthode <code class="language-plaintext highlighter-rouge">display</code> de <code class="language-plaintext highlighter-rouge">UIView</code>. Dans <code class="language-plaintext highlighter-rouge">display</code>, il effectue un rendu asynchrone en utilisant le framework <code class="language-plaintext highlighter-rouge">CoreText</code> pour obtenir des objets <code class="language-plaintext highlighter-rouge">CTLine</code> et <code class="language-plaintext highlighter-rouge">CTRun</code>. Ensuite, il récupère les attributs à partir de <code class="language-plaintext highlighter-rouge">CTRun</code> et, en fonction des propriétés contenues dans ces attributs, utilise le framework <code class="language-plaintext highlighter-rouge">CoreGraphics</code> pour dessiner l’objet <code class="language-plaintext highlighter-rouge">CTRun</code> dans le contexte.</p>

<p>La compréhension n’est pas encore suffisante, je reviendrai lire cela plus tard. Je ne peux m’empêcher de m’exclamer que YY est vraiment trop fort ! Aujourd’hui, j’ai organisé mes idées, me permettant d’écrire tout en lisant le code, pour ne pas que cela devienne ennuyeux, et en même temps pour offrir une référence à tout le monde. Il est temps d’aller dormir.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-fr" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
