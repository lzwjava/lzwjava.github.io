<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Komplexe reguläre Ausdrücke</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Komplexe reguläre Ausdrücke | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Komplexe reguläre Ausdrücke" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="de" />
<meta name="description" content="Kürzlich habe ich mich mit HTML-Parsing beschäftigt und bin auf einen regulären Ausdruck gestoßen:" />
<meta property="og:description" content="Kürzlich habe ich mich mit HTML-Parsing beschäftigt und bin auf einen regulären Ausdruck gestoßen:" />
<link rel="canonical" href="https://lzwjava.github.io/regex-de" />
<meta property="og:url" content="https://lzwjava.github.io/regex-de" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-25T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Komplexe reguläre Ausdrücke" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-25T00:00:00+08:00","datePublished":"2016-05-25T00:00:00+08:00","description":"Kürzlich habe ich mich mit HTML-Parsing beschäftigt und bin auf einen regulären Ausdruck gestoßen:","headline":"Komplexe reguläre Ausdrücke","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/regex-de"},"url":"https://lzwjava.github.io/regex-de"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=9e347f3d5cf7fea6b22da80e13c2ebb0a54f87d3">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=9e347f3d5cf7fea6b22da80e13c2ebb0a54f87d3" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Komplexe reguläre Ausdrücke | Original, von KI übersetzt
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/de/2016-05-25-regex-de.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsde2016-05-25-regex-de.md</span> -->
      

      <!-- <span>2016-05-25-regex-de.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/regex-en" >English</option>
        <option value="/regex-zh" >中文</option>
        <option value="/regex-ja" >日本語</option>
        <option value="/regex-es" >Español</option>
        <option value="/regex-hi" >हिंदी</option>
        <option value="/regex-fr" >Français</option>
        <option value="/regex-de" selected>Deutsch</option>
        <option value="/regex-ar" >العربية</option>
        <option value="/regex-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Kürzlich habe ich mich mit HTML-Parsing beschäftigt und bin auf einen regulären Ausdruck gestoßen:</p>

<p><code class="language-plaintext highlighter-rouge">/([\w-:\*&gt;]*)(?:\#([\w-]+)|\.([\w-]+))?(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?([\/, ]+)/is</code></p>

<p>(Dies ist ein regulärer Ausdruck in PHP, der nicht übersetzt werden muss, da er spezifische Muster in Zeichenketten sucht und keine sprachspezifischen Begriffe enthält.)</p>

<p>Es wird verwendet, um CSS-Selektoren abzugleichen, wie z.B. <code class="language-plaintext highlighter-rouge">div &gt; ul</code>.</p>

<p>Früher bin ich oft auf solch komplexe Ausdrücke gestoßen und habe instinktiv zurückgeschreckt. Heute werde ich sie endlich verstehen! Ein Mann sollte sich selbst härter anpacken!</p>

<h3 id="übereinstimmung-mit-div--ul">Übereinstimmung mit <code class="language-plaintext highlighter-rouge">div &gt; ul</code></h3>

<p>Ich habe eine Website gefunden, https://regex101.com/, die es ermöglicht, online Regex-Muster zu testen und bietet auch Erklärungen dazu.</p>

<p>Obwohl die Erklärung auf der rechten Seite einige Klarheit gebracht hat, ist immer noch nicht ganz klar, wie die genaue Übereinstimmung funktioniert. Also nehmen wir ein paar Beispiele und analysieren sie einzeln.</p>

<p>Der spezifische Code, in dem dieser reguläre Ausdruck auftaucht, ist:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$matches</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nb">preg_match_all</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">trim</span><span class="p">(</span><span class="nv">$selector</span><span class="p">)</span><span class="mf">.</span><span class="s1">' '</span><span class="p">,</span> <span class="nv">$matches</span><span class="p">,</span> <span class="no">PREG_SET_ORDER</span><span class="p">);</span>
</code></pre></div></div>

<p><em>Hinweis: Der Code wurde nicht übersetzt, da es sich um eine Programmiersprache handelt, die in der Regel nicht übersetzt wird.</em></p>

<p><code class="language-plaintext highlighter-rouge">preg_match_all</code> bedeutet, alle Zeichenketten zu erhalten, die dem Muster entsprechen. Wenn es gibt:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">preg_match_all</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">,</span> <span class="s2">"abcdabc"</span><span class="p">,</span> <span class="nv">$matches</span><span class="p">)</span>
</code></pre></div></div>

<p>(Der Code bleibt unverändert, da es sich um eine PHP-Funktion handelt, die in der Regel nicht übersetzt wird.)</p>

<p>Der erste Parameter ist das Muster, der zweite Parameter ist die Zeichenkette, die abgeglichen werden soll, und der dritte Parameter ist die Ergebnisreferenz. Nach der Ausführung enthält das <code class="language-plaintext highlighter-rouge">$matches</code>-Array zwei <code class="language-plaintext highlighter-rouge">abc</code>.</p>

<p>Mit diesem Verständnis im Hinterkopf passt der Ausdruck <code class="language-plaintext highlighter-rouge">div &gt; ul</code> im obigen Bild nur auf die ersten vier Zeichen <code class="language-plaintext highlighter-rouge">div &gt;</code>. Unterstützt <code class="language-plaintext highlighter-rouge">regex101</code> nicht <code class="language-plaintext highlighter-rouge">preg_match_all</code>? Zum Glück reicht es aus, einen Modifikator namens <code class="language-plaintext highlighter-rouge">g</code> hinzuzufügen:</p>

<p>Durch das Hinzufügen von <code class="language-plaintext highlighter-rouge">g</code> wird alles übereinstimmende gefunden, anstatt beim ersten Treffer zurückzukehren.</p>

<p>Nachdem wir es hinzugefügt haben, haben wir <code class="language-plaintext highlighter-rouge">div &gt; ul</code> abgeglichen:</p>

<p>Auf der rechten Seite ist zu sehen, dass im ersten Match, also <code class="language-plaintext highlighter-rouge">div</code>, wir mit den Regeln der ersten Gruppe <code class="language-plaintext highlighter-rouge">div</code> gematcht haben und dann mit den Regeln der siebten Gruppe das Leerzeichen ` ` gematcht haben.</p>

<p>Lassen Sie uns nun die Erklärung der ersten Gruppe von Regeln betrachten:</p>

<p>In diesem langen Ausdruck wird der erste Klammerausdruck als erste Gruppe von Regeln bezeichnet. Dies ist eine Erfassungsgruppe. Die Klammern selbst werden nicht abgeglichen, sondern dienen der Gruppierung. <code class="language-plaintext highlighter-rouge">[]</code> steht für eine Zeichenmenge, und die darin enthaltenen Regeln beschreiben, wie diese Zeichenmenge aussieht. Diese Zeichenmenge enthält:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\w</code> steht für Groß- und Kleinbuchstaben, die Zahlen von 0 bis 9 sowie den Unterstrich.</li>
  <li><code class="language-plaintext highlighter-rouge">-:</code> repräsentiert direkt diese beiden Zeichen in der Menge.</li>
  <li><code class="language-plaintext highlighter-rouge">\*</code> da <code class="language-plaintext highlighter-rouge">*</code> ein reserviertes Zeichen in regulären Ausdrücken ist und eine spezielle Bedeutung hat, muss es mit <code class="language-plaintext highlighter-rouge">\</code> maskiert werden, um ein normales <code class="language-plaintext highlighter-rouge">*</code>-Zeichen darzustellen.</li>
  <li><code class="language-plaintext highlighter-rouge">&gt;</code> stellt einfach das Zeichen <code class="language-plaintext highlighter-rouge">&gt;</code> dar.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">[\w-:\*&gt;]*</code> 最后的 <code class="language-plaintext highlighter-rouge">*</code> 表示前面的字符可以出现 0 次或无数次，但要尽可能多地匹配。之所以能匹配 <code class="language-plaintext highlighter-rouge">div</code> 是因为 <code class="language-plaintext highlighter-rouge">\w</code> 匹配了 <code class="language-plaintext highlighter-rouge">d</code>、<code class="language-plaintext highlighter-rouge">i</code>、<code class="language-plaintext highlighter-rouge">v</code>。之所以不再继续匹配后面的空格，是因为空格没有出现在 <code class="language-plaintext highlighter-rouge">[]</code> 中。捕获组的意思是，这组匹配会出现在结果数组中。相对应的还有非捕获组，语法是 <code class="language-plaintext highlighter-rouge">(?:)</code>。上面的 <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> 如果不需要这组结果，可以记为 <code class="language-plaintext highlighter-rouge">(?:[\w-:\*&gt;]*)</code>。</p>

<p>Warum dann nicht einfach keine Klammern verwenden, wenn sie nicht im Ergebnis erscheinen sollen? Klammern dienen der Gruppierung, und Gruppierung ist durchaus sinnvoll. Weitere Informationen finden Sie unter <a href="http://stackoverflow.com/questions/3512471/what-is-a-non-capturing-group">„What is a non capturing group? (?:) - StackOverflow“</a>.</p>

<p>Nachdem wir besprochen haben, dass <code class="language-plaintext highlighter-rouge">div</code> die erste Gruppe von Regeln erfüllt, wollen wir nun erklären, warum das Leerzeichen ` ` die Regeln der siebten Gruppe erfüllt.</p>

<p><code class="language-plaintext highlighter-rouge">[\/, ]</code> bedeutet, dass eines dieser vier Zeichen übereinstimmt, und <code class="language-plaintext highlighter-rouge">+</code> bedeutet, dass das vorherige Muster ein- oder mehrmals auftritt, wobei die Anzahl der Übereinstimmungen so groß wie möglich sein soll. Da diese vier Zeichen ein Leerzeichen enthalten, wird unser Leerzeichen übereinstimmen. Da das nächste Zeichen nach <code class="language-plaintext highlighter-rouge">div </code> ein <code class="language-plaintext highlighter-rouge">&gt;</code> ist, wird die Regel der siebten Gruppe nicht mehr erfüllt und die Übereinstimmung wird nicht fortgesetzt.</p>

<p>Ich habe verstanden, wie die Übereinstimmung von <code class="language-plaintext highlighter-rouge">div</code> funktioniert. Aber warum haben die Regeln der zweiten bis sechsten Gruppe die Leerzeichen hier nicht erfasst, sondern sie der siebten Gruppe überlassen?</p>

<p>Erklärung zum zweiten Teil:</p>

<p>Zunächst bedeutet <code class="language-plaintext highlighter-rouge">(?:)</code>, dass dies eine nicht erfassende Gruppe ist. Das <code class="language-plaintext highlighter-rouge">?</code> am Ende zeigt an, dass das vorherige Muster 0 oder 1 Mal auftreten kann. Daher kann der obige Ausdruck <code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code> vorhanden sein oder nicht. Wenn wir die äußeren Modifikatoren entfernen, bleibt <code class="language-plaintext highlighter-rouge">\#([\w-]+)|\.([\w-]+)</code> übrig, wobei das <code class="language-plaintext highlighter-rouge">|</code> in der Mitte ein “oder” darstellt, was bedeutet, dass eines der beiden Muster erfüllt sein muss. In <code class="language-plaintext highlighter-rouge">\#([\w-]+)</code> passt <code class="language-plaintext highlighter-rouge">\#</code> auf das <code class="language-plaintext highlighter-rouge">#</code>-Zeichen, und <code class="language-plaintext highlighter-rouge">[\w-]+</code> passt auf andere Zeichen. Im zweiten Teil passt <code class="language-plaintext highlighter-rouge">\.([\w-]+)</code> auf das <code class="language-plaintext highlighter-rouge">.</code>-Zeichen.</p>

<p>Daher können die Gruppen 2 bis 6 möglicherweise nicht erfüllt werden, da Leerzeichen nicht die erforderlichen Anfangszeichen für diese Gruppen sind. Da diese Gruppen jedoch einen <code class="language-plaintext highlighter-rouge">?</code>-Modifikator haben, ist es in Ordnung, wenn sie nicht erfüllt werden, und daher wird zur siebten Gruppe gesprungen.</p>

<p>Der <code class="language-plaintext highlighter-rouge">&gt;</code> nach <code class="language-plaintext highlighter-rouge">div &gt; ul</code> bleibt gleich:</p>

<p>Die erste Regelgruppe <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> hat <code class="language-plaintext highlighter-rouge">&gt;</code> erfasst, und die siebte Regelgruppe <code class="language-plaintext highlighter-rouge">([\/, ]+)</code> hat ein Leerzeichen erfasst. Anschließend wird <code class="language-plaintext highlighter-rouge">ul</code> wie <code class="language-plaintext highlighter-rouge">div</code> behandelt.</p>

<h3 id="übereinstimmung-mit-answer-4185009--table--tbody--tdanswercell--div--pre">Übereinstimmung mit <code class="language-plaintext highlighter-rouge">#answer-4185009 &gt; table &gt; tbody &gt; td.answercell &gt; div &gt; pre</code></h3>

<p>Als nächstes kommt ein etwas komplexerer Selektor <code class="language-plaintext highlighter-rouge">#answer-4185009 &gt; table &gt; tbody &gt; td.answercell &gt; div &gt; pre</code> (du kannst auch https://regex101.com/ öffnen und dies dort einfügen, um es zu testen):</p>

<p>Dies ist ein Kopieren und Einfügen aus Chrome:</p>

<p>Erste Übereinstimmung:</p>

<p>Da in der ersten Gruppe die Zeichenmenge <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> innerhalb der <code class="language-plaintext highlighter-rouge">[]</code> kein Zeichen enthält, das mit <code class="language-plaintext highlighter-rouge">#</code> übereinstimmt, und das abschließende <code class="language-plaintext highlighter-rouge">*</code> die Möglichkeit bietet, 0 oder mehr Vorkommen zu finden, wird hier 0 Mal übereinstimmen. Anschließend beschreibt die zweite Regel:</p>

<p>Wie bereits oben analysiert wurde, schauen wir uns direkt den Teil vor dem <code class="language-plaintext highlighter-rouge">|</code> an, nämlich <code class="language-plaintext highlighter-rouge">\#([\w-]+)</code>. Hier wird <code class="language-plaintext highlighter-rouge">\#</code> verwendet, um das <code class="language-plaintext highlighter-rouge">#</code> zu matchen, und <code class="language-plaintext highlighter-rouge">[\w-]+</code> matcht <code class="language-plaintext highlighter-rouge">answer-4185009</code>. Der darauf folgende Teil <code class="language-plaintext highlighter-rouge">\.([\w-]+)</code> würde angewendet werden, wenn es sich um <code class="language-plaintext highlighter-rouge">.answer-4185009</code> handeln würde.</p>

<p>Als nächstes betrachten wir die Übereinstimmung <code class="language-plaintext highlighter-rouge">td.answercell</code>,</p>

<p>Die erste Gruppe der Regel <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> hat <code class="language-plaintext highlighter-rouge">td</code> abgeglichen, während der hintere Teil des zweiten großen Abschnitts <code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code>, nämlich <code class="language-plaintext highlighter-rouge">\.([\w-]+)</code>, <code class="language-plaintext highlighter-rouge">.answercell</code> abgeglichen hat.</p>

<p>Die Analyse dieses Selektors endet hier.</p>

<h3 id="übereinstimmung-mit-ahrefhttpgooglecom">Übereinstimmung mit <code class="language-plaintext highlighter-rouge">a[href="http://google.com/"]</code></h3>

<p>Als Nächstes passen wir den Selektor <code class="language-plaintext highlighter-rouge">a[href="http://google.com/"]</code> an:</p>

<p>Schauen wir uns den dritten großen Block an:</p>

<p>Der dritte große Ausdruck lautet <code class="language-plaintext highlighter-rouge">(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?</code>. Zunächst bedeutet das äußerste <code class="language-plaintext highlighter-rouge">(?:)</code>, dass es sich um eine nicht erfassende Gruppe handelt. Das <code class="language-plaintext highlighter-rouge">?</code> am Ende zeigt an, dass dieser gesamte Block 0 oder 1 Mal vorkommen kann. Wenn wir dies entfernen, erhalten wir <code class="language-plaintext highlighter-rouge">\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\]</code>. <code class="language-plaintext highlighter-rouge">\[</code> entspricht dem Zeichen <code class="language-plaintext highlighter-rouge">[</code>. <code class="language-plaintext highlighter-rouge">@?</code> bedeutet, dass das Zeichen <code class="language-plaintext highlighter-rouge">@</code> optional ist. Die nächste Gruppe <code class="language-plaintext highlighter-rouge">(!?[\w-:]+)</code> zeigt an, dass das Zeichen <code class="language-plaintext highlighter-rouge">!</code> optional ist, und <code class="language-plaintext highlighter-rouge">[\w-:]+</code> entspricht <code class="language-plaintext highlighter-rouge">href</code>. Die folgende Gruppe <code class="language-plaintext highlighter-rouge">(?:([!*^$]?=)["']?(.*?)["']?)</code> ist eine nicht erfassende Gruppe. Wenn wir die äußerste Schicht entfernen, erhalten wir <code class="language-plaintext highlighter-rouge">([!*^$]?=)["']?(.*?)["']?</code>. Hier bedeutet <code class="language-plaintext highlighter-rouge">([!*^$]?=)</code>, dass <code class="language-plaintext highlighter-rouge">[!*^$]?</code> 0 oder 1 Zeichen aus den eckigen Klammern <code class="language-plaintext highlighter-rouge">[]</code> entspricht. Dann folgt das direkte Zeichen <code class="language-plaintext highlighter-rouge">=</code>. Anschließend entspricht <code class="language-plaintext highlighter-rouge">["']?(.*?)["']?</code> dem Ausdruck <code class="language-plaintext highlighter-rouge">"http://google.com/"</code>. <code class="language-plaintext highlighter-rouge">["']?</code> bedeutet, dass entweder <code class="language-plaintext highlighter-rouge">"</code> oder <code class="language-plaintext highlighter-rouge">'</code> oder keines von beiden übereinstimmt. Wenn wir diese äußerste Schicht entfernen, erhalten wir <code class="language-plaintext highlighter-rouge">(.*?)</code>, was <code class="language-plaintext highlighter-rouge">http://google.com/</code> entspricht. Hier bedeutet <code class="language-plaintext highlighter-rouge">*?</code>, dass so wenig wie möglich übereinstimmen soll, d.h., wenn ein <code class="language-plaintext highlighter-rouge">"</code> oder <code class="language-plaintext highlighter-rouge">'</code> vorhanden ist, soll es dem nachfolgenden Ausdruck <code class="language-plaintext highlighter-rouge">["']?</code> überlassen werden. Daher wird nicht <code class="language-plaintext highlighter-rouge">http://google.com/"</code> übereinstimmen, sondern nur <code class="language-plaintext highlighter-rouge">http://google.com/</code>. Somit entspricht der gesamte Selektor <code class="language-plaintext highlighter-rouge">a[href="http://google.com/</code>.</p>

<p>”]` beendet die Übereinstimmung.</p>

<h3 id="zusammenfassung">Zusammenfassung</h3>

<p>Endlich verstanden! Lassen Sie uns das noch einmal klarstellen. Zunächst besteht der gesamte komplexe Ausdruck <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)(?:\#([\w-]+)|\.([\w-]+))?(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?([\/, ]+)</code> aus vier Hauptteilen:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code></li>
  <li><code class="language-plaintext highlighter-rouge">(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?</code></li>
  <li><code class="language-plaintext highlighter-rouge">([\/, ]+)</code></li>
</ul>

<p>(Dieser Codeblock enthält reguläre Ausdrücke, die nicht übersetzt werden sollten, da sie spezifische Muster für die Textverarbeitung darstellen.)</p>

<p>Der komplexeste dritte Teil besteht wiederum aus diesen Komponenten:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\[</code></li>
  <li><code class="language-plaintext highlighter-rouge">(!?[\w-:]+)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(?:([!*^$]?=)["']?(.*?)["']?)?</code></li>
  <li><code class="language-plaintext highlighter-rouge">\]</code></li>
</ul>

<p>Daher können all diese ausreichend kleinen Teile einzeln angegangen werden. Dann sucht man sich ein paar Beispiele mehr, schaut sich an, wie jedes Beispiel passt, und analysiert es gleichzeitig mit der Erklärung auf https://regex101.com/. So hat man diesen scheinbar komplexen regulären Ausdruck verstanden – es stellt sich heraus, dass er ein Papiertiger ist!</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-de" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
