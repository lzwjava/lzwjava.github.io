<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>GFW, Proxy-APIs und VPN-Erkennung</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>GFW, Proxy-APIs und VPN-Erkennung | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="GFW, Proxy-APIs und VPN-Erkennung" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="de" />
<meta name="description" content="Inhaltsverzeichnis" />
<meta property="og:description" content="Inhaltsverzeichnis" />
<link rel="canonical" href="https://lzwjava.github.io/proxy-ban-de" />
<meta property="og:url" content="https://lzwjava.github.io/proxy-ban-de" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-07T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="GFW, Proxy-APIs und VPN-Erkennung" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2025-01-07T00:00:00+08:00","datePublished":"2025-01-07T00:00:00+08:00","description":"Inhaltsverzeichnis","headline":"GFW, Proxy-APIs und VPN-Erkennung","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/proxy-ban-de"},"url":"https://lzwjava.github.io/proxy-ban-de"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=57b6640df23258b28086850a3420290fcb144992">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=57b6640df23258b28086850a3420290fcb144992" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       GFW, Proxy-APIs und VPN-Erkennung | Original, von KI übersetzt
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/de/2025-01-07-proxy-ban-de.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsde2025-01-07-proxy-ban-de.md</span> -->
      

      <!-- <span>2025-01-07-proxy-ban-de.md</span> -->

      
        

        
          
          <a href="#" class="button">2025.01</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/proxy-ban-en" >English</option>
        <option value="/proxy-ban-zh" >中文</option>
        <option value="/proxy-ban-ja" >日本語</option>
        <option value="/proxy-ban-es" >Español</option>
        <option value="/proxy-ban-hi" >हिंदी</option>
        <option value="/proxy-ban-fr" >Français</option>
        <option value="/proxy-ban-de" selected>Deutsch</option>
        <option value="/proxy-ban-ar" >العربية</option>
        <option value="/proxy-ban-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <h3 id="inhaltsverzeichnis">Inhaltsverzeichnis</h3>

<ol>
  <li><a href="#können-apis-in-proxy-servern-gfw-sperren-umgehen">Können APIs in Proxy-Servern GFW-Sperren umgehen?</a>
    <ul>
      <li>Mischung aus Proxy- und API-Verkehr vermeidet GFW-Sperren</li>
      <li>GFW unterscheidet zwischen Proxy- und normalem HTTP/HTTPS-Verkehr</li>
      <li>GFW sperrt wahrscheinlich basierend auf ausschließlich Proxy-Verkehr</li>
      <li>GFW nutzt ein Zeitfenster für die Verkehrsdatenanalyse</li>
      <li>Regelmäßiger Zugriff auf die API kann Erkennung verhindern</li>
    </ul>
  </li>
  <li><a href="#wie-die-great-firewall-gfw-funktioniert">Wie die Great Firewall (GFW) funktioniert.</a>
    <ul>
      <li>GFW protokolliert Anfragen mit Quellen- und Zieldaten</li>
      <li>Sperrt IPs, die mit illegalen Aktivitäten in Verbindung stehen</li>
      <li>Nutzt Regeln zur Erkennung spezifischer Protokolle</li>
      <li>Kann basierend auf dem Prozentsatz illegaler Anfragen sperren</li>
      <li>Setzt KI für intelligente Verkehrsmustererkennung ein</li>
    </ul>
  </li>
  <li><a href="#analyse-der-chatgpt-ios-vpn-erkennung">Analyse der ChatGPT-iOS-VPN-Erkennung</a>
    <ul>
      <li>ChatGPT iOS funktioniert nun mit einigen VPNs</li>
      <li>Zugriff hängt vom Standort des VPN-Servers ab</li>
      <li>Erkennung basiert auf spezifischen IP-Adressen</li>
      <li>Einige Cloud-Provider-IPs sind gesperrt</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="können-apis-in-proxy-servern-gfw-sperren-umgehen">Können APIs in Proxy-Servern GFW-Sperren umgehen?</h2>

<p>Ich betreibe einen einfachen Server auf meiner Shadowsocks-Instanz mit folgendem Code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">jsonify</span>
<span class="kn">from</span> <span class="nn">flask_cors</span> <span class="kn">import</span> <span class="n">CORS</span>
<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">CORS</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>  <span class="c1"># CORS für alle Routen aktivieren
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/bandwidth'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">get_bandwidth</span><span class="p">():</span>
    <span class="c1"># Führt den vnstat-Befehl aus, um die 5-Minuten-Intervall-Verkehrsstatistiken für eth0 zu erhalten
</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="n">run</span><span class="p">([</span><span class="s">'vnstat'</span><span class="p">,</span> <span class="s">'-i'</span><span class="p">,</span> <span class="s">'eth0'</span><span class="p">,</span> <span class="s">'-5'</span><span class="p">,</span> <span class="s">'--json'</span><span class="p">],</span> <span class="n">capture_output</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">stdout</span>

    <span class="c1"># Gibt die erfassten Daten als JSON-Antwort zurück
</span>    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'0.0.0.0'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
</code></pre></div></div>

<p>Und ich nutze nginx, um Port 443 wie folgt bereitzustellen:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
    listen 443 ssl<span class="p">;</span>
    server_name www.some-domain.xyz<span class="p">;</span>

    ssl_certificate /etc/letsencrypt/live/www.some-domain.xyz/fullchain.pem<span class="p">;</span> <span class="c"># verwaltet von</span>
    <span class="c"># ...</span>
    location / <span class="o">{</span>
        proxy_pass http://127.0.0.1:5000/<span class="p">;</span>
        <span class="c"># ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Dieses Serverprogramm stellt Netzwerkdaten bereit, und ich nutze den Server als meinen Proxy-Server, um meinen Online-Status auf meinem Blog mithilfe der Netzwerkdaten anzuzeigen.</p>

<p>Interessanterweise wurde der Server bisher nicht von der Great Firewall (GFW) oder anderen Netzwerkkontrollsystemen gesperrt – und das bereits seit mehreren Tagen. Normalerweise würde der von mir eingerichtete Proxy-Server innerhalb von ein oder zwei Tagen gesperrt werden. Der Server führt ein Shadowsocks-Programm auf einem Port wie 51939 aus, sodass er mit gemischtem Shadowsocks- und normalem API-Verkehr arbeitet. Diese Mischung scheint die GFW dazu zu bringen, den Server nicht als dedizierten Proxy, sondern als normalen Server einzustufen, wodurch eine Sperrung der IP verhindert wird.</p>

<p>Diese Beobachtung ist faszinierend. Es scheint, dass die GFW spezifische Logik verwendet, um Proxy-Verkehr von normalem Verkehr zu unterscheiden. Während viele Websites wie Twitter und YouTube in China blockiert sind, bleiben zahlreiche ausländische Websites – wie die von internationalen Universitäten und Unternehmen – zugänglich.</p>

<p>Dies deutet darauf hin, dass die GFW wahrscheinlich auf Regeln basiert, die zwischen normalem HTTP/HTTPS-Verkehr und Proxy-Verkehr unterscheiden. Server, die beide Verkehrstypen abwickeln, scheinen Sperren zu entgehen, während Server, die ausschließlich Proxy-Verkehr verarbeiten, eher blockiert werden.</p>

<p>Eine Frage ist, welchen Zeitraum die GFW für die Datensammlung zur Sperrung verwendet – ob es sich um einen Tag oder eine Stunde handelt. Während dieses Zeitraums erkennt sie, ob der Verkehr ausschließlich von einem Proxy stammt. Falls ja, wird die IP des Servers gesperrt.</p>

<p>Ich besuche meinen Blog oft, um zu überprüfen, was ich geschrieben habe, aber in den kommenden Wochen werde ich mich auf andere Aufgaben konzentrieren, statt Blogbeiträge zu verfassen. Dadruch verringert sich mein Zugriff auf die <code class="language-plaintext highlighter-rouge">bandwidth</code>-API über Port 443. Falls ich feststelle, dass ich erneut gesperrt werde, sollte ich ein Programm schreiben, das regelmäßig auf diese API zugreift, um die GFW zu täuschen.</p>

<hr />

<h2 id="wie-die-great-firewall-gfw-funktioniert">Wie die Great Firewall (GFW) funktioniert.</h2>

<h3 id="schritt-1-protokollierung-von-anfragen">Schritt 1: Protokollierung von Anfragen</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Datenbank zur Speicherung von Anfragedaten
</span><span class="n">request_log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Funktion zur Protokollierung von Anfragen
</span><span class="k">def</span> <span class="nf">log_request</span><span class="p">(</span><span class="n">source_ip</span><span class="p">,</span> <span class="n">target_ip</span><span class="p">,</span> <span class="n">target_port</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
    <span class="n">request_log</span><span class="p">.</span><span class="n">append</span><span class="p">({</span>
        <span class="s">'source_ip'</span><span class="p">:</span> <span class="n">source_ip</span><span class="p">,</span>
        <span class="s">'target_ip'</span><span class="p">:</span> <span class="n">target_ip</span><span class="p">,</span>
        <span class="s">'target_port'</span><span class="p">:</span> <span class="n">target_port</span><span class="p">,</span>
        <span class="s">'body'</span><span class="p">:</span> <span class="n">body</span><span class="p">,</span>
        <span class="s">'timestamp'</span><span class="p">:</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
    <span class="p">})</span>
</code></pre></div></div>

<p>Die Funktion <code class="language-plaintext highlighter-rouge">log_request</code> zeichnet eingehende Anfragen mit wesentlichen Informationen wie Quellen-IP, Ziel-IP, Ziel-Port, Anfragekörper und Zeitstempel auf.</p>

<h3 id="schritt-2-überprüfung-und-sperrung-von-ips">Schritt 2: Überprüfung und Sperrung von IPs</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Funktion zur Überprüfung von Anfragen und Sperrung von IPs
</span><span class="k">def</span> <span class="nf">check_and_ban_ips</span><span class="p">():</span>
    <span class="n">banned_ips</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Iteration über alle protokollierten Anfragen
</span>    <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">request_log</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="n">banned_ips</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s">'target_ip'</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">banned_ips</span><span class="p">.</span><span class="n">discard</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s">'target_ip'</span><span class="p">])</span>

    <span class="c1"># Sperrung aller identifizierten IPs
</span>    <span class="n">ban_ips</span><span class="p">(</span><span class="n">banned_ips</span><span class="p">)</span>
</code></pre></div></div>

<p>Die Funktion <code class="language-plaintext highlighter-rouge">check_and_ban_ips</code> durchläuft alle protokollierten Anfragen, identifiziert und sperrt IPs, die mit illegalen Aktivitäten in Verbindung stehen.</p>

<h3 id="schritt-3-definition-illegaler-anfragen">Schritt 3: Definition illegaler Anfragen</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Funktion zur Simulation der Überprüfung, ob eine Anfrage illegal ist
</span><span class="k">def</span> <span class="nf">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># Platzhalter für tatsächliche Logik zur Überprüfung illegaler Anfragen
</span>    <span class="c1"># Beispiel: Überprüfung des Anfragekörpers oder des Ziels
</span>    <span class="k">return</span> <span class="s">"illegal"</span> <span class="ow">in</span> <span class="n">request</span><span class="p">[</span><span class="s">'body'</span><span class="p">]</span>
</code></pre></div></div>

<p>Hier überprüft <code class="language-plaintext highlighter-rouge">is_illegal</code>, ob der Anfragekörper das Wort “illegal” enthält. Dies kann auf komplexere Logik erweitert werden, je nachdem, was als illegale Aktivität gilt.</p>

<h3 id="schritt-4-sperrung-identifizierter-ips">Schritt 4: Sperrung identifizierter IPs</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Funktion zur Sperrung einer Liste von IPs
</span><span class="k">def</span> <span class="nf">ban_ips</span><span class="p">(</span><span class="n">ip_set</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">ip_set</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Sperre IP: </span><span class="si">{</span><span class="n">ip</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Sobald illegale IPs identifiziert wurden, sperrt die Funktion <code class="language-plaintext highlighter-rouge">ban_ips</code> diese, indem sie deren IP-Adressen ausgibt (oder in einem echten System blockiert).</p>

<h3 id="schritt-5-alternative-methode-zur-überprüfung-und-sperrung-von-ips-basierend-auf-80--illegalen-anfragen">Schritt 5: Alternative Methode zur Überprüfung und Sperrung von IPs basierend auf 80 % illegalen Anfragen</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Funktion zur Überprüfung von Anfragen und Sperrung von IPs basierend auf 80 % illegalen Anfragen
</span><span class="k">def</span> <span class="nf">check_and_ban_ips</span><span class="p">():</span>
    <span class="n">banned_ips</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">illegal_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_requests</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Iteration über alle protokollierten Anfragen
</span>    <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">request_log</span><span class="p">:</span>
        <span class="n">total_requests</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="n">illegal_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Wenn 80 % oder mehr der Anfragen illegal sind, werden diese IPs gesperrt
</span>    <span class="k">if</span> <span class="n">total_requests</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">illegal_count</span> <span class="o">/</span> <span class="n">total_requests</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.8</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">request_log</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
                <span class="n">banned_ips</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s">'target_ip'</span><span class="p">])</span>

    <span class="c1"># Sperrung aller identifizierten IPs
</span>    <span class="n">ban_ips</span><span class="p">(</span><span class="n">banned_ips</span><span class="p">)</span>
</code></pre></div></div>

<p>Diese alternative Methode bewertet, ob eine IP gesperrt werden sollte, basierend auf dem Prozentsatz illegaler Anfragen. Wenn 80 % oder mehr der Anfragen von einer IP illegal sind, wird sie gesperrt.</p>

<h3 id="schritt-6-erweiterte-überprüfung-illegaler-anfragen-z-b-shadowsocks--und-trojan-protokoll-erkennung">Schritt 6: Erweiterte Überprüfung illegaler Anfragen (z. B. Shadowsocks- und Trojan-Protokoll-Erkennung)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># Überprüft, ob die Anfrage das Shadowsocks-Protokoll verwendet (Körper enthält binäre Daten)
</span>    <span class="k">if</span> <span class="n">request</span><span class="p">[</span><span class="s">'target_port'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">443</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_trojan</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">is_shadowsocks</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>Die Funktion <code class="language-plaintext highlighter-rouge">is_illegal</code> überprüft nun auch spezifische Protokolle wie Shadowsocks und Trojan:</p>
<ul>
  <li><strong>Shadowsocks</strong>: Es könnte nach verschlüsselten oder binären Daten im Anfragekörper gesucht werden.</li>
  <li><strong>Trojan</strong>: Wenn die Anfrage über Port 443 (HTTPS) erfolgt und bestimmte Muster aufweist (z. B. Trojan-Verkehrscharakteristika), wird sie als illegal markiert.</li>
</ul>

<h3 id="schritt-7-beispiel-für-legale-anfragen">Schritt 7: Beispiel für legale Anfragen</h3>

<p>Anfragen wie <code class="language-plaintext highlighter-rouge">GET https://some-domain.xyz/bandwidth</code> sind zweifellos legal und lösen keinen Sperrmechanismus aus.</p>

<h3 id="schritt-8-verkehrscharakteristika-von-proxy-servern">Schritt 8: Verkehrscharakteristika von Proxy-Servern</h3>

<p>Proxy-Server weisen völlig andere Verkehrscharakteristika auf als normale Web- oder API-Server. Die GFW muss zwischen normalem Webserver-Verkehr und Proxy-Server-Verkehr unterscheiden können, die völlig unterschiedlich aussehen können.</p>

<h3 id="schritt-9-maschinelles-lernen-und-ki-modelle-für-intelligente-erkennung">Schritt 9: Maschinelles Lernen und KI-Modelle für intelligente Erkennung</h3>

<p>Angesichts der Vielzahl von Anfragen und Antworten, die durch das Internet gehen, könnte die GFW KI und maschinelle Lernmodelle einsetzen, um Verkehrsmuster zu analysieren und illegalen Verkehr intelligent zu erkennen. Durch das Training des Systems an einer Vielzahl von Verkehrstypen und den Einsatz fortschrittlicher Techniken könnte es Verkehr effektiver sperren oder filtern, basierend auf beobachteten Mustern.</p>

<hr />

<h2 id="update">Update</h2>

<p>Trotz meiner Bemühungen wird mein Proxy-Server weiterhin gesperrt. Um dies zu umgehen, habe ich eine Problemumgehung mit der Funktion „Reverse-IP“ von Digital Ocean implementiert, die es mir ermöglicht, schnell eine neue IP-Adresse zuzuweisen, sobald eine Sperrung auftritt.</p>

<hr />

<h2 id="analyse-der-chatgpt-ios-vpn-erkennung">Analyse der ChatGPT-iOS-VPN-Erkennung</h2>

<p><em>26.12.2024</em></p>

<p>Heute habe ich entdeckt, dass die ChatGPT-iOS-App nun das Einloggen mit einem VPN in China ermöglicht. Früher wurde eine Sperrmeldung angezeigt, wie im folgenden Beispiel:</p>

<p>Allerdings funktioniert es seit heute problemlos mit einem VPN.</p>

<p>Ich erinnere mich, dass bei der ersten Veröffentlichung der ChatGPT-iOS-App die Nutzung mit einem VPN kein Problem darstellte. Später wurde die VPN-Erkennung strenger, sodass ein Login schwierig wurde. Zum Glück scheint diese Einschränkung kürzlich gelockert worden zu sein.</p>

<p>Bei weiteren Tests stellte ich fest, dass ich mit einem DigitalOcean-VPN in der Region Singapur nicht auf die App zugreifen konnte. Bei der Nutzung von VPNs aus Taiwan oder dem Vereinigten Königreich (bereitgestellt von https://zhs.cloud) funktionierte es jedoch einwandfrei.</p>

<p>Es scheint, dass die ChatGPT-iOS-VPN-Erkennung auf bestimmten IP-Adressen basiert. Einige Cloud-Provider oder bestimmte IP-Adressen sind gesperrt, was das inkonsistente Verhalten je nach Standort des VPN-Servers erklären könnte.</p>

<p><img src="assets/images/chatgpt/block.jpg" alt="" class="responsive" /></p>

<p><img src="assets/images/chatgpt/c1.png" alt="" class="responsive" /></p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-de" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
