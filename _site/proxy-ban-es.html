<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>GFW, APIs de Proxy, Detección de VPN</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>GFW, APIs de Proxy, Detección de VPN | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="GFW, APIs de Proxy, Detección de VPN" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="es" />
<meta name="description" content="Tabla de Contenidos" />
<meta property="og:description" content="Tabla de Contenidos" />
<link rel="canonical" href="https://lzwjava.github.io/proxy-ban-es" />
<meta property="og:url" content="https://lzwjava.github.io/proxy-ban-es" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-07T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="GFW, APIs de Proxy, Detección de VPN" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2025-01-07T00:00:00+08:00","datePublished":"2025-01-07T00:00:00+08:00","description":"Tabla de Contenidos","headline":"GFW, APIs de Proxy, Detección de VPN","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/proxy-ban-es"},"url":"https://lzwjava.github.io/proxy-ban-es"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=fac2831b705ac79d2f040311598ff02f8746df7d">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=fac2831b705ac79d2f040311598ff02f8746df7d" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       GFW, APIs de Proxy, Detección de VPN | Original, traducido por IA
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/es/2025-01-07-proxy-ban-es.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postses2025-01-07-proxy-ban-es.md</span> -->
      

      <!-- <span>2025-01-07-proxy-ban-es.md</span> -->

      
        

        
          
          <a href="#" class="button">2025.01</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/proxy-ban-en" >English</option>
        <option value="/proxy-ban-zh" >中文</option>
        <option value="/proxy-ban-ja" >日本語</option>
        <option value="/proxy-ban-es" selected>Español</option>
        <option value="/proxy-ban-hi" >हिंदी</option>
        <option value="/proxy-ban-fr" >Français</option>
        <option value="/proxy-ban-de" >Deutsch</option>
        <option value="/proxy-ban-ar" >العربية</option>
        <option value="/proxy-ban-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <h3 id="tabla-de-contenidos">Tabla de Contenidos</h3>

<ol>
  <li><a href="#¿pueden-las-apis-en-servidores-proxy-evitarlos-bloqueos-del-gfw">¿Pueden las APIs en servidores proxy evitar los bloqueos del GFW?</a>
    <ul>
      <li>Mezclar tráfico de proxy y API evita bloqueos del GFW</li>
      <li>GFW distingue entre tráfico de proxy y tráfico HTTP/HTTPS normal</li>
      <li>GFW probablemente bloquea según tráfico exclusivo de proxy</li>
      <li>GFW utiliza una ventana de tiempo para el análisis de tráfico</li>
      <li>Acceder regularmente a la API puede evitar la detección</li>
    </ul>
  </li>
  <li><a href="#cómo-funciona-el-gran-cortafuegos-gfw">Cómo funciona el Gran Cortafuegos (GFW).</a>
    <ul>
      <li>GFW registra solicitudes con datos de origen y destino</li>
      <li>Bloquea IPs asociadas con actividades ilegales</li>
      <li>Utiliza reglas para detectar protocolos específicos</li>
      <li>Puede bloquear según el porcentaje de solicitudes ilegales</li>
      <li>Emplea IA para la detección inteligente de patrones de tráfico</li>
    </ul>
  </li>
  <li><a href="#análisis-de-la-detecciónde-vpn-en-chatgpt-ios">Análisis de la detección de VPN en ChatGPT iOS</a>
    <ul>
      <li>ChatGPT iOS ahora funciona con algunas VPNs</li>
      <li>El acceso depende de la ubicación del servidor VPN</li>
      <li>La detección se basa en direcciones IP específicas</li>
      <li>Algunas IPs de proveedores en la nube están bloqueadas</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="pueden-las-apis-en-servidores-proxy-evitar-los-bloqueos-del-gfw">¿Pueden las APIs en servidores proxy evitar los bloqueos del GFW?</h2>

<p>Ejecuto un servidor simple en mi instancia de Shadowsocks con el siguiente código:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">jsonify</span>
<span class="kn">from</span> <span class="nn">flask_cors</span> <span class="kn">import</span> <span class="n">CORS</span>
<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">CORS</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>  <span class="c1"># Habilitar CORS para todas las rutas
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/bandwidth'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">get_bandwidth</span><span class="p">():</span>
    <span class="c1"># Ejecutar el comando vnstat para obtener estadísticas de tráfico en intervalos de 5 minutos para eth0
</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="n">run</span><span class="p">([</span><span class="s">'vnstat'</span><span class="p">,</span> <span class="s">'-i'</span><span class="p">,</span> <span class="s">'eth0'</span><span class="p">,</span> <span class="s">'-5'</span><span class="p">,</span> <span class="s">'--json'</span><span class="p">],</span> <span class="n">capture_output</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">stdout</span>

    <span class="c1"># Devolver los datos capturados como respuesta JSON
</span>    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'0.0.0.0'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
</code></pre></div></div>

<p>Y uso nginx para servir el puerto 443 como se muestra a continuación:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
    listen 443 ssl<span class="p">;</span>
    server_name www.some-domain.xyz<span class="p">;</span>

    ssl_certificate /etc/letsencrypt/live/www.some-domain.xyz/fullchain.pem<span class="p">;</span> <span class="c"># gestionado por</span>
    <span class="c"># ...</span>
    location / <span class="o">{</span>

        proxy_pass http://127.0.0.1:5000/<span class="p">;</span>
        <span class="c"># ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Este programa de servidor proporciona datos de red, y uso el servidor como mi servidor proxy, lo que me permite mostrar mi estado en línea en mi blog utilizando los datos de red.</p>

<p>Lo interesante es que el servidor no ha sido bloqueado por el Gran Cortafuegos (GFW) ni por otros sistemas de control de red en varios días. Normalmente, el servidor proxy que configuro suele ser bloqueado en uno o dos días. El servidor ejecuta un programa Shadowsocks en un puerto como 51939, por lo que opera con tráfico de Shadowsocks mezclado con tráfico normal de API. Esta mezcla parece hacer que el GFW crea que el servidor no es un proxy dedicado, sino un servidor normal, evitando así que bloquee la IP.</p>

<p>Esta observación es intrigante. Parece que el GFW utiliza una lógica específica para diferenciar el tráfico de proxy del tráfico normal. Aunque muchos sitios web como Twitter y YouTube están bloqueados en China, numerosos sitios extranjeros, como los de universidades y empresas internacionales, siguen siendo accesibles.</p>

<p>Esto sugiere que el GFW probablemente opera en función de reglas que distinguen entre el tráfico HTTP/HTTPS normal y el tráfico relacionado con proxy. Los servidores que manejan ambos tipos de tráfico parecen evitar los bloqueos, mientras que los servidores que solo manejan tráfico de proxy tienen más probabilidades de ser bloqueados.</p>

<p>Una pregunta es qué rango de tiempo utiliza el GFW para acumular datos con fines de bloqueo, ya sea un día o una hora. Durante este rango de tiempo, detecta si el tráfico proviene exclusivamente de un proxy. Si es así, la IP del servidor se bloquea.</p>

<p>A menudo visito mi blog para revisar lo que he escrito, pero en las próximas semanas, mi enfoque cambiará a otras tareas en lugar de escribir entradas en el blog. Esto reducirá mi acceso a la API <code class="language-plaintext highlighter-rouge">bandwidth</code> a través del puerto 443. Si descubro que vuelvo a ser bloqueado, debería escribir un programa para acceder regularmente a esta API y engañar al GFW.</p>

<hr />

<h2 id="cómo-funciona-el-gran-cortafuegos-gfw">Cómo funciona el Gran Cortafuegos (GFW).</h2>

<h3 id="paso-1-registrar-solicitudes">Paso 1: Registrar solicitudes</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Base de datos para almacenar datos de solicitudes
</span><span class="n">request_log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Función para registrar solicitudes
</span><span class="k">def</span> <span class="nf">log_request</span><span class="p">(</span><span class="n">source_ip</span><span class="p">,</span> <span class="n">target_ip</span><span class="p">,</span> <span class="n">target_port</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
    <span class="n">request_log</span><span class="p">.</span><span class="n">append</span><span class="p">({</span>
        <span class="s">'source_ip'</span><span class="p">:</span> <span class="n">source_ip</span><span class="p">,</span>
        <span class="s">'target_ip'</span><span class="p">:</span> <span class="n">target_ip</span><span class="p">,</span>
        <span class="s">'target_port'</span><span class="p">:</span> <span class="n">target_port</span><span class="p">,</span>
        <span class="s">'body'</span><span class="p">:</span> <span class="n">body</span><span class="p">,</span>
        <span class="s">'timestamp'</span><span class="p">:</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
    <span class="p">})</span>
</code></pre></div></div>

<p>La función <code class="language-plaintext highlighter-rouge">log_request</code> registra las solicitudes entrantes con información esencial como la IP de origen, IP de destino, puerto de destino, cuerpo de la solicitud y marca de tiempo.</p>

<h3 id="paso-2-verificar-y-bloquear-ips">Paso 2: Verificar y bloquear IPs</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Función para verificar solicitudes y bloquear IPs
</span><span class="k">def</span> <span class="nf">check_and_ban_ips</span><span class="p">():</span>
    <span class="n">banned_ips</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Iterar sobre todas las solicitudes registradas
</span>    <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">request_log</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="n">banned_ips</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s">'target_ip'</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">banned_ips</span><span class="p">.</span><span class="n">discard</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s">'target_ip'</span><span class="p">])</span>

    <span class="c1"># Aplicar bloqueos a todas las IPs identificadas
</span>    <span class="n">ban_ips</span><span class="p">(</span><span class="n">banned_ips</span><span class="p">)</span>
</code></pre></div></div>

<p>La función <code class="language-plaintext highlighter-rouge">check_and_ban_ips</code> recorre todas las solicitudes registradas, identificando y bloqueando IPs asociadas con actividades ilegales.</p>

<h3 id="paso-3-definir-qué-hace-que-una-solicitud-sea-ilegal">Paso 3: Definir qué hace que una solicitud sea ilegal</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Función para simular la verificación de si una solicitud es ilegal
</span><span class="k">def</span> <span class="nf">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># Marcador de posición para la lógica real de verificación de solicitudes ilegales
</span>    <span class="c1"># Por ejemplo, verificar el cuerpo de la solicitud o el destino
</span>    <span class="k">return</span> <span class="s">"illegal"</span> <span class="ow">in</span> <span class="n">request</span><span class="p">[</span><span class="s">'body'</span><span class="p">]</span>
</code></pre></div></div>

<p>Aquí, <code class="language-plaintext highlighter-rouge">is_illegal</code> verifica si el cuerpo de la solicitud contiene la palabra “illegal”. Esto puede expandirse a una lógica más sofisticada según lo que constituya una actividad ilegal.</p>

<h3 id="paso-4-bloquear-ips-identificadas">Paso 4: Bloquear IPs identificadas</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Función para bloquear una lista de IPs
</span><span class="k">def</span> <span class="nf">ban_ips</span><span class="p">(</span><span class="n">ip_set</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">ip_set</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Bloqueando IP: </span><span class="si">{</span><span class="n">ip</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Una vez identificadas las IPs ilegales, la función <code class="language-plaintext highlighter-rouge">ban_ips</code> las bloquea imprimiendo sus direcciones IP (o, en un sistema real, podría bloquearlas).</p>

<h3 id="paso-5-método-alternativo-para-verificar-y-bloquear-ips-según-el-80-de-solicitudes-ilegales">Paso 5: Método alternativo para verificar y bloquear IPs según el 80% de solicitudes ilegales</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Función para verificar solicitudes y bloquear IPs según el 80% de solicitudes ilegales
</span><span class="k">def</span> <span class="nf">check_and_ban_ips</span><span class="p">():</span>
    <span class="n">banned_ips</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">illegal_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_requests</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Iterar sobre todas las solicitudes registradas
</span>    <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">request_log</span><span class="p">:</span>
        <span class="n">total_requests</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="n">illegal_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Si el 80% o más de las solicitudes son ilegales, bloquear esas IPs
</span>    <span class="k">if</span> <span class="n">total_requests</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">illegal_count</span> <span class="o">/</span> <span class="n">total_requests</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.8</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">request_log</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
                <span class="n">banned_ips</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s">'target_ip'</span><span class="p">])</span>

    <span class="c1"># Aplicar bloqueos a todas las IPs identificadas
</span>    <span class="n">ban_ips</span><span class="p">(</span><span class="n">banned_ips</span><span class="p">)</span>
</code></pre></div></div>

<p>Este método alternativo evalúa si una IP debe ser bloqueada según el porcentaje de solicitudes ilegales. Si el 80% o más de las solicitudes de una IP son ilegales, se bloquea.</p>

<h3 id="paso-6-verificación-mejorada-de-solicitudes-ilegales-ejemplo-detección-de-protocolos-shadowsocks-y-trojan">Paso 6: Verificación mejorada de solicitudes ilegales (ejemplo: detección de protocolos Shadowsocks y Trojan)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># Verificar si la solicitud utiliza el protocolo Shadowsocks (el cuerpo contiene datos similares a binarios)
</span>    <span class="k">if</span> <span class="n">request</span><span class="p">[</span><span class="s">'target_port'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">443</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_trojan</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">is_shadowsocks</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>La función <code class="language-plaintext highlighter-rouge">is_illegal</code> ahora también verifica protocolos específicos como Shadowsocks y Trojan:</p>
<ul>
  <li><strong>Shadowsocks</strong>: Podríamos verificar datos cifrados o similares a binarios en el cuerpo de la solicitud.</li>
  <li><strong>Trojan</strong>: Si la solicitud llega a través del puerto 443 (HTTPS) y coincide con patrones específicos (ejemplo: características del tráfico de Trojan), se marca como ilegal.</li>
</ul>

<h3 id="paso-7-ejemplo-de-solicitudes-legales">Paso 7: Ejemplo de solicitudes legales</h3>

<p>Por ejemplo, solicitudes como <code class="language-plaintext highlighter-rouge">GET https://some-domain.xyz/bandwidth</code> son seguras y no activarán el mecanismo de bloqueo.</p>

<h3 id="paso-8-características-del-tráfico-de-servidores-proxy">Paso 8: Características del tráfico de servidores proxy</h3>

<p>Los servidores proxy tienen características de tráfico muy diferentes en comparación con los servidores web o de API normales. El GFW necesita distinguir entre el tráfico de servidores web normales y el tráfico de servidores proxy, que puede parecer completamente diferente.</p>

<h3 id="paso-9-modelos-de-ia-y-aprendizaje-automático-para-detección-inteligente">Paso 9: Modelos de IA y aprendizaje automático para detección inteligente</h3>

<p>Dado el amplio rango de solicitudes y respuestas que pasan por internet, el GFW podría emplear modelos de IA y aprendizaje automático para analizar patrones de tráfico y detectar de manera inteligente comportamientos ilegales. Al entrenar el sistema con una variedad de tipos de tráfico y utilizando técnicas avanzadas, podría bloquear o filtrar el tráfico de manera más efectiva según los patrones observados.</p>

<hr />

<h2 id="actualización">Actualización</h2>

<p>A pesar de mis esfuerzos, mi servidor proxy sigue siendo bloqueado. Para mitigar esto, he implementado una solución alternativa utilizando la función de IP invertida de Digital Ocean, que me permite asignar rápidamente una nueva dirección IP cada vez que ocurre un bloqueo.</p>

<hr />

<h2 id="análisis-de-la-detección-de-vpn-en-chatgpt-ios">Análisis de la detección de VPN en ChatGPT iOS</h2>

<p><em>26.12.2024</em></p>

<p>Hoy descubrí que la aplicación ChatGPT iOS ahora permite iniciar sesión con una VPN en China. Anteriormente, mostraba un mensaje de bloqueo, como el que se muestra a continuación.</p>

<p>Sin embargo, a partir de hoy, funciona bien con una VPN.</p>

<p>Recuerdo que cuando se lanzó por primera vez la aplicación ChatGPT iOS, usarla con una VPN no era un problema. Más tarde, la detección de VPN se volvió más estricta, lo que dificultaba el inicio de sesión. Afortunadamente, parece que esta restricción se ha relajado recientemente.</p>

<p>Tras realizar más pruebas, descubrí que al usar una VPN de la región de Singapur de DigitalOcean, no podía acceder a la aplicación. Sin embargo, al usar VPNs de Taiwán o el Reino Unido (proporcionadas por https://zhs.cloud), funcionaba perfectamente.</p>

<p>Parece que la detección de VPN en ChatGPT iOS se basa en direcciones IP específicas. Algunos proveedores de servicios en la nube o ciertas direcciones IP están bloqueadas, lo que podría explicar el comportamiento inconsistente según la ubicación del servidor VPN.</p>

<p><img src="assets/images/chatgpt/block.jpg" alt="" class="responsive" /></p>

<p><img src="assets/images/chatgpt/c1.png" alt="" class="responsive" /></p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-es" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
