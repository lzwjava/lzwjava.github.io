<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>GFW, API de proxy, détection de VPN</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>GFW, API de proxy, détection de VPN | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="GFW, API de proxy, détection de VPN" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="fr" />
<meta name="description" content="Table des matières" />
<meta property="og:description" content="Table des matières" />
<link rel="canonical" href="https://lzwjava.github.io/proxy-ban-fr" />
<meta property="og:url" content="https://lzwjava.github.io/proxy-ban-fr" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-07T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="GFW, API de proxy, détection de VPN" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2025-01-07T00:00:00+08:00","datePublished":"2025-01-07T00:00:00+08:00","description":"Table des matières","headline":"GFW, API de proxy, détection de VPN","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/proxy-ban-fr"},"url":"https://lzwjava.github.io/proxy-ban-fr"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=a95520d67c5f8ceeaff9e18b8f2af0d3c897a672">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=a95520d67c5f8ceeaff9e18b8f2af0d3c897a672" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       GFW, API de proxy, détection de VPN | Original, traduit par l'IA
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/fr/2025-01-07-proxy-ban-fr.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsfr2025-01-07-proxy-ban-fr.md</span> -->
      

      <!-- <span>2025-01-07-proxy-ban-fr.md</span> -->

      
        

        
          
          <a href="#" class="button">2025.01</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/proxy-ban-en" >English</option>
        <option value="/proxy-ban-zh" >中文</option>
        <option value="/proxy-ban-ja" >日本語</option>
        <option value="/proxy-ban-es" >Español</option>
        <option value="/proxy-ban-hi" >हिंदी</option>
        <option value="/proxy-ban-fr" selected>Français</option>
        <option value="/proxy-ban-de" >Deutsch</option>
        <option value="/proxy-ban-ar" >العربية</option>
        <option value="/proxy-ban-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <h3 id="table-des-matières">Table des matières</h3>

<ol>
  <li><a href="#les-api-dans-les-serveurs-proxy-peuvent-elles-éviter-les-blocages-du-gfw">Les API dans les serveurs proxy peuvent-elles éviter les blocages du GFW ?</a>
    <ul>
      <li>Mélanger le trafic proxy et API évite les blocages du GFW</li>
      <li>Le GFW distingue le trafic proxy du trafic HTTP/HTTPS normal</li>
      <li>Le GFW bloque probablement en fonction du trafic proxy exclusif</li>
      <li>Le GFW utilise une fenêtre temporelle pour l’analyse du trafic</li>
      <li>Accéder régulièrement à l’API peut empêcher la détection</li>
    </ul>
  </li>
  <li><a href="#fonctionnement-du-grand-pare-feu-gfw">Fonctionnement du Grand Pare-feu (GFW).</a>
    <ul>
      <li>Le GFW enregistre les requêtes avec les données source et cible</li>
      <li>Bloque les IP associées à des activités illégales</li>
      <li>Utilise des règles pour détecter des protocoles spécifiques</li>
      <li>Peut bloquer en fonction du pourcentage de requêtes illégales</li>
      <li>Emploie l’IA pour une détection intelligente des motifs de trafic</li>
    </ul>
  </li>
  <li><a href="#analyse-de-la-détection-vpn-de-chatgpt-ios">Analyse de la détection VPN de ChatGPT iOS</a>
    <ul>
      <li>ChatGPT iOS fonctionne désormais avec certains VPN</li>
      <li>L’accès dépend de l’emplacement du serveur VPN</li>
      <li>La détection est basée sur des adresses IP spécifiques</li>
      <li>Certaines IP de fournisseurs cloud sont bloquées</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="les-api-dans-les-serveurs-proxy-peuvent-elles-éviter-les-blocages-du-gfw-">Les API dans les serveurs proxy peuvent-elles éviter les blocages du GFW ?</h2>

<p>Je fais tourner un serveur simple sur mon instance Shadowsocks avec le code suivant :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">jsonify</span>
<span class="kn">from</span> <span class="nn">flask_cors</span> <span class="kn">import</span> <span class="n">CORS</span>
<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">CORS</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>  <span class="c1"># Activer CORS pour toutes les routes
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/bandwidth'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">get_bandwidth</span><span class="p">():</span>
    <span class="c1"># Exécuter la commande vnstat pour obtenir les statistiques de trafic par intervalles de 5 minutes pour eth0
</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="n">run</span><span class="p">([</span><span class="s">'vnstat'</span><span class="p">,</span> <span class="s">'-i'</span><span class="p">,</span> <span class="s">'eth0'</span><span class="p">,</span> <span class="s">'-5'</span><span class="p">,</span> <span class="s">'--json'</span><span class="p">],</span> <span class="n">capture_output</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">stdout</span>

    <span class="c1"># Retourner les données capturées en tant que réponse JSON
</span>    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'0.0.0.0'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
</code></pre></div></div>

<p>Et j’utilise nginx pour servir le port 443 comme montré ci-dessous :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
    listen 443 ssl<span class="p">;</span>
    server_name www.some-domain.xyz<span class="p">;</span>

    ssl_certificate /etc/letsencrypt/live/www.some-domain.xyz/fullchain.pem<span class="p">;</span> <span class="c"># géré par</span>
    <span class="c"># ...</span>
    location / <span class="o">{</span>

        proxy_pass http://127.0.0.1:5000/<span class="p">;</span>
        <span class="c"># ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Ce programme serveur fournit des données réseau, et j’utilise le serveur comme mon serveur proxy, ce qui me permet d’afficher mon statut en ligne sur mon blog en utilisant les données réseau.</p>

<p>Ce qui est intéressant, c’est que le serveur n’a pas été bloqué par le Grand Pare-feu (GFW) ou tout autre système de contrôle réseau depuis plusieurs jours. Normalement, le serveur proxy que j’ai configuré serait bloqué en un ou deux jours. Le serveur exécute un programme Shadowsocks sur un port comme 51939, donc il fonctionne avec un trafic Shadowsocks mélangé à un trafic API normal. Ce mélange semble amener le GFW à croire que le serveur n’est pas un proxy dédié, mais plutôt un serveur normal, l’empêchant de bloquer l’IP.</p>

<p>Cette observation est intrigante. Il semble que le GFW utilise une logique spécifique pour différencier le trafic proxy du trafic normal. Bien que de nombreux sites comme Twitter et YouTube soient bloqués en Chine, de nombreux sites étrangers — comme ceux d’universités internationales et d’entreprises — restent accessibles.</p>

<p>Cela suggère que le GFW fonctionne probablement selon des règles qui distinguent le trafic HTTP/HTTPS normal du trafic lié aux proxy. Les serveurs qui gèrent les deux types de trafic semblent éviter les blocages, tandis que les serveurs ne gérant que le trafic proxy sont plus susceptibles d’être bloqués.</p>

<p>Une question est de savoir quelle plage de temps le GFW utilise pour accumuler les données de blocage — que ce soit une journée ou une heure. Pendant cette période, il détecte si le trafic provient exclusivement d’un proxy. Si c’est le cas, l’IP du serveur est bloquée.</p>

<p>Je visite souvent mon blog pour relire ce que j’ai écrit, mais dans les semaines à venir, mon attention se tournera vers d’autres tâches plutôt que vers la rédaction d’articles de blog. Cela réduira mes accès à l’API <code class="language-plaintext highlighter-rouge">bandwidth</code> via le port 443. Si je constate que je suis à nouveau bloqué, je devrais écrire un programme pour accéder régulièrement à cette API afin de tromper le GFW.</p>

<p>Voici une version améliorée de votre texte avec une structure et une clarté optimisées :</p>

<hr />

<h2 id="fonctionnement-du-grand-pare-feu-gfw">Fonctionnement du Grand Pare-feu (GFW).</h2>

<h3 id="étape-1--journalisation-des-requêtes">Étape 1 : Journalisation des requêtes</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Base de données pour stocker les données des requêtes
</span><span class="n">request_log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Fonction pour enregistrer les requêtes
</span><span class="k">def</span> <span class="nf">log_request</span><span class="p">(</span><span class="n">source_ip</span><span class="p">,</span> <span class="n">target_ip</span><span class="p">,</span> <span class="n">target_port</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
    <span class="n">request_log</span><span class="p">.</span><span class="n">append</span><span class="p">({</span>
        <span class="s">'source_ip'</span><span class="p">:</span> <span class="n">source_ip</span><span class="p">,</span>
        <span class="s">'target_ip'</span><span class="p">:</span> <span class="n">target_ip</span><span class="p">,</span>
        <span class="s">'target_port'</span><span class="p">:</span> <span class="n">target_port</span><span class="p">,</span>
        <span class="s">'body'</span><span class="p">:</span> <span class="n">body</span><span class="p">,</span>
        <span class="s">'timestamp'</span><span class="p">:</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
    <span class="p">})</span>
</code></pre></div></div>

<p>La fonction <code class="language-plaintext highlighter-rouge">log_request</code> enregistre les requêtes entrantes avec des informations essentielles comme l’IP source, l’IP cible, le port cible, le corps de la requête et l’horodatage.</p>

<h3 id="étape-2--vérification-et-blocage-des-ip">Étape 2 : Vérification et blocage des IP</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Fonction pour vérifier les requêtes et bloquer les IP
</span><span class="k">def</span> <span class="nf">check_and_ban_ips</span><span class="p">():</span>
    <span class="n">banned_ips</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Parcourir toutes les requêtes enregistrées
</span>    <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">request_log</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="n">banned_ips</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s">'target_ip'</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">banned_ips</span><span class="p">.</span><span class="n">discard</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s">'target_ip'</span><span class="p">])</span>

    <span class="c1"># Appliquer les blocages à toutes les IP identifiées
</span>    <span class="n">ban_ips</span><span class="p">(</span><span class="n">banned_ips</span><span class="p">)</span>
</code></pre></div></div>

<p>La fonction <code class="language-plaintext highlighter-rouge">check_and_ban_ips</code> parcourt toutes les requêtes enregistrées, identifie et bloque les IP associées à des activités illégales.</p>

<h3 id="étape-3--définition-de-ce-qui-rend-une-requête-illégale">Étape 3 : Définition de ce qui rend une requête illégale</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Fonction pour simuler la vérification si une requête est illégale
</span><span class="k">def</span> <span class="nf">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># Espace réservé pour la logique réelle de vérification des requêtes illégales
</span>    <span class="c1"># Par exemple, vérifier le corps de la requête ou la cible
</span>    <span class="k">return</span> <span class="s">"illegal"</span> <span class="ow">in</span> <span class="n">request</span><span class="p">[</span><span class="s">'body'</span><span class="p">]</span>
</code></pre></div></div>

<p>Ici, <code class="language-plaintext highlighter-rouge">is_illegal</code> vérifie si le corps de la requête contient le mot “illegal”. Cela peut être étendu à une logique plus sophistiquée en fonction de ce qui constitue une activité illégale.</p>

<h3 id="étape-4--blocage-des-ip-identifiées">Étape 4 : Blocage des IP identifiées</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Fonction pour bloquer une liste d'IP
</span><span class="k">def</span> <span class="nf">ban_ips</span><span class="p">(</span><span class="n">ip_set</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">ip_set</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Blocage de l'IP : </span><span class="si">{</span><span class="n">ip</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Une fois les IP illégales identifiées, la fonction <code class="language-plaintext highlighter-rouge">ban_ips</code> les bloque en affichant leurs adresses IP (ou, dans un système réel, pourrait les bloquer).</p>

<h3 id="étape-5--méthode-alternative-pour-vérifier-et-bloquer-les-ip-en-fonction-de-80--de-requêtes-illégales">Étape 5 : Méthode alternative pour vérifier et bloquer les IP en fonction de 80 % de requêtes illégales</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Fonction pour vérifier les requêtes et bloquer les IP en fonction de 80 % de requêtes illégales
</span><span class="k">def</span> <span class="nf">check_and_ban_ips</span><span class="p">():</span>
    <span class="n">banned_ips</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">illegal_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_requests</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Parcourir toutes les requêtes enregistrées
</span>    <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">request_log</span><span class="p">:</span>
        <span class="n">total_requests</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="n">illegal_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Si 80 % ou plus des requêtes sont illégales, bloquer ces IP
</span>    <span class="k">if</span> <span class="n">total_requests</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">illegal_count</span> <span class="o">/</span> <span class="n">total_requests</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.8</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">request_log</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
                <span class="n">banned_ips</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s">'target_ip'</span><span class="p">])</span>

    <span class="c1"># Appliquer les blocages à toutes les IP identifiées
</span>    <span class="n">ban_ips</span><span class="p">(</span><span class="n">banned_ips</span><span class="p">)</span>
</code></pre></div></div>

<p>Cette méthode alternative évalue si une IP doit être bloquée en fonction du pourcentage de requêtes illégales. Si 80 % ou plus des requêtes d’une IP sont illégales, elle est bloquée.</p>

<h3 id="étape-6--vérification-améliorée-des-requêtes-illégales-ex--détection-des-protocoles-shadowsocks-et-trojan">Étape 6 : Vérification améliorée des requêtes illégales (ex. : détection des protocoles Shadowsocks et Trojan)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_illegal</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># Vérifier si la requête utilise le protocole Shadowsocks (corps contenant des données binaires)
</span>    <span class="k">if</span> <span class="n">request</span><span class="p">[</span><span class="s">'target_port'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">443</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_trojan</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">is_shadowsocks</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>La fonction <code class="language-plaintext highlighter-rouge">is_illegal</code> vérifie maintenant également des protocoles spécifiques comme Shadowsocks et Trojan :</p>
<ul>
  <li><strong>Shadowsocks</strong> : On peut vérifier la présence de données chiffrées ou binaires dans le corps de la requête.</li>
  <li><strong>Trojan</strong> : Si la requête passe par le port 443 (HTTPS) et correspond à des motifs spécifiques (ex. : caractéristiques du trafic Trojan), elle est marquée comme illégale.</li>
</ul>

<h3 id="étape-7--exemple-de-requêtes-légales">Étape 7 : Exemple de requêtes légales</h3>

<p>Par exemple, des requêtes comme <code class="language-plaintext highlighter-rouge">GET https://some-domain.xyz/bandwidth</code> sont sûrement légales et ne déclencheront pas le mécanisme de blocage.</p>

<h3 id="étape-8--caractéristiques-du-trafic-des-serveurs-proxy">Étape 8 : Caractéristiques du trafic des serveurs proxy</h3>

<p>Les serveurs proxy ont des caractéristiques de trafic très différentes de celles des serveurs web ou API normaux. Le GFW doit distinguer le trafic normal des serveurs web de celui des serveurs proxy, qui peut être totalement différent.</p>

<h3 id="étape-9--modèles-dia-et-dapprentissage-automatique-pour-une-détection-intelligente">Étape 9 : Modèles d’IA et d’apprentissage automatique pour une détection intelligente</h3>

<p>Étant donné la grande variété de requêtes et de réponses qui transitent par Internet, le GFW pourrait employer des modèles d’IA et d’apprentissage automatique pour analyser les motifs de trafic et détecter intelligemment les comportements illégaux. En formant le système sur divers types de trafic et en utilisant des techniques avancées, il pourrait bloquer ou filtrer le trafic plus efficacement en fonction des motifs observés.</p>

<hr />

<h2 id="mise-à-jour">Mise à jour</h2>

<p>Malgré mes efforts, mon serveur proxy continue d’être bloqué. Pour atténuer ce problème, j’ai mis en place une solution de contournement en utilisant la fonction d’IP inversée de Digital Ocean, qui me permet d’attribuer rapidement une nouvelle adresse IP chaque fois qu’un blocage se produit.</p>

<hr />

<h2 id="analyse-de-la-détection-vpn-de-chatgpt-ios">Analyse de la détection VPN de ChatGPT iOS</h2>

<p><em>26.12.2024</em></p>

<p>Aujourd’hui, j’ai découvert que l’application iOS de ChatGPT permet désormais de se connecter avec un VPN en Chine. Auparavant, elle affichait une invite de blocage, comme celle montrée ci-dessous.</p>

<p>Cependant, à partir d’aujourd’hui, elle fonctionne correctement avec un VPN.</p>

<p>Je me souviens qu’au lancement de l’application iOS de ChatGPT, son utilisation avec un VPN ne posait pas de problème. Plus tard, la détection des VPN est devenue plus stricte, rendant la connexion difficile. Heureusement, il semble que cette restriction ait été assouplie récemment.</p>

<p>Après des tests supplémentaires, j’ai constaté que lorsque j’utilisais un VPN de la région de Singapour de DigitalOcean, je ne pouvais pas accéder à l’application. Cependant, avec des VPN de Taïwan ou du Royaume-Uni (fournis par https://zhs.cloud), cela fonctionnait parfaitement.</p>

<p>Il semble que la détection VPN de ChatGPT iOS soit basée sur des adresses IP spécifiques. Certains fournisseurs cloud ou certaines adresses IP sont bloqués, ce qui peut expliquer le comportement incohérent en fonction de l’emplacement du serveur VPN.</p>

<p><img src="assets/images/chatgpt/block.jpg" alt="" class="responsive" /></p>

<p><img src="assets/images/chatgpt/c1.png" alt="" class="responsive" /></p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-fr" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
