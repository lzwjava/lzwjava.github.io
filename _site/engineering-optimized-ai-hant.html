<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>優化人工智能之軟件工程</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>優化人工智能之軟件工程 | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="優化人工智能之軟件工程" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="hant" />
<meta name="description" content="目錄" />
<meta property="og:description" content="目錄" />
<link rel="canonical" href="https://lzwjava.github.io/engineering-optimized-ai-hant" />
<meta property="og:url" content="https://lzwjava.github.io/engineering-optimized-ai-hant" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-07-27T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="優化人工智能之軟件工程" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2025-07-27T00:00:00+08:00","datePublished":"2025-07-27T00:00:00+08:00","description":"目錄","headline":"優化人工智能之軟件工程","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/engineering-optimized-ai-hant"},"url":"https://lzwjava.github.io/engineering-optimized-ai-hant"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=354081f776a5a6e0f68a45ccf69ea1afb59f6fd1">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=354081f776a5a6e0f68a45ccf69ea1afb59f6fd1" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       優化人工智能之軟件工程 | 原創，AI翻譯
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/hant/2025-07-27-engineering-optimized-ai-hant.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postshant2025-07-27-engineering-optimized-ai-hant.md</span> -->
      

      <!-- <span>2025-07-27-engineering-optimized-ai-hant.md</span> -->

      
        

        
          
          <a href="#" class="button">2025.07</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/engineering-optimized-ai-en" >English</option>
        <option value="/engineering-optimized-ai-zh" >中文</option>
        <option value="/engineering-optimized-ai-ja" >日本語</option>
        <option value="/engineering-optimized-ai-es" >Español</option>
        <option value="/engineering-optimized-ai-hi" >हिंदी</option>
        <option value="/engineering-optimized-ai-fr" >Français</option>
        <option value="/engineering-optimized-ai-de" >Deutsch</option>
        <option value="/engineering-optimized-ai-ar" >العربية</option>
        <option value="/engineering-optimized-ai-hant" selected>繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <h3 id="目錄">目錄</h3>

<ol>
  <li><a href="#optimizing-software-engineering-for-ai">為 AI 優化軟件工程</a>
    <ul>
      <li>AI-First 開發的扁平架構</li>
      <li>Python 在 AI 驅動工作流程中的優勢</li>
      <li>Context Engineering 和 Token 優化</li>
      <li>為 AI 輔助構建程式碼</li>
    </ul>
  </li>
  <li><a href="#thriving-as-a-manual-ai-agent">作為一個人手 AI 代理蓬勃發展</a>
    <ul>
      <li>在企業環境中使用 AI 工具</li>
      <li>工具選擇和上下文管理</li>
      <li>建立可重用提示系統</li>
    </ul>
  </li>
  <li><a href="#leveraging-python-for-java-development">利用 Python 進行 Java 開發</a>
    <ul>
      <li>用於 Java 專案支援的 Python 腳本</li>
      <li>跨語言開發策略</li>
      <li>AI 輔助程式碼生成</li>
    </ul>
  </li>
  <li><a href="#programming-languages-in-the-ai-era">AI 時代的程式語言</a>
    <ul>
      <li>Python、Rust 和 Java 的未來</li>
      <li>性能與簡潔性的權衡</li>
      <li>語言演進與 AI 整合</li>
    </ul>
  </li>
</ol>

<h3 id="為-ai-優化軟件工程">為 AI 優化軟件工程</h3>

<p>在這個博客中，我使用數百個腳本來協助翻譯、沙盒、前端維護和 Telegram 機器人。我相信這種開發方法可能代表著為 AI 優化的未來軟件工程。</p>

<p>我不太依賴 Python 模組功能，也不想像一個大型 Java Spring 專案那樣構建程式碼。</p>

<p>在我的職業生涯中，我曾經參與過許多軟件專案。我見過令人印象深刻的銀行架構、微服務、有效的跨國設計以減少重複、基於 Spring 構建的強大基礎框架，以及具有集中配置的強大治理。</p>

<p>雖然這些銀行架構令人印象深刻，但如果我們今天開始，我會考慮為大型語言模型（LLMs）和 AI 進行優化。這將涉及更好的上下文工程、改進的關注點分離，以及優先考慮 AI 為先的思維，而非以人為中心的設計。儘管 Spring 提供多層次和良好的抽象，但對於 LLMs 和 AI 來說，導航起來可能具有挑戰性。</p>

<p>我認為我們應該追求更扁平的結構，類似於扁平化組織。這意味著只使用兩個層次：第一層調用第二層。在一個函數中，最好直接調用另外 50 個函數，而不是擁有 50 個嵌套級別或堆棧。AI/LLM 難以判斷或推斷過於複雜的嵌套結構，但它們擅長處理 100 到 200 行程式碼的小型函數。Python 非常適合從其他文件調用和導入。</p>

<p>Python 程式碼比 Java 容易的一個原因是它的依賴管理很簡單。你只需要使用 <code class="language-plaintext highlighter-rouge">pip install</code> 來添加一個依賴。而使用 Maven，你需要在 POM XML 文件中寫入依賴，然後使用 <code class="language-plaintext highlighter-rouge">mvn compile</code> 讓 Maven 下載依賴。</p>

<p>Python 簡單的另一個原因是它的程式碼可以直接運行而沒有麻煩。</p>

<p>儘管從 Java 11 開始，<code class="language-plaintext highlighter-rouge">java</code> 命令可以直接執行單文件源程式碼程式，而無需單獨使用 <code class="language-plaintext highlighter-rouge">javac</code> 編譯。然而，通常對於 Java 專案，它們很大，所以必須配合一些屬性配置，使用 <code class="language-plaintext highlighter-rouge">mvn spring-boot:run</code> 來運行。</p>

<p>第三個原因是 Python 的模組設計很簡單；你可以使用 <code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">import</code> 輕鬆地從其他文件導入程式碼。</p>

<p>目前，許多 AI 聊天機器人可以直接在聊天機器人窗口中運行 Python 程式碼，例如 Grok。</p>

<p>將 100 個 Java 文件（每個約 1000 行程式碼）與一些簡單的 Python 腳本進行比較，這是不公平的。對於這種專案，我寧願擁有 1000 個 Python 文件，每個約 100 行程式碼。</p>

<p>選擇要編輯的程式碼行或函數是可以接受的。但是，你需要知道在哪裡選擇。為什麼不讓 AI 處理這個任務，讓我們的生活更輕鬆呢？所以，我們只需要使用「全選」來選擇所有程式碼，並告訴 AI/LLM 如何編輯。</p>

<p>對於 Python，使用 <code class="language-plaintext highlighter-rouge">if __name__ == "__main__":</code> 來運行和測試文件中的函數更容易。其他 Python 文件也更容易調用此文件中的函數，而無需運行測試。</p>

<p>這是為 AI 優化的上下文工程。我們可以用其他方式來處理嗎？AI/LLM 是自回歸的。然而，當我們使用 Copilot 或 Claude Code 時，我們不知道 AI 軟件代理是如何幫助我們的。他們應該替我們思考，而不是我們自己。</p>

<p>在用戶端，我們能否專門安排程式碼以減少 token 使用？對於這一點，擁有 1000 個 Python 文件，每個 100 行程式碼的方法對於這個目的來說是很好的。因為你可以在其他 Python 程式碼調用它們之前輕鬆驗證函數和程式碼文件。</p>

<p>但一個問題是，如果你想同時更改多個程式碼文件，這並不容易做到。一個簡單的方法是，你可以將程式碼複製到 AI 聊天機器人，讓它們告訴你如何在這些文件中編輯程式碼。</p>

<p>也許，我們不需要使用行數來分隔函數或邏輯。但我們應該這樣做，將邏輯分成小函數。我們可以通過按邏輯類型自然地分隔它們來做到這一點，這樣它們看起來會更短。</p>

<p>我們為什麼要為 AI 優化軟件工程？因為 AI 很強大，我們應該為 AI 優化所有事物，然後讓 AI 盡可能地幫助軟件工程。</p>

<p>這不僅適用於程式碼，也適用於任何文本。假設我們是非常挑剔的編輯者；我們不希望 AI 一次性編輯我們的大量文本。我們想逐段檢查。對於程式碼，我們可以容忍輕微的錯誤或漏洞。對於文本，我們可以容忍它們，因為大多數讀者不會那麼挑剔。</p>

<p>但程式碼的不同之處在於，有時即使是一個小錯誤也可能導致一個大型專案完全失效。</p>

<p>對於 XML 或 YAML 文件，我們可能不需要太多地分隔它們，因為它們已經高度結構化。</p>

<p>而對於 HTML 文件，我們應該進行一些分隔。與其將數百個 JavaScript 文件與數百個 HTML 文件一起寫，導致很容易超過 1000 行程式碼，我們應該使用 <code class="language-plaintext highlighter-rouge">import</code> 來管理 JavaScript。對於 JavaScript 程式碼，我們可以使用上述方法進行分隔。</p>

<p>我們希望以一種讓 AI 能夠輕鬆幫助我們添加、編輯、刪除和運行程式碼的方式來構建程式碼。這只是開始。想像一下有一天，所有程式碼都可以輕鬆地由 AI 生成或修復。世界將高度數字化。</p>

<p>想像一下我自己編寫 100 個大型軟件專案並提供 API 與他人連接。這包括我的每日議程；我現在就像一個擁有 1000 名員工的科技公司。它們是為我的需求定制的，為了賺錢或為我的利益花錢。這真的很棒。</p>

<h3 id="作為一個人手-ai-代理蓬勃發展">作為一個人手 AI 代理蓬勃發展</h3>

<p>AI 代理應該能夠自動運行代碼。現在，這篇文章的標題是「人手 AI 代理」。你可能會覺得我在開玩笑，但我不是。</p>

<p>我之所以說「人手 AI 代理」，是因為對於大公司來說，由於安全數據顧慮和長期考量，技術採用速度緩慢。</p>

<p>市場上有很多新技術；誰知道什麼會持久，什麼會很快消失。</p>

<p>他們也有安全數據顧慮。通常，他們希望與其數據政策嚴格並受到公眾監督的大品牌合作。這解釋了為什麼微軟成為財富 500 強企業中的頂級合作夥伴。其他公司使用他們的 Teams、Microsoft Office 365、Azure 和 Copilot。</p>

<p>這意味著我們將使用大量工具來工作，類似於這些 API 中的工具使用或函數調用。我們將自行進行提示工程或上下文工程。</p>

<p>我們可能不會使用 Claude Code 或 Manus 來執行複雜任務，而是使用普通的 AI 聊天機器人及其 API 來執行任務。</p>

<p>AspectJ 很好，因為它使用 AOP 編程來攔截方法。Spring 中的過濾器也很好，可以捕獲 HTTP 請求的日誌。Log4j 中的日誌記錄器很好，可以將特定日誌重定向到文件。IntelliJ IDEA 很好，因為它具有將對象匯出為文本的功能。</p>

<p>SQL 客戶端很好，因為它們可以輕鬆地將行數匯出為 CSV 或 Excel 文件。Git diff 很好，因為它回傳比較文本。</p>

<p>這些都有助於你為 AI 聊天機器人提供更好的上下文。AI 聊天機器人也可以幫助很多 Python 腳本執行任務。</p>

<p>要成為一個有效的 AI 代理，你需要使用許多有效的工具來幫助你執行任務，無論是簡單還是複雜的。</p>

<p>所以你不需要像那些自動 AI 代理那樣多次詢問 AI 聊天機器人。你可以仔細選擇你將使用的工具。</p>

<p>所以，像一個人手 AI 代理那樣工作有它的好處。然而，AI 代理技術發展迅速，並向世界展示其潛力。</p>

<p>如果它們非常有用，大公司也會採用它們，就像 AI 聊天機器人一樣。否則，它們無法與其他已採用它們的公司競爭——不僅是其他大公司，還有小型初創公司。因為現在 AI 如此強大，一家只有數十名員工的初創公司可能會超越那些擁有 1000 名員工的公司。</p>

<p>作為人手 AI 代理工作有時是不可避免的。這份工作除了缺乏先進的 AI 技術之外，還有其他好處。找到好工作也不容易。所以在這種情況下，這恰好給了我們空間，利用我們的傳統智慧最大限度地利用 AI 聊天機器人。</p>

<p>這意味著我們可以組織和累積我們的提示，為 AI 聊天機器人創建系統提示，類似於那些被披露的 Claude 或 Grok 所使用的。這樣，我們就不需要重複編寫提示。我們可以使用 Python 腳本來協助我們編寫提示。我們可以獲取 HTTP 請求的日誌，並編寫提示來生成 API 測試案例。</p>

<p>編程的魔力在於其無限的抽象層次。這就像函數，你可以有 100 層函數調用。例如，微信建立在 iOS 之上，微信小程序建立在微信之上。iOS 本身建立在 Objective-C 或 Swift 之上，而後者又建立在 LLVM 和蘋果 ARM 晶片的指令集之上。</p>

<h3 id="利用-python-進行-java-開發">利用 Python 進行 Java 開發</h3>

<p>在 AI 時代，如何利用 Python 幫助 Java 開發？我喜歡 Python。自 2022 年 11 月底 ChatGPT 發布以來，我在過去約 3 年裡使用 Python 最多。</p>

<p>一種幫助方式是使用 Python 為 Java 專案編寫 SQL 輔助腳本、測試腳本和日誌搜索腳本。</p>

<p>使用 Python 分析 POM 文件並打包 Java 的依賴項。使用 Python 檢查 Java 中的數據一致性。我們可以在 Python 中做很多事情，而不必用 Java。</p>

<p>但 Java 沒有 PyTorch。Python 可以在 200 行程式碼中完成 Java 需要 500 行程式碼才能完成的任何事情。但通過使用 AI 工具，你也不能輕易獲得自己的 PyTorch 版本。即使像 TinyGrad 這樣的小東西也需要時間來構建。</p>

<p>為什麼要先編寫自己的腳本？一個原因是它具有超高的可定制性。沒有任何公共軟件或開源專案可以直接幫助我們的專案，特別是那些在大公司中的專案。</p>

<p>大公司中的大型專案經過十年或更長時間的開發。它們已經有很多定制。</p>

<p>因此，將來，大公司中的大型專案周圍將有很多周邊專案。大公司內部編碼代理工具中將會出現更多類似 Claude 的程式碼路由器。大公司將會有更多自訂的 Postman、SQL 客戶端和編譯器。</p>

<p>使用 Python 程式碼也可以連接到 Java 代理。</p>

<p>這意味著我需要很好地學習 Python 和 Java，這樣我就知道如何使用一個來幫助另一個。</p>

<p>而且在 AI 的幫助下，我可以使用 Python 為自己和公司專案創造很多東西。Java 似乎沒有什麼障礙。Java 搭配 Spring、數據庫，以及 Angular、Vue 或 React 作為前端，不應該成為 Python 提供大量幫助的障礙。</p>

<p>編程是如此靈活的東西。限制是我們的想像力。</p>

<p>所以 AI 發展迅速。我們可以用 AI 在編程和學習中幫助我們多快多容易地實現目標來衡量 AI 的進步。</p>

<p>有一天，我們能否編寫一些 AI 代理，然後這些代理幫助創建一個完整的 TikTok，包括其眾多的微服務和大型 iOS 或 Android 專案？</p>

<p>如果 AI 如此強大，我們今天應該做什麼？可能什麼都不做，因為我們今天所做的事情，用 AI 將很容易實現。在 2025 年，我們借助 AI 完成的一年工作，可能在 2030 年的 AI 能力下，一個月就能完成。</p>

<p>這引出了我們關鍵的問題：我們生命的目的是什麼？這一切是為了什麼？如何過上美好的生活？</p>

<p>AI 像其他科技一樣出現，為我們帶來自由。但似乎在這個資本社會中，每個人都忙得像機器一樣。</p>

<p>回到主題。Python 也可以幫助編寫 Java 程式碼。你可以使用 Python 來獲取編寫程式碼的上下文，並讓 Copilot 幫你編寫，確保一次就做對。</p>

<p>AI 關乎提示工程和上下文工程。提示和上下文有助於 AI 聊天機器人的回應。</p>

<p>Python 可以幫助提供上下文；Python 可以幫助生成提示。</p>

<p>所以這不僅關乎 Java，也關乎所有其他程式語言。Python 可以深入地幫助它們。那麼我們為什麼還需要使用其他程式語言呢？</p>

<p>是因為 Python 的本質設計使其性能不如其他程式語言，如 C、C++ 或 Rust。</p>

<h3 id="ai-時代的程式語言">AI 時代的程式語言</h3>

<p>AI 現在如此強大，我們必須從 AI 的角度重新思考所有事情。未來 10 年，哪些程式語言會受歡迎？</p>

<p>Python 肯定會。許多 AI 聊天機器人使用 Python 在瀏覽器中執行程式碼，例如 Grok。Python 因其簡潔、易學和不錯的性能而受歡迎。它被許多軟件專案採用。</p>

<p>Python 比 C++、Java 和 Rust 慢。Java 擁有龐大的社區。Rust 建立在 C 之上。</p>

<p>我不知道是不是很多專案會被 Rust 重寫或取代。被 Rust 重寫意味著參考舊專案並使用 Rust 實現相同的功能。被取代意味著用其他語言編寫的軟件現在被用 Rust 編寫的類似軟件取代。</p>

<p>Rust 的語法相對複雜。但在 AI 時代，這不是一個大問題，因為 AI 會幫助編寫程式碼。對於複雜的語法，人類實際上也沒有太多麻煩。</p>

<p>我認為印地語或泰米爾語相當複雜。但對於居住在北方的印度人來說，印地語不是問題，對於南方的印度人來說，泰米爾語也不是問題。</p>

<p>但對於像我這樣的中國公民來說，我認為學習起來是個大問題。</p>

<p>乍一看，印地語中的所有字符對我來說都很相似。我認為印地語和阿拉伯語的區別就像中文和日語，或者英語和西班牙語的區別一樣。</p>

<p>程式語言之間的差異小於自然語言之間的差異。一個主要原因是，程式語言僅在字符外觀上有所不同，而自然語言在發音上也不同。自然語言在兩個方面有所不同：字符集和發音。</p>

<p>程式語言只有大約一個世紀的歷史，但自然語言有超過 100 個世紀的歷史。人們花在某件事上的時間越多，差異就會越大。意見稍有不同的人會創造自己的版本。</p>

<p>這解釋了英語口音。在一些 TikTok 影片中，人們說最差的英語口音是伯明翰。</p>

<p>所以實際上，Rust 沒有太大的問題。它的性能非常好，因為它建立在 C/C++ 之上。</p>

<p>性能對於許多應用程式至關重要。如今，許多應用程式被數十億人使用。對於底層雲計算基礎設施，它們的服務被調用多次。因此，即使是微小的性能提升也能節省大量資金。</p>

<p>Rust 有很多缺點嗎？人們抱怨的一點是它很難學。學習曲線很陡峭。AI 帶來好消息，因為它對學習有很大的幫助。</p>

<p>我不需要對 Rust 了解太多。作為一個有 10 年經驗的軟件工程師，我可以使用 AI 幫助編寫許多簡單的 Rust 應用程式。我只需要知道基本的 Rust 編譯命令，如 <code class="language-plaintext highlighter-rouge">cargo</code> 和 <code class="language-plaintext highlighter-rouge">cargo build</code>。我甚至不需要對 Rust 語法本身了解太多。</p>

<p>對於 Rust，可變性或借用模型不會給我帶來麻煩。對於少於 200 行程式碼的簡單應用程式，我可以要求 AI 通過提供錯誤信息直接修復錯誤。</p>

<p>但如果 Rust 這麼好，為什麼人們仍然大量使用 Python 呢？因為 Python 在另一方面很好。它非常容易使用和學習。它擁有龐大的社區和許多庫。</p>

<p>Python 仍然擁有足夠好的性能，可以支持數百萬甚至數千萬用戶的產品。大多數產品沒有那麼多用戶。如果你確實有那麼多用戶，你可以僱用 Rust 或 Java 程式設計師來優化性能。</p>

<p>Python 適用於許多開發：機器學習、網頁開發、數學、教學和腳本編寫。雖然 Python 不擅長桌面應用程式，但 MicroPython 用於 Raspberry Pi。</p>

<p>AI 時代的 Java 怎麼樣？它也會很好，因為它擁有龐大的用戶群和社區。AI 對此幫助很大。它被許多大公司使用。他們傾向於不改變他們的主要程式語言。對於他們的一些大型遺留專案，使用新的程式語言重寫一個專案將需要十年的努力。AI 將幫助解決這個問題，但這個過程仍然會很慢。</p>

<p>通常，大公司中的理性人不會考慮改變他們的主要程式語言。他們的主要業務在其他領域。他們不太關心技術。如果他們關心，他們就會成為軟件或互聯網公司，並在開源社區中處於領先地位。然而，沒有多少財富 500 強公司關心這一點。</p>

<p>由於 AI，將會有大量初創公司。初創公司喜歡做新事物，所以他們會嘗試新的程式語言。在 AI 時代，靈活的程式語言將在中小型企業中獲勝。</p>

<p>在算法競賽中，最受歡迎的程式語言會改變嗎？C++ 在這個領域已經佔據主導地位幾十年了。在實際的算法競賽中，你不能使用 AI。但我認為在 AI 時代，參與的人會更少。</p>

<p>既然這些人非常擅長編程，並且由於 AI 有這麼多的機會，為什麼不讓更多人為用戶構建實際產品，而不是練習算法問題呢？即使是算法競賽的 GOAT，Gennady Korotkevich，也選擇加入了 Devin。</p>

<p>但算法競賽對聰明的程式設計師來說可以是一種放鬆或退休的愛好。它就像下棋或打籃球。人們這樣做是因為他們喜歡或需要它，而不是出於其他原因。許多人在 30 多歲或 40 多歲時打籃球。他們可能這樣做是為了健康或讓生活更有趣。</p>

<p>對於 iOS 和 Android，它是 Java、Kotlin、Swift 和 Objective-C。由於 AI，不會有顯著變化，因為選擇有限。在終端用戶端，性能要求沒有那麼高。Google 和 Apple 對其平台有很高的控制權。如果 Google 和 Apple 不改變，程式設計師就不會改變。</p>

<p>但對於伺服器，有很多選擇。更 AI 友好的語言將會獲勝。</p>

<p>程序式程式語言將比物件導向語言更受歡迎。程序式語言直接且易於由 AI 生成，而 OOP 語言則有許多嵌套層次或設計模式。</p>

<p>由於 AI，會出現更多程式語言嗎？我認為會。Zed 和 OCaml 將擁有更多用戶。LLMs/AI 非常擅長學習模式，因此很容易用其他語言重寫專案。</p>

<p>程式語言未來將面臨更多競爭。那些在性能、語法和編譯器質量方面表現良好的語言將自然而然地變得更受歡迎。競爭就像 LLMs 一樣。那些本質上表現良好的，如 Claude 和 DeepSeek，就會受歡迎。</p>

<p>如果 AI 變得如此強大，我們就不需要再學習程式設計了呢？那還早得很呢。假設我們有一個非常大的專案，有 1,000 個 Java 文件。AI 可能需要 10 年才能輕鬆完成這類任務。</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-hant" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
