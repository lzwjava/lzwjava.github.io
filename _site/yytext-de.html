<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Wie funktioniert YYText?</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Wie funktioniert YYText? | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Wie funktioniert YYText?" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="de" />
<meta name="description" content="Der obige Schatteneffekt wurde mit dem folgenden Code erzielt:" />
<meta property="og:description" content="Der obige Schatteneffekt wurde mit dem folgenden Code erzielt:" />
<link rel="canonical" href="https://lzwjava.github.io/yytext-de" />
<meta property="og:url" content="https://lzwjava.github.io/yytext-de" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-24T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Wie funktioniert YYText?" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-24T00:00:00+08:00","datePublished":"2016-05-24T00:00:00+08:00","description":"Der obige Schatteneffekt wurde mit dem folgenden Code erzielt:","headline":"Wie funktioniert YYText?","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/yytext-de"},"url":"https://lzwjava.github.io/yytext-de"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=f1b6c4b5f186136a03bf90eed67dd70f6320ecee">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=f1b6c4b5f186136a03bf90eed67dd70f6320ecee" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Wie funktioniert YYText? | Original, von KI übersetzt
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/de/2016-05-24-yytext-de.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsde2016-05-24-yytext-de.md</span> -->
      

      <!-- <span>2016-05-24-yytext-de.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/yytext-en" >English</option>
        <option value="/yytext-zh" >中文</option>
        <option value="/yytext-ja" >日本語</option>
        <option value="/yytext-es" >Español</option>
        <option value="/yytext-hi" >हिंदी</option>
        <option value="/yytext-fr" >Français</option>
        <option value="/yytext-de" selected>Deutsch</option>
        <option value="/yytext-ar" >العربية</option>
        <option value="/yytext-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Der obige Schatteneffekt wurde mit dem folgenden Code erzielt:</p>

<p>Man kann sehen, dass zuerst ein <code class="language-plaintext highlighter-rouge">YYTextShadow</code> erzeugt wurde, dann dem <code class="language-plaintext highlighter-rouge">yy_textShadow</code> der <code class="language-plaintext highlighter-rouge">attributedString</code> zugewiesen wurde, und anschließend die <code class="language-plaintext highlighter-rouge">attributedString</code> dem <code class="language-plaintext highlighter-rouge">YYLabel</code> zugewiesen wurde. Danach wurde das <code class="language-plaintext highlighter-rouge">YYLabel</code> zur Anzeige in eine <code class="language-plaintext highlighter-rouge">UIView</code> eingefügt. Beim Verfolgen von <code class="language-plaintext highlighter-rouge">yy_textShadow</code> stellt man fest, dass hauptsächlich der <code class="language-plaintext highlighter-rouge">textShadow</code> an das Attribut <code class="language-plaintext highlighter-rouge">NSAttributedString</code> gebunden wurde, wobei der Schlüssel <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> und der Wert <code class="language-plaintext highlighter-rouge">textShadow</code> ist. Das bedeutet, dass der Schatten zunächst gespeichert und später verwendet wird. Mit Shift + Command + J kann man schnell zur Definitionsstelle springen:</p>

<p>Hier gibt es eine Funktion namens <code class="language-plaintext highlighter-rouge">addAttribute</code>, die in <code class="language-plaintext highlighter-rouge">NSAttributedString.h</code> definiert ist:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAttribute</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">value</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">range</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</code></pre></div></div>

<p>Die Beschreibung besagt, dass beliebige Schlüssel-Wert-Paare zugewiesen werden können. Die Definition von <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> ist ein gewöhnlicher String, was bedeutet, dass zunächst die Schatteninformationen gespeichert und später verwendet werden. Lassen Sie uns global nach <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> suchen.</p>

<p>Dann kommen wir zur Funktion <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> in <code class="language-plaintext highlighter-rouge">YYTextLayout</code>:</p>

<p><code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> bedeutet, den Ursprungspunkt eines Kontexts zu verschieben, also</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>Es bedeutet, dass der Zeichenkontext zum Punkt <code class="language-plaintext highlighter-rouge">point</code> verschoben werden soll. Zuerst sollten wir herausfinden, wo <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> aufgerufen wird, und wir stellen fest, dass es in <code class="language-plaintext highlighter-rouge">drawInContext</code> aufgerufen wird.</p>

<p>In <code class="language-plaintext highlighter-rouge">drawInContext</code> wird zuerst der Rahmen des Blocks gezeichnet, gefolgt vom Hintergrundrahmen, Schatten, Unterstreichung, Text, Zusatzelementen, innerem Schatten, Durchstreichung, Textrahmen und Debug-Linien.</p>

<p>Wo genau wird also <code class="language-plaintext highlighter-rouge">drawInContext</code> verwendet? Man kann sehen, dass es einen Parameter <code class="language-plaintext highlighter-rouge">YYTextDebugOption</code> gibt, daher ist diese Funktion definitiv kein System-Callback, sondern wird innerhalb von YYText selbst aufgerufen.</p>

<p>Halten Sie <strong>Ctrl + 1</strong> gedrückt, um die Tastenkombination aufzurufen, und Sie werden feststellen, dass sie an vier Stellen verwendet wird.</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext:size:debug</code> ist immer noch ein eigener Aufruf von YYText, da der Typ von <code class="language-plaintext highlighter-rouge">debug</code> <code class="language-plaintext highlighter-rouge">YYTextDebugOption *</code> ist, was zu YY gehört. <code class="language-plaintext highlighter-rouge">newAsyncTask</code> scheint kein Systemaufruf zu sein, und das gleiche gilt für <code class="language-plaintext highlighter-rouge">addAttachmentToView:layer:</code>, daher handelt es sich höchstwahrscheinlich um <code class="language-plaintext highlighter-rouge">drawRect:</code>.</p>

<p>Tatsächlich, wenn man sich die schnelle Hilfe auf der rechten Seite ansieht, gibt es eine detaillierte Erklärung, und unter der Hilfe wird auch erwähnt, dass es in <code class="language-plaintext highlighter-rouge">UIView</code> definiert ist. Wenn man sich dann <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> ansieht, erbt es von <code class="language-plaintext highlighter-rouge">UIView</code>.</p>

<p>Also verwendet <code class="language-plaintext highlighter-rouge">YYLabel</code> <code class="language-plaintext highlighter-rouge">YYTextContainerView</code>? Und lässt dann das System die <code class="language-plaintext highlighter-rouge">drawRect:</code>-Methode in <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> aufrufen, um das Zeichnen durchzuführen?</p>

<p>Seltsam, <code class="language-plaintext highlighter-rouge">YYLabel</code> erbt von <code class="language-plaintext highlighter-rouge">UIView</code>. Daher sollte es in YYText zwei verschiedene Systeme geben! Ein System <code class="language-plaintext highlighter-rouge">YYLabel</code> und ein System <code class="language-plaintext highlighter-rouge">YYTextView</code>, ähnlich wie <code class="language-plaintext highlighter-rouge">UILabel</code> und <code class="language-plaintext highlighter-rouge">UITextView</code>. Dann schauen wir uns noch einmal den <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code> von <code class="language-plaintext highlighter-rouge">YYLabel</code> an, den wir zuvor gesehen haben.</p>

<p>Lange, in der Mitte wird die Methode <code class="language-plaintext highlighter-rouge">drawInContext</code> aus <code class="language-plaintext highlighter-rouge">YYTextLayout</code> aufgerufen. <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code>, wo wird das wiederum aufgerufen?</p>

<p>In der zweiten Zeile wurde es aufgerufen. Man kann es also einfach so verstehen, dass <code class="language-plaintext highlighter-rouge">YYLabel</code> asynchron verwendet wird, um den Text zu zeichnen. Und <code class="language-plaintext highlighter-rouge">_displayAsync</code> wird von dem oben genannten <code class="language-plaintext highlighter-rouge">display</code> aufgerufen. Wenn man sich die Dokumentation von <code class="language-plaintext highlighter-rouge">display</code> ansieht, steht dort, dass das System es zum richtigen Zeitpunkt aufruft, um den Inhalt des Layers zu aktualisieren, und man sollte es nicht direkt aufrufen. Wir können auch einen Breakpoint setzen.</p>

<p>Die Erklärung besagt, dass <code class="language-plaintext highlighter-rouge">display</code> innerhalb einer Transaktion von <code class="language-plaintext highlighter-rouge">CALayer</code> aufgerufen wird. Der Grund für die Verwendung einer Transaktion liegt wahrscheinlich darin, dass Änderungen in Batches vorgenommen werden sollen, um die Effizienz zu erhöhen. Es scheint nicht so, als ob es sich um eine Anforderung für ein Rollback wie in einer Datenbank handelt.</p>

<p>Die Systemdokumentation von <code class="language-plaintext highlighter-rouge">display</code> besagt auch, dass Sie diese Methode überschreiben können, um Ihr eigenes Zeichnen zu implementieren, wenn Sie möchten, dass Ihre Ebene anders gezeichnet wird.</p>

<p>Also haben wir eine einfache Idee. <code class="language-plaintext highlighter-rouge">YYLabel</code> überschreibt die <code class="language-plaintext highlighter-rouge">display</code>-Methode von <code class="language-plaintext highlighter-rouge">UIView</code>, um asynchron verschiedene Effekte wie Schatten zu zeichnen. Der Schatteneffekt wird zunächst in den Attributen des <code class="language-plaintext highlighter-rouge">attributedText</code> von <code class="language-plaintext highlighter-rouge">YYLabel</code> gespeichert und dann während des Zeichnens in der <code class="language-plaintext highlighter-rouge">display</code>-Methode wieder abgerufen. Beim Zeichnen wird das CoreGraphics-Framework des Systems verwendet.</p>

<p>Nachdem ich einige Gedanken sortiert habe, wird mir klar, was wirklich beeindruckend ist: Einerseits die Organisation all dieser Effekte und asynchronen Aufrufe, andererseits die fundierte Beherrschung des zugrunde liegenden CoreGraphics-Frameworks. Nachdem ich also ein Verständnis für die Organisation des vorherigen Codes entwickelt habe, tauchen wir tiefer in das CoreGraphics-Framework ein. Schauen wir uns an, wie die Zeichnungen tatsächlich umgesetzt werden.</p>

<p>Lassen Sie uns noch einmal zu <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> zurückkehren.</p>

<p>Hier umschließen <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> und <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> einen Block von Zeichencode. <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> bedeutet, dass der aktuelle Zeichenzustand kopiert und auf den Zeichenstapel gelegt wird. Jeder Zeichenkontext verwaltet einen eigenen Zeichenstapel. Ich bin mir nicht sicher, wie genau der Stapel intern funktioniert. Vorerst verstehe ich es so, dass vor dem Zeichnen im Kontext <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> aufgerufen werden muss und nach dem Zeichnen <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code>, damit die Zeichnungen in der Mitte effektiv im Kontext erscheinen. <code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> bewegt den Kontext an die entsprechende Position. Zuerst wird zu <code class="language-plaintext highlighter-rouge">point.x</code> und <code class="language-plaintext highlighter-rouge">point.y</code> bewegt, um an der entsprechenden Position zu zeichnen. Warum danach zu 0 und <code class="language-plaintext highlighter-rouge">size.height</code> bewegt wird, ist mir noch nicht klar, das werde ich später noch einmal überprüfen. Anschließend wird <code class="language-plaintext highlighter-rouge">lines</code> ausgelesen und eine <code class="language-plaintext highlighter-rouge">for</code>-Schleife ausgeführt.</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> 是什么？在 <code class="language-plaintext highlighter-rouge">YYTextLayout</code> 中的 <code class="language-plaintext highlighter-rouge">(YYTextLayout *)layoutWithContainer:(YYTextContainer *)container text:(NSAttributedString *)text range:(NSRange)range</code> 方法中被赋值。</p>

<p>Dann navigieren Sie zur Definition dieser Funktion:</p>

<p>Diese Funktion ist sehr lang, sie erstreckt sich von Zeile 367 bis 861, insgesamt 500 Zeilen Code! Wenn man den Anfang und das Ende betrachtet, wird deutlich, dass ihr Zweck darin besteht, diese Variablen zu erhalten. Wie wird <code class="language-plaintext highlighter-rouge">lines</code> erhalten?</p>

<p>Man kann sehen, dass in einer großen <code class="language-plaintext highlighter-rouge">for</code>-Schleife Zeile für Zeile (<code class="language-plaintext highlighter-rouge">line</code>) zu <code class="language-plaintext highlighter-rouge">lines</code> hinzugefügt wird. Aber wie wird <code class="language-plaintext highlighter-rouge">lineCount</code> ermittelt?</p>

<p>In Zeile 472 wird ein <code class="language-plaintext highlighter-rouge">framesetter</code>-Objekt erstellt, wobei der Parameter <code class="language-plaintext highlighter-rouge">text</code> ein <code class="language-plaintext highlighter-rouge">NSAttributedString</code> ist. Anschließend wird in dem <code class="language-plaintext highlighter-rouge">frameSetter</code>-Objekt ein <code class="language-plaintext highlighter-rouge">CTFrameRef</code> erzeugt, und aus diesem <code class="language-plaintext highlighter-rouge">CTFrameRef</code> werden die <code class="language-plaintext highlighter-rouge">lines</code> extrahiert. Was genau ist eine <code class="language-plaintext highlighter-rouge">line</code>? Setzen wir einen Breakpoint, um das zu untersuchen.</p>

<p>Es wurde festgestellt, dass <code class="language-plaintext highlighter-rouge">lineCount = 2</code> für das Wort <code class="language-plaintext highlighter-rouge">shadow</code> nicht die erwartete Anzahl der Buchstaben darstellt.</p>

<p>Also könnte man vermuten, dass der weiße <code class="language-plaintext highlighter-rouge">Shadow</code> insgesamt eine <code class="language-plaintext highlighter-rouge">line</code> ist, und der Schatten ebenfalls eine <code class="language-plaintext highlighter-rouge">line</code>?</p>

<p>In YYText, there are several examples, but only one effect is displayed, and the other code is commented out. I noticed something strange: for Shadow, <code class="language-plaintext highlighter-rouge">lineCount = 2</code>, and for Multiple Shadows, <code class="language-plaintext highlighter-rouge">lineCount</code> is also 2. However, Multiple Shadows also has an inner shadow, so shouldn’t it be 3 lines?</p>

<p>In der Apple-Dokumentation zu CTLine steht, dass CTLine eine Textzeile repräsentiert und ein CTLine-Objekt eine Gruppe von <code class="language-plaintext highlighter-rouge">glyph runs</code> enthält. Es handelt sich also einfach um die Anzahl der Zeilen! Wenn man sich den obigen Screenshot des Breakpoints ansieht, war der Wert von <code class="language-plaintext highlighter-rouge">shadow</code> 2, weil der Text <code class="language-plaintext highlighter-rouge">shadow\n\n</code> lautete. Die <code class="language-plaintext highlighter-rouge">\n\n</code> wurden absichtlich hinzugefügt, um die Darstellung zu verschönern:</p>

<p>Also ist <code class="language-plaintext highlighter-rouge">shadow\n\n</code> ein Text mit zwei Zeilen. CTLine ist das, was wir normalerweise als Zeile bezeichnen. Schauen wir uns nun unseren <code class="language-plaintext highlighter-rouge">lineCount</code> noch einmal an:</p>

<p>Hier erhalten wir das <code class="language-plaintext highlighter-rouge">CTLines</code>-Array, bestimmen die Anzahl der darin enthaltenen Elemente und wenn <code class="language-plaintext highlighter-rouge">lineCount</code> größer als 0 ist, ermitteln wir den Ursprungspunkt jeder Zeile. Gut, jetzt, da wir <code class="language-plaintext highlighter-rouge">lineCount</code> haben, schauen wir uns die <code class="language-plaintext highlighter-rouge">for</code>-Schleife an.</p>

<p>Aus dem <code class="language-plaintext highlighter-rouge">ctLines</code>-Array wird ein <code class="language-plaintext highlighter-rouge">CTLine</code>-Objekt extrahiert, woraus dann ein <code class="language-plaintext highlighter-rouge">YYTextLine</code>-Objekt erstellt wird, das anschließend dem <code class="language-plaintext highlighter-rouge">lines</code>-Array hinzugefügt wird. Danach werden einige Frame-Berechnungen für die <code class="language-plaintext highlighter-rouge">line</code> durchgeführt. Der Konstruktor von <code class="language-plaintext highlighter-rouge">YYTextLine</code> ist recht einfach und speichert zunächst die Position, ob es sich um vertikalen Text handelt, und das <code class="language-plaintext highlighter-rouge">CTLine</code>-Objekt:</p>

<p>Nachdem wir <code class="language-plaintext highlighter-rouge">lines</code> verstanden haben, kehren wir zu <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> zurück:</p>

<p>Der Code ist jetzt einfacher. Zuerst wird die Anzahl der Zeilen ermittelt, dann wird jede Zeile durchlaufen, und anschließend wird das <code class="language-plaintext highlighter-rouge">GlyphRuns</code>-Array abgerufen, das ebenfalls durchlaufen wird. Ein <code class="language-plaintext highlighter-rouge">GlyphRun</code> kann als ein grafisches Element oder eine Zeichnungseinheit verstanden werden. Danach wird das <code class="language-plaintext highlighter-rouge">attributes</code>-Array daraus extrahiert, und mit unserem zuvor definierten <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> wird der <code class="language-plaintext highlighter-rouge">shadow</code>-Wert abgerufen, den wir am Anfang zugewiesen haben. Schließlich wird der Schatten gezeichnet:</p>

<p>Eine <code class="language-plaintext highlighter-rouge">while</code>-Schleife, die kontinuierlich Unterstreichungen zeichnet. Es wird <code class="language-plaintext highlighter-rouge">CGContextSetShadowWithColor</code> aufgerufen, um die Verschiebung, den Radius und die Farbe des Schattens festzulegen. Anschließend wird <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> aufgerufen, um das eigentliche Zeichnen durchzuführen. <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> wird an drei Stellen aufgerufen:</p>

<p>Es wird verwendet, um innere Schatten, Textschatten und Text zu zeichnen. Dies zeigt, dass es sich um eine universelle Methode handelt, um das Objekt <code class="language-plaintext highlighter-rouge">Run</code> zu zeichnen.</p>

<p>Zuerst wird die Transformationsmatrix des Textes abgerufen, um mit <code class="language-plaintext highlighter-rouge">runTextMatrixIsID</code> zu überprüfen, ob sie unverändert bleibt. Wenn es sich nicht um vertikales Layout handelt oder keine grafische Transformation festgelegt wurde, wird der Text direkt gezeichnet. Der Aufruf von <code class="language-plaintext highlighter-rouge">CTRunDraw</code> zeichnet das <code class="language-plaintext highlighter-rouge">run</code>-Objekt. Anschließend zeigt der Breakpoint, dass beim Zeichnen des anfänglichen Schattens nur der <code class="language-plaintext highlighter-rouge">if</code>-Block betreten wird, nicht der <code class="language-plaintext highlighter-rouge">else</code>-Block.</p>

<p>Also, damit ist unsere Schattenerstellung abgeschlossen!</p>

<p>Zusammenfassend speichert <code class="language-plaintext highlighter-rouge">YYLabel</code> zunächst Effekte wie Schatten in den Attributen des <code class="language-plaintext highlighter-rouge">attributedText</code>. Es überschreibt die <code class="language-plaintext highlighter-rouge">display</code>-Methode von <code class="language-plaintext highlighter-rouge">UIView</code> und führt darin asynchrones Zeichnen durch. Mit dem <code class="language-plaintext highlighter-rouge">CoreText</code>-Framework werden <code class="language-plaintext highlighter-rouge">CTLine</code>- und <code class="language-plaintext highlighter-rouge">CTRun</code>-Objekte erstellt, und aus <code class="language-plaintext highlighter-rouge">CTRun</code> werden die Attribute abgerufen. Anschließend wird basierend auf den Eigenschaften in den Attributen das <code class="language-plaintext highlighter-rouge">CTRun</code>-Objekt mit dem <code class="language-plaintext highlighter-rouge">CoreGraphics</code>-Framework in den Context gezeichnet.</p>

<p>Das Verständnis ist noch nicht ausreichend, ich werde später noch einmal darauf zurückkommen. Ich kann nicht umhin, zu bewundern, wie stark YY ist! Heute habe ich meine Gedanken sortiert und mich dazu gebracht, den Code beim Schreiben zu lesen, um es nicht zu langweilig zu machen, und gleichzeitig als Referenz für andere zu dienen. Ich muss jetzt schlafen gehen.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-de" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
