<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>How YYText Works</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>How YYText Works | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="How YYText Works" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="en" />
<meta name="description" content="The shadow effect above is achieved using the following code:" />
<meta property="og:description" content="The shadow effect above is achieved using the following code:" />
<link rel="canonical" href="https://lzwjava.github.io/yytext-en" />
<meta property="og:url" content="https://lzwjava.github.io/yytext-en" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-24T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="How YYText Works" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-24T00:00:00+08:00","datePublished":"2016-05-24T00:00:00+08:00","description":"The shadow effect above is achieved using the following code:","headline":"How YYText Works","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/yytext-en"},"url":"https://lzwjava.github.io/yytext-en"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=3eb5b66ed1e2cae2306f81d4489ffb31d5192864">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=3eb5b66ed1e2cae2306f81d4489ffb31d5192864" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       How YYText Works | Original, translated by AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/en/2016-05-24-yytext-en.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsen2016-05-24-yytext-en.md</span> -->
      

      <!-- <span>2016-05-24-yytext-en.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/yytext-en" selected>English</option>
        <option value="/yytext-zh" >中文</option>
        <option value="/yytext-ja" >日本語</option>
        <option value="/yytext-es" >Español</option>
        <option value="/yytext-hi" >हिंदी</option>
        <option value="/yytext-fr" >Français</option>
        <option value="/yytext-de" >Deutsch</option>
        <option value="/yytext-ar" >العربية</option>
        <option value="/yytext-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>The shadow effect above is achieved using the following code:</p>

<p>First, a <code class="language-plaintext highlighter-rouge">YYTextShadow</code> object is created and assigned to the <code class="language-plaintext highlighter-rouge">yy_textShadow</code> attribute of the <code class="language-plaintext highlighter-rouge">attributedString</code>, which is then assigned to a <code class="language-plaintext highlighter-rouge">YYLabel</code>. The <code class="language-plaintext highlighter-rouge">YYLabel</code> is added to a <code class="language-plaintext highlighter-rouge">UIView</code> for display. By tracing <code class="language-plaintext highlighter-rouge">yy_textShadow</code>, we find that it is stored in the <code class="language-plaintext highlighter-rouge">NSAttributedString</code> attributes with the key <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code>. This means the shadow is stored for later use. Using Shift + Command + J, we can quickly jump to the definition:</p>

<p>Here, <code class="language-plaintext highlighter-rouge">addAttribute</code> is defined in <code class="language-plaintext highlighter-rouge">NSAttributedString.h</code>:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAttribute</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">value</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">range</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</code></pre></div></div>

<p>This means you can assign any key-value pair to it. The definition of <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> is just a regular string, indicating that the shadow information is stored for later use. Let’s search for <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> globally.</p>

<p>Now, let’s move to the <code class="language-plaintext highlighter-rouge">YYTextLayout</code> function <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>:</p>

<p><code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> changes the origin coordinates in a Context, so</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>means moving the drawing context to the point specified. First, we need to understand where <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> is called, which we find in <code class="language-plaintext highlighter-rouge">drawInContext</code>.</p>

<p>In <code class="language-plaintext highlighter-rouge">drawInContext</code>, various elements are drawn in sequence, including the block’s border, background border, shadow, underline, text, attachments, inner shadow, strikethrough, text border, and debug lines.</p>

<p>So where is <code class="language-plaintext highlighter-rouge">drawInContext</code> used? Given the <code class="language-plaintext highlighter-rouge">YYTextDebugOption</code> parameter, this function is likely not a system callback but called within YYText itself.</p>

<p>Using Ctrl + 1, we find that it is called in four places.</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext:size:debug</code> is likely still within YYText, as <code class="language-plaintext highlighter-rouge">debug</code> is of type <code class="language-plaintext highlighter-rouge">YYTextDebugOption *</code>. <code class="language-plaintext highlighter-rouge">newAsyncTask</code> and <code class="language-plaintext highlighter-rouge">addAttachmentToView:layer:</code> also seem to be internal calls, making it likely that <code class="language-plaintext highlighter-rouge">drawRect:</code> is involved.</p>

<p>Indeed, <code class="language-plaintext highlighter-rouge">drawRect:</code> is defined in <code class="language-plaintext highlighter-rouge">UIView</code>. <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> inherits from <code class="language-plaintext highlighter-rouge">UIView</code>.</p>

<p>So, <code class="language-plaintext highlighter-rouge">YYLabel</code> likely uses <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> to let the system call its <code class="language-plaintext highlighter-rouge">drawRect:</code> method for rendering.</p>

<p>Interestingly, <code class="language-plaintext highlighter-rouge">YYLabel</code> itself inherits from <code class="language-plaintext highlighter-rouge">UIView</code>. Hence, YYText might have two sets of components: <code class="language-plaintext highlighter-rouge">YYLabel</code> and <code class="language-plaintext highlighter-rouge">YYTextView</code>, similar to <code class="language-plaintext highlighter-rouge">UILabel</code> and <code class="language-plaintext highlighter-rouge">UITextView</code>. Returning to the <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code> in <code class="language-plaintext highlighter-rouge">YYLabel</code>,</p>

<p>in the middle, it calls <code class="language-plaintext highlighter-rouge">drawInContext</code> from <code class="language-plaintext highlighter-rouge">YYTextLayout</code>. The <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code> itself is called in <code class="language-plaintext highlighter-rouge">_displayAsync</code>.</p>

<p>In <code class="language-plaintext highlighter-rouge">_displayAsync</code>, it is called on the second line. So, <code class="language-plaintext highlighter-rouge">YYLabel</code> uses asynchronous rendering for text. <code class="language-plaintext highlighter-rouge">_displayAsync</code> is called by <code class="language-plaintext highlighter-rouge">display</code>, which is mentioned in the documentation to be called by the system at appropriate times to update the layer’s content. Let’s set a breakpoint on <code class="language-plaintext highlighter-rouge">display</code>.</p>

<p>This shows <code class="language-plaintext highlighter-rouge">display</code> is called within a transaction in <code class="language-plaintext highlighter-rouge">CALayer</code>. Transactions are likely used for batch updates for efficiency, rather than for rollback purposes as in databases.</p>

<p>The documentation also mentions that if you want your layer to render differently, you can override this method to implement custom rendering.</p>

<p>Thus, we have a rough idea: <code class="language-plaintext highlighter-rouge">YYLabel</code> overrides <code class="language-plaintext highlighter-rouge">UIView</code>’s <code class="language-plaintext highlighter-rouge">display</code> method for asynchronous rendering of shadows and other effects. The shadow effect is first stored in the <code class="language-plaintext highlighter-rouge">attributedText</code>’s attributes and retrieved during rendering using the CoreGraphics framework.</p>

<p>Understanding the code organization helps us realize the strength lies in managing various effects and asynchronous calls, along with proficient use of the CoreGraphics framework. With this understanding, let’s delve deeper into the CoreGraphics framework to see how the rendering is done.</p>

<p>Returning to <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>,</p>

<p><code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> and <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> surround a segment of drawing code. <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> copies the current drawing state onto a stack, maintained by each drawing context. Without knowing the exact internal operations of this stack, we can understand that <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> should be called before and <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> after drawing to ensure effective rendering within the context. <code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> moves the context to the specified position. Moving to <code class="language-plaintext highlighter-rouge">point.x</code> and <code class="language-plaintext highlighter-rouge">point.y</code> makes sense, but the subsequent move to 0 and <code class="language-plaintext highlighter-rouge">size.height</code> requires further investigation. The <code class="language-plaintext highlighter-rouge">lines</code> are then obtained and iterated over.</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> is assigned in <code class="language-plaintext highlighter-rouge">layoutWithContainer:text:range:</code> in <code class="language-plaintext highlighter-rouge">YYTextLayout</code>.</p>

<p>This function is quite lengthy, from lines 367 to 861, totaling 500 lines. Its purpose is to obtain these variables. How are <code class="language-plaintext highlighter-rouge">lines</code> obtained?</p>

<p>Within a large <code class="language-plaintext highlighter-rouge">for</code> loop, individual lines are added to <code class="language-plaintext highlighter-rouge">lines</code>. The <code class="language-plaintext highlighter-rouge">lineCount</code> is then determined.</p>

<p>At line 472, a <code class="language-plaintext highlighter-rouge">framesetter</code> object is created with <code class="language-plaintext highlighter-rouge">text</code> as an <code class="language-plaintext highlighter-rouge">NSAttributedString</code>, and a <code class="language-plaintext highlighter-rouge">CTFrameRef</code> is obtained from it, which in turn provides the <code class="language-plaintext highlighter-rouge">lines</code>. Let’s set a breakpoint to understand what a <code class="language-plaintext highlighter-rouge">line</code> is.</p>

<p>Interestingly, <code class="language-plaintext highlighter-rouge">lineCount</code> for the word <code class="language-plaintext highlighter-rouge">shadow</code> is 2, not the number of letters.</p>

<p>This suggests that the entire word <code class="language-plaintext highlighter-rouge">Shadow</code> is one line, and the shadow itself is another line.</p>

<p>Looking at examples in YYText, only one effect is shown while commenting out the others. It’s odd that <code class="language-plaintext highlighter-rouge">lineCount</code> is 2 for both <code class="language-plaintext highlighter-rouge">Shadow</code> and <code class="language-plaintext highlighter-rouge">Multiple Shadows</code>, even though <code class="language-plaintext highlighter-rouge">Multiple Shadows</code> should have three lines with an inner shadow.</p>

<p>The Apple documentation for CTLine indicates that a CTLine represents a single line of text, containing a group of glyph runs. So, it essentially represents the number of lines. The previous breakpoint screenshot shows <code class="language-plaintext highlighter-rouge">shadow</code> as <code class="language-plaintext highlighter-rouge">shadow\n\n</code>, where <code class="language-plaintext highlighter-rouge">\n\n</code> was added intentionally for display purposes.</p>

<p>So <code class="language-plaintext highlighter-rouge">shadow\n\n</code> is two lines of text. CTLine is simply a line. Returning to <code class="language-plaintext highlighter-rouge">lineCount</code>:</p>

<p>Here, the <code class="language-plaintext highlighter-rouge">CTLines</code> array is obtained, and its count is used to determine <code class="language-plaintext highlighter-rouge">lineCount</code>. If <code class="language-plaintext highlighter-rouge">lineCount</code> is greater than 0, the origin coordinates of each line are obtained. With <code class="language-plaintext highlighter-rouge">lineCount</code> determined, let’s proceed to the <code class="language-plaintext highlighter-rouge">for</code> loop.</p>

<p>From the <code class="language-plaintext highlighter-rouge">ctLines</code> array, a <code class="language-plaintext highlighter-rouge">CTLine</code> is obtained, which is then converted into a <code class="language-plaintext highlighter-rouge">YYTextLine</code> object and added to <code class="language-plaintext highlighter-rouge">lines</code>. Some frame calculations are performed for each line. The <code class="language-plaintext highlighter-rouge">YYTextLine</code> constructor simply stores the position, vertical layout status, and <code class="language-plaintext highlighter-rouge">CTLine</code> object.</p>

<p>Having understood <code class="language-plaintext highlighter-rouge">lines</code>, let’s return to <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>:</p>

<p>The code now becomes straightforward. The number of lines is obtained and iterated over, followed by extracting the <code class="language-plaintext highlighter-rouge">GlyphRuns</code> array for each line, which represents drawing units or primitives. From each <code class="language-plaintext highlighter-rouge">GlyphRun</code>, the attributes array is obtained, and the previously assigned <code class="language-plaintext highlighter-rouge">shadow</code> is retrieved using <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code>. Shadow drawing begins:</p>

<p>A <code class="language-plaintext highlighter-rouge">while</code> loop continuously draws sub-shadows. <code class="language-plaintext highlighter-rouge">CGContextSetShadowWithColor</code> sets the shadow offset, radius, and color. <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> is then called to actually draw. <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> is called in three places:</p>

<p>It’s used for drawing inner shadows, text shadows, and text itself, indicating it’s a general-purpose method for drawing <code class="language-plaintext highlighter-rouge">Run</code> objects.</p>

<p>Initially, the text transformation matrix is obtained, and if the run is not vertically laid out or lacks a transformation, it is drawn directly using <code class="language-plaintext highlighter-rouge">CTRunDraw</code>. The breakpoint reveals that while drawing the initial shadow, only the <code class="language-plaintext highlighter-rouge">if</code> block is entered, not the <code class="language-plaintext highlighter-rouge">else</code> block.</p>

<p>Thus, shadow rendering ends here!</p>

<p>In summary, <code class="language-plaintext highlighter-rouge">YYLabel</code> stores shadow effects in the <code class="language-plaintext highlighter-rouge">attributedText</code> attributes, overrides the <code class="language-plaintext highlighter-rouge">UIView</code>’s <code class="language-plaintext highlighter-rouge">display</code> method for asynchronous rendering, retrieves the attributes during rendering, and uses the CoreGraphics framework to draw the <code class="language-plaintext highlighter-rouge">CTRun</code> objects onto the context.</p>

<p>Further understanding is needed, which can be gained through future study. YY is truly impressive! Today, I organized my thoughts, making it easier to read and write code simultaneously, hopefully serving as a reference for others. Time for bed.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-en" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
