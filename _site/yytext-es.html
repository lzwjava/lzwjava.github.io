<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>¿Cómo funciona YYText?</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>¿Cómo funciona YYText? | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="¿Cómo funciona YYText?" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="es" />
<meta name="description" content="El efecto de sombra anterior se logró con el siguiente código:" />
<meta property="og:description" content="El efecto de sombra anterior se logró con el siguiente código:" />
<link rel="canonical" href="https://lzwjava.github.io/yytext-es" />
<meta property="og:url" content="https://lzwjava.github.io/yytext-es" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-24T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="¿Cómo funciona YYText?" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-24T00:00:00+08:00","datePublished":"2016-05-24T00:00:00+08:00","description":"El efecto de sombra anterior se logró con el siguiente código:","headline":"¿Cómo funciona YYText?","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/yytext-es"},"url":"https://lzwjava.github.io/yytext-es"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=fe318419e164ac4369c82db28dff561d33fa6e1a">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=fe318419e164ac4369c82db28dff561d33fa6e1a" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       ¿Cómo funciona YYText? | Original, traducido por IA
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/es/2016-05-24-yytext-es.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postses2016-05-24-yytext-es.md</span> -->
      

      <!-- <span>2016-05-24-yytext-es.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/yytext-en" >English</option>
        <option value="/yytext-zh" >中文</option>
        <option value="/yytext-ja" >日本語</option>
        <option value="/yytext-es" selected>Español</option>
        <option value="/yytext-hi" >हिंदी</option>
        <option value="/yytext-fr" >Français</option>
        <option value="/yytext-de" >Deutsch</option>
        <option value="/yytext-ar" >العربية</option>
        <option value="/yytext-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>El efecto de sombra anterior se logró con el siguiente código:</p>

<p>Se puede observar que primero se genera <code class="language-plaintext highlighter-rouge">YYTextShadow</code>, luego se asigna a <code class="language-plaintext highlighter-rouge">yy_textShadow</code> de <code class="language-plaintext highlighter-rouge">attributedString</code>, y después se asigna <code class="language-plaintext highlighter-rouge">attributedString</code> a <code class="language-plaintext highlighter-rouge">YYLabel</code>. A continuación, se añade <code class="language-plaintext highlighter-rouge">YYLabel</code> a <code class="language-plaintext highlighter-rouge">UIView</code> para mostrarlo. Al rastrear <code class="language-plaintext highlighter-rouge">yy_textShadow</code>, se descubre que principalmente se vincula <code class="language-plaintext highlighter-rouge">textShadow</code> al atributo de <code class="language-plaintext highlighter-rouge">NSAttributedString</code>, donde la clave es <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> y el valor es <code class="language-plaintext highlighter-rouge">textShadow</code>. Es decir, primero se almacena el shadow y luego se utiliza. Usando Shift + Command + J, se puede saltar rápidamente a la definición:</p>

<p>Aquí hay un <code class="language-plaintext highlighter-rouge">addAttribute</code>, que está definido en <code class="language-plaintext highlighter-rouge">NSAttributedString.h</code>:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAttribute</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">value</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">range</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</code></pre></div></div>

<p>En español, el método se traduciría como:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">agregarAtributo</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">nombre</span> <span class="nf">valor</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">valor</span> <span class="nf">rango</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">rango</span><span class="p">;</span>
</code></pre></div></div>

<p>La explicación indica que se pueden asignar pares clave-valor arbitrarios. La definición de <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> es una cadena de texto común, lo que significa que primero se almacena la información de la sombra y luego se utiliza más adelante. Vamos a realizar una búsqueda global de <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code>.</p>

<p>Luego llegamos a la función <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> dentro de <code class="language-plaintext highlighter-rouge">YYTextLayout</code>:</p>

<p><code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> se refiere a cambiar las coordenadas del origen en un contexto, por lo que</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>Se refiere a mover el contexto de dibujo al punto <code class="language-plaintext highlighter-rouge">point</code>. Primero, debemos aclarar dónde se llama a <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>, y descubrimos que se llama dentro de <code class="language-plaintext highlighter-rouge">drawInContext</code>.</p>

<p>En <code class="language-plaintext highlighter-rouge">drawInContext</code>, se dibuja en orden el borde del bloque, luego el borde del fondo, la sombra, la línea subrayada, el texto, los accesorios, la sombra interior, la línea de tachado, el borde del texto y las líneas de depuración.</p>

<p>Entonces, ¿dónde se usa exactamente <code class="language-plaintext highlighter-rouge">drawInContext</code>? Puedes ver que hay un parámetro llamado <code class="language-plaintext highlighter-rouge">YYTextDebugOption</code>, lo que significa que esta función definitivamente no es una devolución de llamada del sistema, sino que es llamada internamente por YYText.</p>

<p>Mantén presionado Ctrl + 1 para abrir el menú de atajos de teclado, y notarás que hay cuatro lugares donde se invoca.</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext:size:debug</code> sigue siendo una llamada propia de YYText, ya que el tipo de <code class="language-plaintext highlighter-rouge">debug</code> es <code class="language-plaintext highlighter-rouge">YYTextDebugOption *</code>, que es propio de YY. <code class="language-plaintext highlighter-rouge">newAsyncTask</code> no parece ser una llamada del sistema, y lo mismo ocurre con <code class="language-plaintext highlighter-rouge">addAttachmentToView:layer:</code>, por lo que es muy probable que sea <code class="language-plaintext highlighter-rouge">drawRect:</code>.</p>

<p>Efectivamente, al mirar la ayuda rápida en el lado derecho, hay una explicación detallada, y debajo de la ayuda también se indica que está definido en <code class="language-plaintext highlighter-rouge">UIView</code>. Si observamos <code class="language-plaintext highlighter-rouge">YYTextContainerView</code>, vemos que hereda de <code class="language-plaintext highlighter-rouge">UIView</code>.</p>

<p>¿Entonces <code class="language-plaintext highlighter-rouge">YYLabel</code> utiliza <code class="language-plaintext highlighter-rouge">YYTextContainerView</code>? ¿Y luego hace que el sistema llame al método <code class="language-plaintext highlighter-rouge">drawRect:</code> dentro de <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> para dibujarlo?</p>

<p>Es curioso, <code class="language-plaintext highlighter-rouge">YYLabel</code> hereda de <code class="language-plaintext highlighter-rouge">UIView</code>. Por lo tanto, en YYText debería haber dos conjuntos de cosas: uno para <code class="language-plaintext highlighter-rouge">YYLabel</code> y otro para <code class="language-plaintext highlighter-rouge">YYTextView</code>, similar a cómo están <code class="language-plaintext highlighter-rouge">UILabel</code> y <code class="language-plaintext highlighter-rouge">UITextView</code>. Luego, si volvemos a revisar el <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code> de <code class="language-plaintext highlighter-rouge">YYLabel</code> que mencionamos antes,</p>

<p>Es bastante largo, en la parte central se llama a <code class="language-plaintext highlighter-rouge">drawInContext</code> dentro de <code class="language-plaintext highlighter-rouge">YYTextLayout</code>. ¿Dónde se llama a <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code>?</p>

<p>En la segunda línea se llamó. Por lo tanto, se puede entender simplemente que <code class="language-plaintext highlighter-rouge">YYLabel</code> utiliza asincronía para dibujar el texto. Y <code class="language-plaintext highlighter-rouge">_displayAsync</code> fue llamado por el <code class="language-plaintext highlighter-rouge">display</code> anterior. Mirando la documentación de <code class="language-plaintext highlighter-rouge">display</code>, dice que el sistema lo llamará en el momento adecuado para actualizar el contenido del layer, y no debes llamarlo directamente. También podemos ponerle un punto de interrupción.</p>

<p>La explicación es que <code class="language-plaintext highlighter-rouge">display</code> se llama dentro de una transacción de <code class="language-plaintext highlighter-rouge">CALayer</code>. ¿Por qué se usa una transacción? Probablemente para realizar actualizaciones en lote, lo que sería más eficiente, ¿no? No parece ser un requisito de reversión como en una base de datos.</p>

<p>La documentación del sistema de <code class="language-plaintext highlighter-rouge">display</code> también menciona que, si deseas que tu capa se dibuje de manera diferente, puedes sobrescribir este método para implementar tu propio dibujo.</p>

<p>Entonces, tenemos una idea básica. <code class="language-plaintext highlighter-rouge">YYLabel</code> sobrescribe el método <code class="language-plaintext highlighter-rouge">display</code> de <code class="language-plaintext highlighter-rouge">UIView</code> para dibujar de manera asíncrona varios efectos como sombras, etc. Los efectos de sombra se almacenan primero en los atributos del <code class="language-plaintext highlighter-rouge">attributedText</code> de <code class="language-plaintext highlighter-rouge">YYLabel</code>, y luego se recuperan durante la ejecución del método <code class="language-plaintext highlighter-rouge">display</code> para dibujarlos. Durante el dibujo, se utiliza el framework CoreGraphics del sistema.</p>

<p>Después de aclarar algunas ideas, te darás cuenta de que lo que realmente es poderoso es, por un lado, la capacidad de organizar tantos efectos, llamadas asíncronas, etc., y por otro lado, el manejo experto del framework CoreGraphics subyacente. Así que, después de comprender un poco la organización del código anterior, profundizaremos en el framework CoreGraphics. Veamos cómo se realiza el dibujo.</p>

<p>Volvamos a <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code>.</p>

<p>Aquí, <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> y <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> encierran un bloque de código de dibujo. <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> significa copiar el estado actual de dibujo y guardarlo en la pila de dibujo. Cada contexto de dibujo mantiene una pila de dibujo. No estoy seguro de cómo se maneja exactamente la pila internamente. Por ahora, entiéndase que antes de dibujar en el contexto, se debe llamar a <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code>, y después de dibujar en el contexto, se debe llamar a <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code>. Luego, el dibujo en el medio aparecerá efectivamente en el contexto. <code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> mueve el contexto a la posición correspondiente. Primero se mueve a <code class="language-plaintext highlighter-rouge">point.x</code> y <code class="language-plaintext highlighter-rouge">point.y</code>, que son las coordenadas correspondientes para el dibujo. En cuanto al movimiento posterior a 0 y <code class="language-plaintext highlighter-rouge">size.height</code>, no estoy seguro, lo revisaré más adelante. Luego se obtienen las <code class="language-plaintext highlighter-rouge">lines</code> y se ejecuta un bucle <code class="language-plaintext highlighter-rouge">for</code>.</p>

<p>¿Qué es <code class="language-plaintext highlighter-rouge">lines</code>? Se encuentra en <code class="language-plaintext highlighter-rouge">YYTextLayout</code> dentro del método <code class="language-plaintext highlighter-rouge">(YYTextLayout *)layoutWithContainer:(YYTextContainer *)container text:(NSAttributedString *)text range:(NSRange)range</code>, donde se asigna un valor.</p>

<p>Luego, navega hasta la definición de esta función:</p>

<p>Esta función es extremadamente larga, ¡va desde la línea 367 hasta la 861, con 500 líneas de código! Después de revisar el principio y el final, se puede ver que su propósito es obtener estas variables. ¿Cómo se obtiene <code class="language-plaintext highlighter-rouge">lines</code>?</p>

<p>Se puede observar que dentro de un gran bucle <code class="language-plaintext highlighter-rouge">for</code>, se agrega una por una cada <code class="language-plaintext highlighter-rouge">line</code> a <code class="language-plaintext highlighter-rouge">lines</code>. Entonces, ¿cómo se obtiene el <code class="language-plaintext highlighter-rouge">lineCount</code>?</p>

<p>En la línea 472, se crea un objeto <code class="language-plaintext highlighter-rouge">framesetter</code>, donde el parámetro <code class="language-plaintext highlighter-rouge">text</code> es un <code class="language-plaintext highlighter-rouge">NSAttributedString</code>. Luego, se crea un <code class="language-plaintext highlighter-rouge">CTFrameRef</code> dentro del objeto <code class="language-plaintext highlighter-rouge">frameSetter</code>, y a partir de este <code class="language-plaintext highlighter-rouge">CTFrameRef</code>, se obtienen las <code class="language-plaintext highlighter-rouge">lines</code>. ¿Qué es exactamente <code class="language-plaintext highlighter-rouge">line</code>? Vamos a ponerle un punto de interrupción para averiguarlo.</p>

<p>Descubrí que la palabra <code class="language-plaintext highlighter-rouge">shadow</code> tiene <code class="language-plaintext highlighter-rouge">lineCount = 2</code>, lo cual no es el número de letras que imaginábamos.</p>

<p>Así que supongo que el <code class="language-plaintext highlighter-rouge">Shadow</code> blanco es una sola <code class="language-plaintext highlighter-rouge">line</code>, y la sombra también es una <code class="language-plaintext highlighter-rouge">line</code>?</p>

<p>En YYText hay varios ejemplos, solo se muestra uno de los efectos y los demás códigos están comentados. Noté algo extraño: el <code class="language-plaintext highlighter-rouge">lineCount</code> de Shadow es 2, y el <code class="language-plaintext highlighter-rouge">lineCount</code> de Multiple Shadows también es 2, pero Multiple Shadows tiene una sombra interna, ¿no debería ser 3?</p>

<p>Al buscar la documentación de Apple sobre CTLine, se dice que CTLine representa una línea de texto, y un objeto CTLine contiene un conjunto de <code class="language-plaintext highlighter-rouge">glyph runs</code>. ¡Así que simplemente se trata del número de líneas! Mirando la captura de pantalla del punto de interrupción anterior, la razón por la que <code class="language-plaintext highlighter-rouge">shadow</code> era 2 es porque su texto era <code class="language-plaintext highlighter-rouge">shadow\n\n</code>. Como se puede ver, <code class="language-plaintext highlighter-rouge">\n\n</code> se agregó intencionalmente para mejorar la presentación visual:</p>

<p>Por lo tanto, <code class="language-plaintext highlighter-rouge">shadow\n\n</code> son dos líneas de texto. CTLine es lo que comúnmente llamamos una línea. Luego, volvemos a nuestro <code class="language-plaintext highlighter-rouge">lineCount</code>:</p>

<p>Aquí obtenemos el arreglo <code class="language-plaintext highlighter-rouge">CTLines</code>, contamos el número de elementos dentro de él, y si <code class="language-plaintext highlighter-rouge">lineCount</code> es mayor que 0, obtenemos el origen de las coordenadas de cada línea. Bien, ahora que tenemos <code class="language-plaintext highlighter-rouge">lineCount</code>, continuamos con el bucle <code class="language-plaintext highlighter-rouge">for</code>.</p>

<p>Obtén <code class="language-plaintext highlighter-rouge">CTLine</code> del array <code class="language-plaintext highlighter-rouge">ctLines</code>, luego obtén el objeto <code class="language-plaintext highlighter-rouge">YYTextLine</code> y agrégalo al array <code class="language-plaintext highlighter-rouge">lines</code>. Después, realiza algunos cálculos de <code class="language-plaintext highlighter-rouge">frame</code> para la línea. El constructor de <code class="language-plaintext highlighter-rouge">YYTextLine</code> es bastante simple, primero guarda la posición, si es un diseño vertical y el objeto <code class="language-plaintext highlighter-rouge">CTLine</code>:</p>

<p>Una vez que hayas entendido <code class="language-plaintext highlighter-rouge">lines</code>, volvamos a la función <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> anterior:</p>

<p>Ahora el código es más sencillo. Primero obtenemos el número de líneas, lo recorremos, luego obtenemos el array <code class="language-plaintext highlighter-rouge">GlyphRuns</code> y lo recorremos también. <code class="language-plaintext highlighter-rouge">GlyphRun</code> puede entenderse como un primitivo gráfico o una unidad de dibujo. Luego, obtenemos el array <code class="language-plaintext highlighter-rouge">attributes</code> y, utilizando nuestro <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> anterior, obtenemos el <code class="language-plaintext highlighter-rouge">shadow</code> que asignamos al principio. Finalmente, comenzamos a dibujar la sombra:</p>

<p>Un bucle <code class="language-plaintext highlighter-rouge">while</code> que dibuja continuamente sombras secundarias. Se llama a <code class="language-plaintext highlighter-rouge">CGContextSetShadowWithColor</code> para configurar el desplazamiento, el radio y el color de la sombra. Luego se llama a <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> para realizar el dibujo real. <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> es llamado desde tres lugares:</p>

<p>Se utiliza para dibujar sombras internas, sombras de texto y el texto en sí. Esto indica que es un método genérico utilizado para dibujar el objeto <code class="language-plaintext highlighter-rouge">Run</code>.</p>

<p>Primero, se obtiene la matriz de transformación del texto y se utiliza <code class="language-plaintext highlighter-rouge">runTextMatrixIsID</code> para verificar si permanece sin cambios. Si no es una disposición vertical o no se ha configurado una transformación de gráficos primitivos, se procede directamente a dibujar. Se llama a <code class="language-plaintext highlighter-rouge">CTRunDraw</code> para dibujar el objeto <code class="language-plaintext highlighter-rouge">run</code>. Luego, al establecer un punto de interrupción, se descubre que al dibujar la sombra inicial solo se entra en el bloque <code class="language-plaintext highlighter-rouge">if</code>, pero no en el bloque <code class="language-plaintext highlighter-rouge">else</code>.</p>

<p>¡Así que eso es todo para nuestro dibujo de sombras!</p>

<p>En resumen, <code class="language-plaintext highlighter-rouge">YYLabel</code> primero guarda efectos como sombras en los atributos del <code class="language-plaintext highlighter-rouge">attributedText</code>, sobrescribe el método <code class="language-plaintext highlighter-rouge">display</code> de <code class="language-plaintext highlighter-rouge">UIView</code>, y realiza el dibujo asíncrono dentro de <code class="language-plaintext highlighter-rouge">display</code>. Utiliza el framework <code class="language-plaintext highlighter-rouge">CoreText</code> para obtener objetos <code class="language-plaintext highlighter-rouge">CTLine</code> y <code class="language-plaintext highlighter-rouge">CTRun</code>, y luego extrae los atributos desde <code class="language-plaintext highlighter-rouge">CTRun</code>. Finalmente, basándose en los atributos obtenidos, utiliza el framework <code class="language-plaintext highlighter-rouge">CoreGraphics</code> para dibujar el objeto <code class="language-plaintext highlighter-rouge">CTRun</code> en el Contexto.</p>

<p>Aún no lo entiendo del todo, volveré a leerlo más adelante. No puedo evitar admirar lo increíblemente poderoso que es YY. Hoy he organizado mis ideas, escribiendo y leyendo código al mismo tiempo para no aburrirme, y también para que otros puedan consultarlo. Es hora de ir a dormir.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-es" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
