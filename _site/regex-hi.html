<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>जटिल रेगुलर एक्सप्रेशन</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>जटिल रेगुलर एक्सप्रेशन | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="जटिल रेगुलर एक्सप्रेशन" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="hi" />
<meta name="description" content="हाल ही में मैं HTML पार्सिंग का अध्ययन कर रहा था और एक रेगुलर एक्सप्रेशन (regular expression) से मिला:" />
<meta property="og:description" content="हाल ही में मैं HTML पार्सिंग का अध्ययन कर रहा था और एक रेगुलर एक्सप्रेशन (regular expression) से मिला:" />
<link rel="canonical" href="https://lzwjava.github.io/regex-hi" />
<meta property="og:url" content="https://lzwjava.github.io/regex-hi" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-25T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="जटिल रेगुलर एक्सप्रेशन" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-25T00:00:00+08:00","datePublished":"2016-05-25T00:00:00+08:00","description":"हाल ही में मैं HTML पार्सिंग का अध्ययन कर रहा था और एक रेगुलर एक्सप्रेशन (regular expression) से मिला:","headline":"जटिल रेगुलर एक्सप्रेशन","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/regex-hi"},"url":"https://lzwjava.github.io/regex-hi"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=99b941d1f99a8508470f88432ce9a36a1e29f244">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=99b941d1f99a8508470f88432ce9a36a1e29f244" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       जटिल रेगुलर एक्सप्रेशन | मूल, AI द्वारा अनुवादित
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/hi/2016-05-25-regex-hi.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postshi2016-05-25-regex-hi.md</span> -->
      

      <!-- <span>2016-05-25-regex-hi.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/regex-en" >English</option>
        <option value="/regex-zh" >中文</option>
        <option value="/regex-ja" >日本語</option>
        <option value="/regex-es" >Español</option>
        <option value="/regex-hi" selected>हिंदी</option>
        <option value="/regex-fr" >Français</option>
        <option value="/regex-de" >Deutsch</option>
        <option value="/regex-ar" >العربية</option>
        <option value="/regex-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>हाल ही में मैं HTML पार्सिंग का अध्ययन कर रहा था और एक रेगुलर एक्सप्रेशन (regular expression) से मिला:</p>

<p>यह एक रेगुलर एक्सप्रेशन (regex) है जो HTML टैग्स, आईडी, क्लास, एट्रिब्यूट्स, और अन्य विशेषताओं को पार्स करने के लिए उपयोग किया जाता है। इसे हिंदी में समझाने का प्रयास करते हैं:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">/([\w-:\*&gt;]*)</code>: यह भाग टैग नाम को कैप्चर करता है। इसमें अक्षर, संख्याएं, हाइफन, कोलन, और कुछ विशेष वर्ण (जैसे <code class="language-plaintext highlighter-rouge">*</code> और <code class="language-plaintext highlighter-rouge">&gt;</code>) शामिल हो सकते हैं।</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code>: यह भाग आईडी (<code class="language-plaintext highlighter-rouge">#</code>) या क्लास (<code class="language-plaintext highlighter-rouge">.</code>) को कैप्चर करता है। यह वैकल्पिक है (इसलिए <code class="language-plaintext highlighter-rouge">?</code> का उपयोग किया गया है)।</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?</code>: यह भाग एट्रिब्यूट्स को कैप्चर करता है। इसमें एट्रिब्यूट नाम, ऑपरेटर (जैसे <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">*=</code>), और मान शामिल हो सकते हैं। यह भी वैकल्पिक है।</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">([\/, ]+)</code>: यह भाग टैग के बाद आने वाले स्लैश (<code class="language-plaintext highlighter-rouge">/</code>) या कॉमा (<code class="language-plaintext highlighter-rouge">,</code>) और स्पेस को कैप्चर करता है।</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">/is</code>: यह फ्लैग्स हैं जो रेगुलर एक्सप्रेशन को केस-इनसेंसिटिव (<code class="language-plaintext highlighter-rouge">i</code>) और सिंगल लाइन मोड (<code class="language-plaintext highlighter-rouge">s</code>) में चलाने के लिए उपयोग किए जाते हैं।</p>
  </li>
</ul>

<p>यह रेगुलर एक्सप्रेशन HTML टैग्स और उनके एट्रिब्यूट्स को पार्स करने के लिए उपयोगी है, जैसे कि <code class="language-plaintext highlighter-rouge">&lt;div id="main" class="container" data-attr="value"&gt;</code>।</p>

<p>यह CSS चयनकर्ताओं (selectors) से मेल खाने के लिए उपयोग किया जाता है, जैसे कि <code class="language-plaintext highlighter-rouge">div &gt; ul</code>।</p>

<p>पहले मैंने ऐसे कई जटिल एक्सप्रेशन देखे हैं, और मैं हमेशा उनसे दूर भागता था। आज मैंने तय किया है कि इसे पूरी तरह से समझ लूंगा! आदमी को खुद पर थोड़ा सख्त होना चाहिए!</p>

<h3 id="div--ul-का-मिलान-करें"><code class="language-plaintext highlighter-rouge">div &gt; ul</code> का मिलान करें</h3>

<p>यह CSS चयनकर्ता (selector) उन <code class="language-plaintext highlighter-rouge">&lt;ul&gt;</code> तत्वों का चयन करता है जो किसी <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> तत्व के सीधे बच्चे (direct child) होते हैं। यहां एक उदाहरण दिया गया है:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div&gt;</span>
  <span class="nt">&lt;ul&gt;</span>
    <span class="nt">&lt;li&gt;</span>Item 1<span class="nt">&lt;/li&gt;</span>
    <span class="nt">&lt;li&gt;</span>Item 2<span class="nt">&lt;/li&gt;</span>
  <span class="nt">&lt;/ul&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>इस उदाहरण में, <code class="language-plaintext highlighter-rouge">&lt;ul&gt;</code> तत्व <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> का सीधा बच्चा है, इसलिए यह <code class="language-plaintext highlighter-rouge">div &gt; ul</code> चयनकर्ता से मेल खाएगा।</p>

<p>यदि <code class="language-plaintext highlighter-rouge">&lt;ul&gt;</code> तत्व किसी अन्य तत्व के अंदर नेस्टेड (nested) होता है, तो यह मेल नहीं खाएगा। उदाहरण के लिए:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div&gt;</span>
  <span class="nt">&lt;section&gt;</span>
    <span class="nt">&lt;ul&gt;</span>
      <span class="nt">&lt;li&gt;</span>Item 1<span class="nt">&lt;/li&gt;</span>
      <span class="nt">&lt;li&gt;</span>Item 2<span class="nt">&lt;/li&gt;</span>
    <span class="nt">&lt;/ul&gt;</span>
  <span class="nt">&lt;/section&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>इस मामले में, <code class="language-plaintext highlighter-rouge">&lt;ul&gt;</code> तत्व <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code> का सीधा बच्चा नहीं है, इसलिए यह <code class="language-plaintext highlighter-rouge">div &gt; ul</code> चयनकर्ता से मेल नहीं खाएगा।</p>

<p>मैंने एक वेबसाइट https://regex101.com/ ढूंढी है, जो ऑनलाइन मिलान करने और स्पष्टीकरण देने में सक्षम है।</p>

<p>हालांकि दाईं ओर के विवरण से कुछ स्पष्टता मिली है, लेकिन फिर भी यह स्पष्ट नहीं है कि वास्तव में मिलान कैसे किया जाता है। तो चलिए कुछ उदाहरण लेते हैं और एक-एक करके उनका विश्लेषण करते हैं।</p>

<p>इस रेगुलर एक्सप्रेशन का उपयोग करने वाला कोड निम्नलिखित है:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$matches</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nb">preg_match_all</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">trim</span><span class="p">(</span><span class="nv">$selector</span><span class="p">)</span><span class="mf">.</span><span class="s1">' '</span><span class="p">,</span> <span class="nv">$matches</span><span class="p">,</span> <span class="no">PREG_SET_ORDER</span><span class="p">);</span>
</code></pre></div></div>

<p>(यह कोड ब्लॉक PHP में है और इसे अनुवादित नहीं किया जाना चाहिए।)</p>

<p><code class="language-plaintext highlighter-rouge">preg_match_all</code> का मतलब है कि यह सभी स्ट्रिंग्स को प्राप्त करता है जो दिए गए पैटर्न से मेल खाते हैं। अगर हमारे पास यह है:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">preg_match_all</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">,</span> <span class="s2">"abcdabc"</span><span class="p">,</span> <span class="nv">$matches</span><span class="p">)</span>
</code></pre></div></div>

<p>यह PHP कोड <code class="language-plaintext highlighter-rouge">preg_match_all</code> फ़ंक्शन का उपयोग करता है। यह फ़ंक्शन एक स्ट्रिंग में एक पैटर्न के सभी मिलान ढूंढता है और उन्हें <code class="language-plaintext highlighter-rouge">$matches</code> नामक वेरिएबल में स्टोर करता है। इस उदाहरण में, पैटर्न <code class="language-plaintext highlighter-rouge">"abc"</code> है और स्ट्रिंग <code class="language-plaintext highlighter-rouge">"abcdabc"</code> है। इसलिए, यह <code class="language-plaintext highlighter-rouge">"abc"</code> पैटर्न को स्ट्रिंग में दो बार ढूंढेगा और <code class="language-plaintext highlighter-rouge">$matches</code> में स्टोर करेगा।</p>

<p>पहला पैरामीटर पैटर्न है, दूसरा पैरामीटर मिलान करने के लिए स्ट्रिंग है, और तीसरा पैरामीटर परिणाम संदर्भ है। चलाने के बाद, <code class="language-plaintext highlighter-rouge">$matches</code> सरणी में दो <code class="language-plaintext highlighter-rouge">abc</code> शामिल होंगे।</p>

<p>इस समझ के साथ, ऊपर दिए गए चित्र में <code class="language-plaintext highlighter-rouge">div &gt; ul</code> केवल पहले चार वर्णों <code class="language-plaintext highlighter-rouge">div &gt;</code> से मेल खाता है। क्या <code class="language-plaintext highlighter-rouge">regex101</code> <code class="language-plaintext highlighter-rouge">preg_match_all</code> का समर्थन नहीं करता है? कोई बात नहीं, बस <code class="language-plaintext highlighter-rouge">g</code> नामक एक संशोधक जोड़ें और यह काम कर जाएगा:</p>

<p><code class="language-plaintext highlighter-rouge">g</code> जोड़ने के बाद, यह सभी से मेल खाएगा, न कि केवल पहले से मिलने पर वापस आएगा।</p>

<p>जोड़ने के बाद, हमने <code class="language-plaintext highlighter-rouge">div &gt; ul</code> से मिलान किया:</p>

<p>दाईं ओर दिखाया गया है, पहले मिलान में, यानी <code class="language-plaintext highlighter-rouge">div</code>, हमने पहले समूह के नियमों का उपयोग करके <code class="language-plaintext highlighter-rouge">div</code> से मिलान किया, और फिर सातवें समूह के नियमों का उपयोग करके स्पेस ` ` से मिलान किया।</p>

<p>आइए पहले नियम समूह की व्याख्या पर नजर डालते हैं:</p>

<p>इस लंबी अभिव्यक्ति में, पहले कोष्ठक में बंद हिस्से को पहला समूह नियम कहा जाता है। यह एक कैप्चर समूह है। कोष्ठक स्वयं मेल नहीं खाते, बल्कि समूह बनाने के लिए उपयोग किए जाते हैं। <code class="language-plaintext highlighter-rouge">[]</code> एक वर्ण समूह को दर्शाता है, और इसके अंदर के नियम बताते हैं कि यह किस प्रकार का वर्ण समूह है। इस वर्ण समूह में शामिल हैं:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\w</code> बड़े और छोटे अक्षरों, 0 से 9 तक की संख्याओं और अंडरस्कोर (_) को दर्शाता है।</li>
  <li><code class="language-plaintext highlighter-rouge">-:</code> सीधे इन दोनों वर्णों को समूह में दर्शाता है।</li>
  <li><code class="language-plaintext highlighter-rouge">\*</code> क्योंकि <code class="language-plaintext highlighter-rouge">*</code> रेगुलर एक्सप्रेशन में एक आरक्षित वर्ण है और इसका विशेष अर्थ होता है, इसलिए इसे एक साधारण <code class="language-plaintext highlighter-rouge">*</code> वर्ण के रूप में दर्शाने के लिए <code class="language-plaintext highlighter-rouge">\</code> का उपयोग करके एस्केप किया जाता है।</li>
  <li><code class="language-plaintext highlighter-rouge">&gt;</code> सीधे <code class="language-plaintext highlighter-rouge">&gt;</code> वर्ण को दर्शाता है।</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">[\w-:\*&gt;]*</code> में अंतिम <code class="language-plaintext highlighter-rouge">*</code> यह दर्शाता है कि पिछले वर्ण 0 या अनेक बार आ सकते हैं, लेकिन जितना संभव हो उतनी बार मेल खाने का प्रयास किया जाएगा। यह <code class="language-plaintext highlighter-rouge">div</code> से मेल खाता है क्योंकि <code class="language-plaintext highlighter-rouge">\w</code> ने <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">i</code>, और <code class="language-plaintext highlighter-rouge">v</code> से मेल खाया है। यह आगे के स्पेस से मेल नहीं खाता क्योंकि स्पेस <code class="language-plaintext highlighter-rouge">[]</code> में शामिल नहीं है। कैप्चर ग्रुप का अर्थ है कि यह मेल परिणाम सरणी में दिखाई देगा। इसके विपरीत नॉन-कैप्चर ग्रुप भी होते हैं, जिनका सिंटैक्स <code class="language-plaintext highlighter-rouge">(?:)</code> है। उपरोक्त <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> यदि इस परिणाम की आवश्यकता नहीं है, तो इसे <code class="language-plaintext highlighter-rouge">(?:[\w-:\*&gt;]*)</code> के रूप में लिखा जा सकता है।</p>

<p>तो परिणाम में नहीं दिखने के लिए, सीधे कोष्ठक का उपयोग न करना क्यों नहीं? कोष्ठक समूहीकरण के लिए होते हैं, और समूहीकरण का बहुत महत्व होता है। आप <a href="http://stackoverflow.com/questions/3512471/what-is-a-non-capturing-group">《What is a non capturing group? (?:) - StackOverflow》</a> को संदर्भित कर सकते हैं।</p>

<p><code class="language-plaintext highlighter-rouge">div</code> के पहले सेट के नियमों को पूरा करने के बाद, अब हम यह समझाएंगे कि स्पेस ` ` क्यों सातवें सेट के नियमों को पूरा करता है।</p>

<p><code class="language-plaintext highlighter-rouge">[\/, ]</code> का मतलब है कि यह इन चार वर्णों में से किसी एक से मेल खाता है, और <code class="language-plaintext highlighter-rouge">+</code> का मतलब है कि पिछला मिलान एक या अनेक बार होता है, और जितना संभव हो उतनी बार होता है। इसलिए, क्योंकि इन चार वर्णों में स्पेस भी शामिल है, यह हमारे स्पेस से मेल खाता है। और क्योंकि <code class="language-plaintext highlighter-rouge">div </code> के बाद अगला वर्ण <code class="language-plaintext highlighter-rouge">&gt;</code> है, इसलिए यह सातवें समूह के नियम को पूरा नहीं करता है, और आगे मेल नहीं खाता है।</p>

<p><code class="language-plaintext highlighter-rouge">div</code> का मिलान समझ में आ गया है। तो फिर दूसरे से छठे समूह के नियमों ने यहां के रिक्त स्थान का मिलान क्यों नहीं किया, बल्कि उन्हें सातवें समूह के लिए छोड़ दिया?</p>

<p>दूसरे भाग की व्याख्या:</p>

<p>सबसे पहले, <code class="language-plaintext highlighter-rouge">(?:)</code> यह दर्शाता है कि यह एक नॉन-कैप्चरिंग ग्रुप है। अंत में आया <code class="language-plaintext highlighter-rouge">?</code> यह दर्शाता है कि इससे पहले का मिलान 0 या 1 बार हो सकता है। इसलिए ऊपर दिया गया <code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code> हो सकता है या नहीं भी हो सकता है। बाहरी मॉडिफायर को हटाने के बाद, जो बचता है वह है <code class="language-plaintext highlighter-rouge">\#([\w-]+)|\.([\w-]+)</code>, जहां बीच का <code class="language-plaintext highlighter-rouge">|</code> “या” को दर्शाता है, यानी इनमें से कोई एक मिलान होना चाहिए। <code class="language-plaintext highlighter-rouge">\#([\w-]+)</code> में <code class="language-plaintext highlighter-rouge">\#</code> <code class="language-plaintext highlighter-rouge">#</code> कैरेक्टर से मिलान करता है, और <code class="language-plaintext highlighter-rouge">[\w-]+</code> अन्य कैरेक्टर्स से मिलान करता है। फिर, दूसरे हिस्से में, <code class="language-plaintext highlighter-rouge">\.([\w-]+)</code> में <code class="language-plaintext highlighter-rouge">.</code> <code class="language-plaintext highlighter-rouge">.</code> कैरेक्टर से मिलान करता है।</p>

<p>इसलिए 2 से 6 समूह संभवतः रिक्त स्थान के कारण संतुष्ट नहीं हो सकते हैं क्योंकि ये समूह रिक्त स्थान को अपने शुरुआती वर्ण के रूप में नहीं मांगते हैं। चूंकि इन समूहों में एक <code class="language-plaintext highlighter-rouge">?</code> संशोधक है, इसलिए यदि वे संतुष्ट नहीं होते हैं तो भी कोई समस्या नहीं है, और इसलिए यह सातवें समूह पर कूद जाता है।</p>

<p><code class="language-plaintext highlighter-rouge">div &gt; ul</code> के बाद आने वाला <code class="language-plaintext highlighter-rouge">&gt;</code> भी वैसा ही है:</p>

<p>पहला नियम <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> ने <code class="language-plaintext highlighter-rouge">&gt;</code> को मैच किया, और सातवां नियम <code class="language-plaintext highlighter-rouge">([\/, ]+)</code> ने स्पेस को मैच किया। फिर <code class="language-plaintext highlighter-rouge">ul</code> भी <code class="language-plaintext highlighter-rouge">div</code> की तरह काम करता है।</p>

<h3 id="मिलान-करें-answer-4185009--table--tbody--tdanswercell--div--pre">मिलान करें <code class="language-plaintext highlighter-rouge">#answer-4185009 &gt; table &gt; tbody &gt; td.answercell &gt; div &gt; pre</code></h3>

<p>यह एक CSS सेलेक्टर है जो HTML डॉक्यूमेंट में एक विशिष्ट एलिमेंट को टार्गेट करता है। यह सेलेक्टर निम्नलिखित तरीके से काम करता है:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">#answer-4185009</code> - ID <code class="language-plaintext highlighter-rouge">answer-4185009</code> वाले एलिमेंट को चुनता है।</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; table</code> - उस एलिमेंट के सीधे बच्चे (direct child) के रूप में <code class="language-plaintext highlighter-rouge">table</code> एलिमेंट को चुनता है।</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; tbody</code> - उस <code class="language-plaintext highlighter-rouge">table</code> एलिमेंट के सीधे बच्चे के रूप में <code class="language-plaintext highlighter-rouge">tbody</code> एलिमेंट को चुनता है।</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; td.answercell</code> - उस <code class="language-plaintext highlighter-rouge">tbody</code> एलिमेंट के सीधे बच्चे के रूप में <code class="language-plaintext highlighter-rouge">td</code> एलिमेंट को चुनता है जिसकी क्लास <code class="language-plaintext highlighter-rouge">answercell</code> है।</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; div</code> - उस <code class="language-plaintext highlighter-rouge">td</code> एलिमेंट के सीधे बच्चे के रूप में <code class="language-plaintext highlighter-rouge">div</code> एलिमेंट को चुनता है।</li>
  <li><code class="language-plaintext highlighter-rouge">&gt; pre</code> - उस <code class="language-plaintext highlighter-rouge">div</code> एलिमेंट के सीधे बच्चे के रूप में <code class="language-plaintext highlighter-rouge">pre</code> एलिमेंट को चुनता है।</li>
</ol>

<p>यह सेलेक्टर HTML डॉक्यूमेंट में एक विशिष्ट <code class="language-plaintext highlighter-rouge">pre</code> एलिमेंट को टार्गेट करता है जो उपरोक्त पदानुक्रम में स्थित होता है।</p>

<p>अब एक थोड़ा और जटिल चयनकर्ता (selector) आता है <code class="language-plaintext highlighter-rouge">#answer-4185009 &gt; table &gt; tbody &gt; td.answercell &gt; div &gt; pre</code> (आप इसे https://regex101.com/ पर खोलकर वहाँ पेस्ट करके टेस्ट भी कर सकते हैं):</p>

<p>यह Chrome से कॉपी-पेस्ट किया गया है:</p>

<p>पहला मिलान:</p>

<p>क्योंकि पहले समूह के नियम <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> में <code class="language-plaintext highlighter-rouge">[]</code> के अंदर के कैरेक्टर सेट में कोई भी <code class="language-plaintext highlighter-rouge">#</code> से मेल नहीं खाता, और फिर अंत में <code class="language-plaintext highlighter-rouge">*</code> 0 या अनेक बार मेल खाने का समर्थन करता है, यहां यह 0 बार है। फिर दूसरे समूह के नियम का विवरण है:</p>

<p>ऊपर पहले ही विश्लेषण किया जा चुका है। सीधे <code class="language-plaintext highlighter-rouge">|</code> से पहले के <code class="language-plaintext highlighter-rouge">\#([\w-]+)</code> को देखें, <code class="language-plaintext highlighter-rouge">\#</code> ने <code class="language-plaintext highlighter-rouge">#</code> को मैच कर दिया है, और <code class="language-plaintext highlighter-rouge">[\w-]+</code> ने <code class="language-plaintext highlighter-rouge">answer-4185009</code> को मैच कर दिया है। इसके बाद वाला <code class="language-plaintext highlighter-rouge">\.([\w-]+)</code>, अगर <code class="language-plaintext highlighter-rouge">.answer-4185009</code> होता तो यह मैच लागू होता।</p>

<p>अगला, <code class="language-plaintext highlighter-rouge">td.answercell</code> इस मिलान को देखते हैं,</p>

<p>पहले समूह का नियम <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code> ने <code class="language-plaintext highlighter-rouge">td</code> से मेल खाया, और दूसरे बड़े हिस्से <code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code> के बाद वाले हिस्से, यानी <code class="language-plaintext highlighter-rouge">\.([\w-]+)</code>, ने <code class="language-plaintext highlighter-rouge">.answercell</code> से मेल खाया।</p>

<p>इस चयनकर्ता (selector) का विश्लेषण यहीं समाप्त होता है।</p>

<h3 id="ahrefhttpgooglecom-से-मिलान-करें"><code class="language-plaintext highlighter-rouge">a[href="http://google.com/"]</code> से मिलान करें</h3>

<p>यह CSS सेलेक्टर उन <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> टैग्स को चुनता है जिनका <code class="language-plaintext highlighter-rouge">href</code> एट्रिब्यूट <code class="language-plaintext highlighter-rouge">http://google.com/</code> के बराबर होता है। यह सेलेक्टर बहुत सटीक है और केवल उन्हीं लिंक्स को मैच करेगा जिनका <code class="language-plaintext highlighter-rouge">href</code> एट्रिब्यूट बिल्कुल <code class="language-plaintext highlighter-rouge">http://google.com/</code> होगा।</p>

<p>उदाहरण:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"http://google.com/"</span><span class="nt">&gt;</span>Google<span class="nt">&lt;/a&gt;</span> <span class="c">&lt;!-- यह मैच होगा --&gt;</span>
<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"https://google.com/"</span><span class="nt">&gt;</span>Google<span class="nt">&lt;/a&gt;</span> <span class="c">&lt;!-- यह मैच नहीं होगा --&gt;</span>
<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"http://google.com"</span><span class="nt">&gt;</span>Google<span class="nt">&lt;/a&gt;</span> <span class="c">&lt;!-- यह मैच नहीं होगा (अंत में '/' नहीं है) --&gt;</span>
</code></pre></div></div>

<p>इस सेलेक्टर का उपयोग करके आप सटीक रूप से उन लिंक्स को स्टाइल या मैनिपुलेट कर सकते हैं जो सीधे <code class="language-plaintext highlighter-rouge">http://google.com/</code> की ओर इशारा करते हैं।</p>

<p>अगले चरण में हम सेलेक्टर <code class="language-plaintext highlighter-rouge">a[href="http://google.com/"]</code> को मैच करेंगे:</p>

<p>तीसरे बड़े ब्लॉक को देखें:</p>

<p>तीसरे ब्लॉक का एक्सप्रेशन है <code class="language-plaintext highlighter-rouge">(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?</code>। सबसे पहले, बाहरी <code class="language-plaintext highlighter-rouge">(?:)</code> इंगित करता है कि यह एक नॉन-कैप्चरिंग ग्रुप है, और अंत में <code class="language-plaintext highlighter-rouge">?</code> इंगित करता है कि यह पूरा बड़ा ब्लॉक 0 या 1 बार मैच कर सकता है। इसे हटाने के बाद यह <code class="language-plaintext highlighter-rouge">\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\]</code> बन जाता है। <code class="language-plaintext highlighter-rouge">\[</code> <code class="language-plaintext highlighter-rouge">[</code> कैरेक्टर को मैच करता है। <code class="language-plaintext highlighter-rouge">@?</code> इंगित करता है कि <code class="language-plaintext highlighter-rouge">@</code> कैरेक्टर वैकल्पिक है। अगला ग्रुप <code class="language-plaintext highlighter-rouge">(!?[\w-:]+)</code> है, जहां <code class="language-plaintext highlighter-rouge">!</code> वैकल्पिक है और <code class="language-plaintext highlighter-rouge">[\w-:]+</code> <code class="language-plaintext highlighter-rouge">href</code> को मैच करता है। इसके बाद का ग्रुप <code class="language-plaintext highlighter-rouge">(?:([!*^$]?=)["']?(.*?)["']?)</code> एक नॉन-कैप्चरिंग ग्रुप है, जिसे हटाने के बाद यह <code class="language-plaintext highlighter-rouge">([!*^$]?=)["']?(.*?)["']?</code> बन जाता है। यहां <code class="language-plaintext highlighter-rouge">([!*^$]?=)</code> में <code class="language-plaintext highlighter-rouge">[!*^$]?</code> इंगित करता है कि <code class="language-plaintext highlighter-rouge">[]</code> के अंदर के कैरेक्टर्स में से 0 या 1 को मैच किया जाए। फिर <code class="language-plaintext highlighter-rouge">=</code> सीधे मैच होता है। इसके बाद <code class="language-plaintext highlighter-rouge">["']?(.*?)["']?</code> <code class="language-plaintext highlighter-rouge">"http://google.com/"</code> को मैच करता है, जहां <code class="language-plaintext highlighter-rouge">["']?</code> इंगित करता है कि <code class="language-plaintext highlighter-rouge">"</code> या <code class="language-plaintext highlighter-rouge">'</code> या दोनों में से कोई भी नहीं मैच हो सकता है। इस बाहरी हिस्से को हटाने के बाद <code class="language-plaintext highlighter-rouge">(.*?)</code> <code class="language-plaintext highlighter-rouge">http://google.com/</code> को मैच करता है, जहां <code class="language-plaintext highlighter-rouge">*?</code> इंगित करता है कि जितना संभव हो उतना कम मैच किया जाए। इसका मतलब है कि अगर <code class="language-plaintext highlighter-rouge">"</code> या <code class="language-plaintext highlighter-rouge">'</code> है, तो उसे बाद के एक्सप्रेशन <code class="language-plaintext highlighter-rouge">["']?</code> को मैच करने के लिए छोड़ दिया जाए। इसलिए यह <code class="language-plaintext highlighter-rouge">http://google.com/"</code> को नहीं, बल्कि केवल <code class="language-plaintext highlighter-rouge">http://google.com/</code> को मैच करता है। इस प्रकार, पूरा सेलेक्टर <code class="language-plaintext highlighter-rouge">a[href="http://google.com/</code> हो जाता है।</p>

<p><code class="language-plaintext highlighter-rouge">"]</code> 就匹配结束了。</p>

<h3 id="सारांश">सारांश</h3>

<p>आखिरकार समझ में आ गया! चलिए एक बार फिर से स्पष्ट करते हैं, पहले पूरे जटिल एक्सप्रेशन <code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)(?:\#([\w-]+)|\.([\w-]+))?(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?([\/, ]+)</code> को चार मुख्य भागों में विभाजित करते हैं:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">([\w-:\*&gt;]*)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(?:\#([\w-]+)|\.([\w-]+))?</code></li>
  <li><code class="language-plaintext highlighter-rouge">(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)["']?(.*?)["']?)?\])?</code></li>
  <li><code class="language-plaintext highlighter-rouge">([\/, ]+)</code></li>
</ul>

<p>ये रेगुलर एक्सप्रेशन (Regular Expressions) हैं जिनका उपयोग विभिन्न पैटर्न को मैच करने के लिए किया जाता है। इन्हें हिंदी में अनुवाद करने की आवश्यकता नहीं है क्योंकि ये कोड के हिस्से हैं और इन्हें उनके मूल रूप में ही रखा जाना चाहिए।</p>

<p>सबसे जटिल तीसरा भाग इन कुछ हिस्सों से मिलकर बना है:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\[</code></li>
  <li><code class="language-plaintext highlighter-rouge">(!?[\w-:]+)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(?:([!*^$]?=)["']?(.*?)["']?)?</code></li>
  <li><code class="language-plaintext highlighter-rouge">\]</code></li>
</ul>

<p>यह एक regex (रेगुलर एक्सप्रेशन) है जो किसी विशेष पैटर्न को मैच करने के लिए उपयोग किया जाता है। इसे हिंदी में समझाने का प्रयास करते हैं:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">\[</code> - यह एक स्क्वायर ब्रैकेट <code class="language-plaintext highlighter-rouge">[</code> को मैच करता है।</li>
  <li><code class="language-plaintext highlighter-rouge">(!?[\w-:]+)</code> - यह एक ग्रुप है जो एक या अधिक वर्ड कैरेक्टर्स (अक्षर, संख्या, अंडरस्कोर), हाइफन, या कोलन को मैच करता है। इससे पहले एक ऑप्शनल <code class="language-plaintext highlighter-rouge">!</code> हो सकता है।</li>
  <li><code class="language-plaintext highlighter-rouge">(?:([!*^$]?=)["']?(.*?)["']?)?</code> - यह एक नॉन-कैप्चरिंग ग्रुप है जो ऑप्शनल है। यह एक ऑपरेटर (<code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">*=</code>, <code class="language-plaintext highlighter-rouge">^=</code>, <code class="language-plaintext highlighter-rouge">$=</code>) को मैच कर सकता है, और उसके बाद एक ऑप्शनल कोटेड स्ट्रिंग (सिंगल या डबल कोट्स में) को मैच करता है।</li>
  <li><code class="language-plaintext highlighter-rouge">\]</code> - यह एक स्क्वायर ब्रैकेट <code class="language-plaintext highlighter-rouge">]</code> को मैच करता है।</li>
</ol>

<p>इस regex का उपयोग अक्सर HTML या XML जैसी भाषाओं में एट्रिब्यूट्स को पार्स करने के लिए किया जाता है।</p>

<p>इसलिए ये सभी छोटे-छोटे हिस्से एक-एक करके समझे जा सकते हैं। फिर और उदाहरण ढूंढें, देखें कि प्रत्येक उदाहरण कैसे मेल खाता है, और साथ ही https://regex101.com/ की व्याख्या का उपयोग करके विश्लेषण करें। इस तरह, यह जटिल लगने वाला रेगुलर एक्सप्रेशन समझ में आ जाएगा, और पता चलेगा कि यह एक कागजी शेर है!</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-hi" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
