<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>تحسين هندسة البرمجيات للذكاء الاصطناعي</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>تحسين هندسة البرمجيات للذكاء الاصطناعي | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="تحسين هندسة البرمجيات للذكاء الاصطناعي" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="ar" />
<meta name="description" content="فهرس" />
<meta property="og:description" content="فهرس" />
<link rel="canonical" href="https://lzwjava.github.io/engineering-optimized-ai-ar" />
<meta property="og:url" content="https://lzwjava.github.io/engineering-optimized-ai-ar" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-07-27T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="تحسين هندسة البرمجيات للذكاء الاصطناعي" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2025-07-27T00:00:00+08:00","datePublished":"2025-07-27T00:00:00+08:00","description":"فهرس","headline":"تحسين هندسة البرمجيات للذكاء الاصطناعي","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/engineering-optimized-ai-ar"},"url":"https://lzwjava.github.io/engineering-optimized-ai-ar"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=4ba61b8ce89505d1538a7b863ffbe5946ebb831a">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=4ba61b8ce89505d1538a7b863ffbe5946ebb831a" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       تحسين هندسة البرمجيات للذكاء الاصطناعي | أصلي، ترجم بواسطة AI
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/ar/2025-07-27-engineering-optimized-ai-ar.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsar2025-07-27-engineering-optimized-ai-ar.md</span> -->
      

      <!-- <span>2025-07-27-engineering-optimized-ai-ar.md</span> -->

      
        

        
          
          <a href="#" class="button">2025.07</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/engineering-optimized-ai-en" >English</option>
        <option value="/engineering-optimized-ai-zh" >中文</option>
        <option value="/engineering-optimized-ai-ja" >日本語</option>
        <option value="/engineering-optimized-ai-es" >Español</option>
        <option value="/engineering-optimized-ai-hi" >हिंदी</option>
        <option value="/engineering-optimized-ai-fr" >Français</option>
        <option value="/engineering-optimized-ai-de" >Deutsch</option>
        <option value="/engineering-optimized-ai-ar" selected>العربية</option>
        <option value="/engineering-optimized-ai-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <h3 id="فهرس">فهرس</h3>

<ol>
  <li><a href="#optimizing-software-engineering-for-ai">تحسين هندسة البرمجيات لأجل الذكاء الاصطناعي</a>
    <ul>
      <li>هندسة معمارية مسطحة لتطوير الذكاء الاصطناعي الأول</li>
      <li>مزايا لغة بايثون في سير العمل التي تدفعها الذكاء الاصطناعي</li>
      <li>هندسة السياق وتحسين الرموز</li>
      <li>تنظيم الكود لمساعدة الذكاء الاصطناعي</li>
    </ul>
  </li>
  <li><a href="#thriving-as-a-manual-ai-agent">الازدهار كوكيل يدوي للذكاء الاصطناعي</a>
    <ul>
      <li>العمل مع أدوات الذكاء الاصطناعي في بيئات الشركات</li>
      <li>اختيار الأدوات وإدارة السياق</li>
      <li>بناء أنظمة التوجيه القابلة لإعادة الاستخدام</li>
    </ul>
  </li>
  <li><a href="#leveraging-python-for-java-development">استغلال بايثون لتطوير جافا</a>
    <ul>
      <li>Scripts بايثون لدعم مشاريع جافا</li>
      <li>استراتيجيات تطوير متعددة اللغات</li>
      <li>توليد الكود بمساعدة الذكاء الاصطناعي</li>
    </ul>
  </li>
  <li><a href="#programming-languages-in-the-ai-era">لغات البرمجة في عصر الذكاء الاصطناعي</a>
    <ul>
      <li>مستقبل بايثون، رست، وجافا
 الأداء مقابل التبسيط
 تطور اللغة ودمج الذكاء الاصطناعي</li>
    </ul>
  </li>
</ol>

<h3 id="تحسين-هندسة-البرمجيات-لأجل-الذكاء-الاصطناعي">تحسين هندسة البرمجيات لأجل الذكاء الاصطناعي</h3>

<p>في هذا المقال، استخدمت مئات scripts للمساعدة في الترجمة، وarea of play، وصيانة frontmatter، وrobots Telegram. أعتقد أن هذا النهج في التطوير قد يمثل مستقبل هندسة البرمجيات المحسنة لأجل الذكاء الاصطناعي.</p>

<p>لا أعتمد كثيرًا على وظائف modules بايثون، ولا أريد تنظيم الكود مثل مشروع جافا Spring الكبير.</p>

<p>لقد عملت على العديد من مشاريع البرمجيات طوال مسيرتي المهنية. لقد شاهدت هندسة بنكية مذهلة، وميكروسيرفيس، وتصاميم متعددة الدول التي تقلل من التكرار، وإطارات أساسية قوية مبنية على Spring، وحكم قوي مع تكوين مركزي.</p>

<p>على الرغم من أن هذه الهياكل البنكية مذهلة، إذا بدأنا اليوم، سأفكر في تحسينها لأجل LLMs والذكاء الاصطناعي. وهذا يعني تحسين هندسة السياق، وفصل المسؤليات بشكل أفضل، وتفضيل التفكير الأولي للذكاء الاصطناعي على التصميم الموجه للإنسان. على الرغم من أن Spring يوفر طبقات متعددة وتعميمًا جيدًا، إلا أنه قد يكون صعبًا على LLMs والذكاء الاصطناعي التنقل فيه.</p>

<p>أعتقد أننا يجب أن نسعى إلى هياكل أكثر مسطحية، مثل منظمة مسطحة. وهذا يعني استخدام مستوىين فقط: المستوى الأول يدعو المستوى الثاني. في دالة، من الأفضل أن ندعو 50 دالة مباشرة بدلاً من وجود 50 مستوى متداخل أو كومة. يتعثر الذكاء الاصطناعي/LLMs في الحكم أو الاستنتاج الهياكل المعقدة والمتداخلة جدًا، لكنهم يتفوقون في التعامل مع الدوال الصغيرة التي تحتوي على 100 إلى 200 سطر من الكود. بايثون مناسبة جدًا لدعوة واستيراد من ملفات أخرى.</p>

<p>أحد الأسباب التي تجعل كود بايثون أسهل من جافا هو أن إدارة الاعتمادات فيه بسيطة. كل ما عليك فعله هو استخدام <code class="language-plaintext highlighter-rouge">pip install</code> لإضافة الاعتماد. مع Maven، عليك كتابة الاعتماد في ملف POM XML ثم استخدام <code class="language-plaintext highlighter-rouge">mvn compile</code> لتحميل الاعتمادات.</p>

<p>سبب آخر لتبسيط بايثون هو أن كودها يمكن تشغيله مباشرة دون عناء.</p>

<p>على الرغم من أن بدء جافا 11، يمكن للامر <code class="language-plaintext highlighter-rouge">java</code> تنفيذ برامج الكود المصدر ذات الملف الواحد مباشرة دون الحاجة إلى تجميعها بشكل منفصل باستخدام <code class="language-plaintext highlighter-rouge">javac</code>. ومع ذلك، غالبًا ما تكون مشاريع جافا كبيرة، لذا يجب تشغيلها مع <code class="language-plaintext highlighter-rouge">mvn spring-boot:run</code> بالإضافة إلى بعض تكوين الخصائص.</p>

<p>سبب ثالث هو أن تصميم modules بايثون بسيط؛ يمكنك استخدام <code class="language-plaintext highlighter-rouge">from</code> و <code class="language-plaintext highlighter-rouge">import</code> لاستيراد الكود من ملفات أخرى بسهولة.</p>

<p>في الوقت الحالي، يمكن العديد من روبوتات الدردشة الذكاء الاصطناعي تشغيل كود بايثون مباشرة في نافذة الدردشة، مثل Grok.</p>

<p>عند مقارنته بين 100 ملف جافا، كل منها يحتوي على حوالي 1000 سطر من الكود، مع بعض scripts بايثون البسيطة، فإن هذا ليس مقارنًا عادلًا. بالنسبة لهذا النوع من المشروع، سأفضل أن يكون هناك 1000 ملف بايثون، كل منها يحتوي على حوالي 100 سطر من الكود.</p>

<p>من المقبول اختيار أسطر الكود أو دالة للتعديل. ولكن عليك أن تعرف أين تختار. لماذا لا نترك هذه المهمة للذكاء الاصطناعي لتسهيل حياتنا؟ لذا، كل ما علينا فعله هو استخدام “اختر الكل” لاختيار جميع الكود وتخبر الذكاء الاصطناعي/LLM كيف يتم التعديل.</p>

<p>بالنسبة لبايثون، من الأسهل استخدام <code class="language-plaintext highlighter-rouge">if __name__ == "__main__":</code> لتشغيل واختبار الدوال في ملف. كما من الأسهل للملفات بايثون الأخرى استدعاء الدوال داخل هذا الملف دون الحاجة إلى تشغيل الاختبار.</p>

<p>هذا هو هندسة السياق المحسنة للذكاء الاصطناعي. هل يمكننا الوصول إليه بطرق أخرى؟ الذكاء الاصطناعي/LLM هو تكراري تلقائي. ومع ذلك، عندما نستخدم Copilot أو Claude Code، لا نعرف كيف يساعدنا الذكاء الاصطناعي Software Agent. يجب عليهم التفكير فيه بدلاً مننا.</p>

<p>هل يمكننا، من جانب المستخدم، تنظيم الكود بشكل خاص لتقليل استخدام الرموز؟ بالنسبة لهذا النقطة، فإن نهج وجود 1000 ملف بايثون، كل منها يحتوي على 100 سطر من الكود، جيد لهذا الغرض. لأنك يمكنك التحقق من الدوال والملفات الكود بسهولة قبل السماح للكود بايثون الآخر بالاتصال بهم.</p>

<p>لكن هناك مشكلة واحدة وهي أنه إذا كنت تريد تغيير عدة ملفات من الكود معًا، فإن ذلك ليس سهلا. طريقة بسيطة هي نسخ الكود إلى روبوتات الدردشة الذكاء الاصطناعي وتركهم يخبرونك كيف تعدل الكود في هذه الملفات.</p>

<p>من الممكن أن لا نحتاج إلى استخدام عدد الأسطر لفصل الدوال أو المنطق. ولكن يجب علينا القيام بذلك لفصل المنطق إلى دوال صغيرة. يمكننا القيام بذلك عن طريق فصلهم بشكل طبيعي حسب نوع المنطق، حتى يبدو أقصر.</p>

<p>لماذا نريد هندسة البرمجيات المحسنة للذكاء الاصطناعي؟ لأن الذكاء الاصطناعي قوي، يجب أن نتحسن كل شيء للذكاء الاصطناعي ثم نترك الذكاء الاصطناعي يساعد هندسة البرمجيات قدر الإمكان.</p>

<p>هذا ممكن ليس فقط للكود، ولكن أيضًا لأي نص. افترض أننا نكون محررين متحفظين؛ لا نريد للذكاء الاصطناعي تحرير نصوصنا الكبيرة دفعة واحدة. نريد التحقق من الفقرة بعد الفقرة. بالنسبة للكود، يمكننا تحمل الأخطاء أو العيوب الصغيرة. بالنسبة للنص، يمكننا تحملها لأن معظم القراء ليسوا متحفظين جدًا.</p>

<p>لكن الكود مختلف في أنه أحيانًا، حتى خطأ صغير يمكن أن يؤدي إلى فشل كامل لمشروع كبير.</p>

<p>بالنسبة لملفات XML أو YAML، ربما لا نحتاج إلى فصلها كثيرًا لأنهما بالفعل altamente strutturati.</p>

<p>وللملفات HTML، يجب أن نفعل بعض الفصل. بدلاً من كتابة مئات ملفات JavaScript مع مئات ملفات HTML، مما يجعل من السهل تجاوز 1000 سطر من الكود، يجب أن نستخدم <code class="language-plaintext highlighter-rouge">import</code> لـ JavaScript لإدارة ذلك. بالنسبة لكود JavaScript، يمكننا استخدام الطرق المذكورة أعلاه للفصل.</p>

<p>نريد تنظيم الكود بطريقة تتيح للذكاء الاصطناعي مساعدتنا بسهولة في إضافة، تحرير، حذف، وتشغيل الكود. هذا هو البداية. تخيل يومًا عندما يمكن للذكاء الاصطناعي توليد أو إصلاح جميع الكود بسهولة. العالم سيصبح رقميًا للغاية.</p>

<p>تصور نفسي أكتب 100 مشروع برمجي كبير وأقدم واجهة برمجة التطبيقات للاتصال بالآخرين. وهذا يشمل جدول أعمالي اليومي؛ أنا، بنفسي، مثل شركة تكنولوجية تضم 1000 موظف اليوم. هم مصممون لتلبية احتياجاتي، لكسب المال أو إنفاقه من أجل فوائدي. هذا حقًا مذهل.</p>

<h3 id="الازدهار-كوكيل-يدوي-للذكاء-الاصطناعي">الازدهار كوكيل يدوي للذكاء الاصطناعي</h3>

<p>يجب تشغيل وكيل الذكاء الاصطناعي تلقائيًا مع الكود. الآن، عنوان هذا المقال هو “وكيل الذكاء الاصطناعي اليدوي”. قد تظن أنني أضحك، لكن هذا ليس هو الحال.</p>

<p>السبب الذي يجعلني أقول “وكيل الذكاء الاصطناعي اليدوي” هو أن الشركات الكبيرة تباطؤ في تبني التكنولوجيا بسبب مخاوف تتعلق بالأمان والبيانات والاعتبارات طويلة الأجل.</p>

<p>هناك العديد من التقنيات الجديدة في السوق؛ من يعرف ما سيبقى وما سيختفي بسرعة.</p>

<p>لديهم أيضًا مخاوف بشأن الأمن والبيانات. عادةً ما يفضلون الشراكة مع العلامات التجارية الكبيرة التي سياساتها المتعلقة بالبيانات صارمة ومراقبة من قبل الجمهور. هذا يشرح لماذا أصبحت مايكروسوفت شريكًا رئيسيًا بين شركات فورشن 500. الشركات الأخرى تستخدم Teams، Microsoft Office 365، Azure، وCopilot.</p>

<p>لكن ماذا لو لم تقدم الشركات الكبيرة لموظفيها واجهة برمجة التطبيقات للذكاء الاصطناعي لتستخدمها؟ يجب أن نفكر في كيفية العمل كوكيل ذكاء اصطناعي يدوي.</p>

<p>هذا يعني أننا سنستخدم العديد من الأدوات للعمل، بشكل مشابه لاستخدام الأدوات أو استدعاء الدوال في هذه الواجهات البرمجية. سنقوم بتحسين التوجيه أو هندسة السياق الخاص بنا.</p>

<p>بدلاً من استخدام Claude Code أو Manus لإجراء مهمة معقدة، قد نؤدي المهام بأنفسنا مع روبوت دردشة الذكاء الاصطناعي البسيط.</p>

<p>AspectJ جيدة لأنها تستخدم برمجة AOP لالتقاط الطرق. مرشحات Spring جيدة أيضًا لالتقاط سجلات طلبات HTTP. سجلات Log4j جيدة لتوجيه سجلات محددة إلى ملف. IntelliJ IDEA جيدة لأنها تحتوي على دالة لتصدير الكائنات كنص.</p>

<p>عملاء SQL جيدون لأنهم يمكنهم تصدير ملفات CSV أو Excel لصفوف. Git diff جيد لأنه يمكن أن يعطيك نصًا مقارنًا.</p>

<p>كلها تساعدك في تقديم سياق أفضل لروبوتات الدردشة الذكاء الاصطناعي. ويمكن لروبوتات الدردشة الذكاء الاصطناعي أيضًا مساعدتها في أداء العديد من scripts بايثون للمهام.</p>

<p>لتكون وكيل ذكاء اصطناعي فعالًا، يجب أن تستخدم العديد من الأدوات الفعالة لمساعدتك في أداء المهام، سواء كانت بسيطة أو معقدة.</p>

<p>بدون واجهة برمجة التطبيقات لروبوتات الدردشة الذكاء الاصطناعي/الذكاء الاصطناعي، يجب عليك نسخ النص إلى الروبوتات. هذا أكثر تعبًا قليلاً من استدعاء الذكاء الاصطناعي مباشرة، لكن الخبر السار هو أنك يمكنك اختيار السياق أو التوجيهات بعناية أكبر.</p>

<p>لذلك، لا تحتاج إلى طرح أسئلة على روبوتات الدردشة الذكاء الاصطناعي عدة مرات مثل تلك الوكلاء الذكاء الاصطناعي الآلية. يمكنك اختيار الأدوات التي ستستخدمها بعناية.</p>

<p>لذلك، العمل مثل وكيل الذكاء الاصطناعي اليدوي له مزايا. ومع ذلك، تتطور تكنولوجيا وكيل الذكاء الاصطناعي بسرعة وتظهر إمكانياتها للعالم.</p>

<p>إذا كانوا مفيدين جدًا، ستتبنى الشركات الكبيرةهم مثل روبوتات الدردشة الذكاء الاصطناعي. وإلا، لن يتمكنوا من المنافسة مع الشركات الأخرى التي تبنتهم - ليس فقط الشركات الكبيرة، ولكن أيضًا الشركات الناشئة الصغيرة. لأن الذكاء الاصطناعي قوي جدًا الآن، قد تفوق شركة ناشئة تضم عشرات الموظفين على تلك التي تضم 1000 موظف.</p>

<p>العمل كوكيل ذكاء اصطناعي يدوي أحيانًا لا مفر منه. الوظيفة لها فوائد أخرى بالإضافة إلى نقص التكنولوجيا الذكاء الاصطناعي المتقدمة. ليس من السهل العثور على وظائف جيدة أيضًا. لذلك، في هذه الحالة، يحدث لنا مساحة لاستخدام حكمةنا التقليدية لاستغلال روبوتات الدردشة الذكاء الاصطناعي بأفضل طريقة.</p>

<p>وهذا يعني أننا يمكننا تنظيم وتجميع توجيهاتنا لإنشاء توجيهات نظام لروبوتات الدردشة الذكاء الاصطناعي، مثل تلك المستخدمة من قبل Claude أو Grok التي تم الكشف عنها. بهذه الطريقة، لا نحتاج إلى كتابة توجيهات بشكل متكرر. يمكننا استخدام scripts بايثون لمساعدتنا في كتابة التوجيهات. يمكننا الحصول على سجلات طلبات HTTP وكتابة توجيهات لتوليد حالات اختبار واجهة برمجة التطبيقات.</p>

<p>سحر البرمجة يكمن في مستويات التجريد غير المحدودة. إنه مثل الدوال حيث يمكنك أن تكون لديك 100 مستوى من استدعاءات الدوال. على سبيل المثال، WeChat مبني على iOS، وWeChat Mini Programs مبني على WeChat. iOS نفسه مبني على Objective-C أو Swift، والتي بدورها مبنية على LLVM وجمع التعليمات الخاصة بشبكات ARM من آبل.</p>

<h3 id="استغلال-بايثون-لتطوير-جافا">استغلال بايثون لتطوير جافا</h3>

<p>كيف يمكن استخدام بايثون لمساعدة تطوير جافا في عصر الذكاء الاصطناعي؟ أحب بايثون. لقد عملت مع بايثون أكثر من أي لغة أخرى في السنوات الثلاث الأخيرة، منذ إطلاق ChatGPT في نهاية نوفمبر 2022.</p>

<p>واحدة من الطرق هي استخدام بايثون لكتابة scripts مساعدة SQL، وscripts الاختبار، وscripts البحث في السجلات لمشاريع جافا.</p>

<p>استخدم بايثون لتحليل ملفات POM وتعبئة الاعتمادات لمشاريع جافا. استخدم بايثون للتحقق من consistency البيانات في جافا. هناك العديد من الأشياء التي يمكننا القيام بها في بايثون بدلاً من جافا.</p>

<p>لكن جافا ليس لديها PyTorch. بايثون يمكن أن تساعد في أي شيء في 200 سطر من الكود الذي سيستغرق 500 سطر في جافا. ولكن باستخدام أدوات الذكاء الاصطناعي، لا يمكنك بسهولة الحصول على نسخة خاصة بك من PyTorch. حتى شيء مثل TinyGrad يستغرق وقتًا في البناء.</p>

<p>لماذا نكتب scripts الخاصة بنا أولًا؟ أحد الأسباب هو أنها قابلة للتخصيص بشكل كبير. لا توجد برامج أو مشاريع مفتوحة المصدر عامة يمكن أن تساعدنا مباشرة في مشاريعنا، خاصة تلك في الشركات الكبيرة.</p>

<p>المشاريع الكبيرة في الشركات الكبيرة تم تطويرها على مدى عقد من الزمن أو أكثر. لديهم بالفعل الكثير من التخصيص.</p>

<p>لذلك، في المستقبل، هناك العديد من المشاريع المحيطة بالمشاريع الكبيرة في الشركات الكبيرة. هناك المزيد من مرشحات الكود الداخلية مثل Claude في أدوات وكيل الترميز الداخلية في الشركات الكبيرة. هناك المزيد من Postman المخصص، وعملاء SQL، ومترجمين للشركات الكبيرة.</p>

<p>يمكن استخدام كود بايثون للاتصال بوكيل جافا أيضًا.</p>

<p>هذا يعني أنني بحاجة إلى تعلم بايثون وجافا جيدًا، حتى أعرف كيف أستخدم واحدة لمساعدة الأخرى.</p>

<p>ويمكنني استخدام بايثون بمساعدة الذكاء الاصطناعي لإنشاء العديد من الأشياء لنفسي ومشاريع الشركات أيضًا. جافا لا تبدو عائقًا. جافا، مع Spring، والقواعد البيانات، وAngular، Vue، أو React كواجهة المستخدم، لا يجب أن تكون عائقًا في مساعدة بايثون كثيرًا.</p>

<p>البرمجة شيء مرن جدًا. الحد هو خيالنا.</p>

<p>لذلك، الذكاء الاصطناعي ينمو بسرعة. يمكننا قياس تقدم الذكاء الاصطناعي من خلال مقدار ما يمكننا استخدامه بسهولة في الكود لتحقيق الأشياء بمساعدته في البرمجة والتعلم.</p>

<p>هل يمكننا يومًا كتابة بعض وكيل الذكاء الاصطناعي، ثم تساعد هذه الوكلاء في إنشاء TikTok بالكامل، بما في ذلك ميكروسيرفيسها الكبيرة ومشاريع iOS أو Android الكبيرة؟</p>

<p>إذا كان الذكاء الاصطناعي قويًا جدًا، فما علينا فعله اليوم؟ ربما لا شيء، لأن ما نفعله اليوم سيكون سهلا التنفيذ مع الذكاء الاصطناعي. في عام 2025، ربما يمكن إنجاز عملنا لمدة عام واحد بمساعدة الذكاء الاصطناعي في شهر واحد مع قدرات الذكاء الاصطناعي في عام 2030.</p>

<p>هذا يثير السؤال الأساسي: ما هو غرض حياتنا؟ ما هذا كل شيء؟ كيف نعيش حياة جيدة؟</p>

<p>الذكاء الاصطناعي يظهر مثل التقنيات الأخرى لجلب الحرية لنا. ولكن يبدو أن الجميع مشغولون مثل الآلات في هذه المجتمع الرأسمالي.</p>

<p>العودة إلى الموضوع. لذلك، بايثون يمكن أن تساعد في كتابة كود جافا أيضًا. يمكنك استخدام بايثون للحصول على السياق لكتابة الكود وترك Copilot يكتبه لك للقيام بذلك في المرة الأولى.</p>

<p>الذكاء الاصطناعي يتعلق بتحسين التوجيه وتحسين السياق. التوجيهات والسياق تساعد في استجابات روبوتات الدردشة الذكاء الاصطناعي.</p>

<p>بايثون يمكن أن تساعد في السياق؛ بايثون يمكن أن تساعد في توليد التوجيهات.</p>

<p>هذا ليس فقط عن جافا، ولكن عن كل لغة برمجة أخرى. بايثون يمكن أن تساعدهم بشكل عميق. لذلك، لماذا لا تزال لدينا حاجة إلى استخدام لغات برمجة أخرى؟</p>

<p>السبب هو التصميم الداخلي لبايثون الذي يجعل أدائها أقل من لغات البرمجة الأخرى مثل C، C++، أو Rust.</p>

<h3 id="لغات-البرمجة-في-عصر-الذكاء-الاصطناعي">لغات البرمجة في عصر الذكاء الاصطناعي</h3>

<p>الذكاء الاصطناعي قوي جدًا الآن، مما يجعلنا نعيد التفكير في كل شيء من منظور الذكاء الاصطناعي. أي لغات البرمجة ستكون شائعة في السنوات العشر القادمة؟</p>

<p>بالطبع، بايثون. العديد من روبوتات الدردشة الذكاء الاصطناعي تستخدم بايثون لتشغيل الكود في المتصفح، مثل Grok. بايثون شهيرة بسبب بساطتها وسهولة التعلم والأداء الجيد. يتم تبنيها من قبل العديد من مشاريع البرمجيات.</p>

<p>بايثون أبطأ من C++، جافا، ورست. جافا لديها مجتمع كبير. رست مبنية على C.</p>

<p>أستغرب ما إذا كان العديد من المشاريع ستتم إعادة كتابتها أو استبدالها برست. إعادة كتابتها في رست يعني الإشارة إلى مشروع قديم واستخدام رست لتنفيذ نفس الوظيفة. الاستبدال يعني أن البرمجيات المكتوبة بلغات أخرى يتم استبدالها الآن ببرمجيات مماثلة مكتوبة برست.</p>

<p>لغة رست لها Syntax معقدة نسبيًا. ولكن في عصر الذكاء الاصطناعي، هذا ليس مشكلة كبيرة، لأن الذكاء الاصطناعي سيساعد في كتابة الكود. بالنسبة للSyntax المعقدة، البشر لا يعانون من صعوبة كبيرة أيضًا.</p>

<p>أعتقد أن الهندية أو التاميلية معقدة جدًا. ولكن بالنسبة للهنديين الذين يعيشون في الشمال، الهندية ليست مشكلة، وللذين في الجنوب، التاميلية ليست مشكلة أيضًا.</p>

<p>لكن بالنسبة لمواطن صيني مثلي، أعتقد أن تعلمها مشكلة كبيرة.</p>

<p>في البداية، يبدو أن جميع الحروف في الهندية مشابهة لي. أعتقد أن الفرق بين الهندية والعربية مثل الفرق بين الصينية واليابانية، أو الإنجليزية والإسبانية.</p>

<p>الفرق بين لغات البرمجة أقل من الفرق بين اللغات الطبيعية. السبب الكبير هو أن لغات البرمجة تختلف فقط في مظهر الحروف، بينما اللغات الطبيعية تختلف أيضًا في الصوت. اللغات الطبيعية تختلف في جانبين: مجموعة الحروف والنطق.</p>

<p>لغات البرمجة لها تاريخ يبلغ حوالي قرن من الزمن، بينما اللغات الطبيعية لها أكثر من 100 قرن. كلما قضا الناس وقتًا أطول في شيء ما، كلما تطور أكثر من الاختلافات. الأشخاص الذين لديهم آراء مختلفة قليلاً سيخلقون إصداراتهم الخاصة من الأشياء.</p>

<p>هذا يشرح لهجة الإنجليزية. في بعض فيديوهات TikTok، يقول الناس أن أسوأ لهجة إنجليزية هي برمنغهام.</p>

<p>لذلك، في الواقع، رست ليس لديها مشكلة كبيرة. أداؤها جيد جدًا، حيث أنها مبنية على C/C++.</p>

<p>الأداء حاسم للعديد من التطبيقات. اليوم، يتم استخدام العديد من التطبيقات من قبل مليارات الأشخاص. للخدمات البنية التحتية لحوسبة السحابة، يتم استدعاء خدماتهم العديد من المرات. لذلك، حتى زيادة صغيرة في الأداء يمكن أن Economize الكثير من المال.</p>

<p>هل رست لديها العديد من العيوب؟ شيء واحد يشكو منه الناس هو أنه صعب التعلم. منحنى التعلم حاد. الذكاء الاصطناعي يجلب أخبارًا جيدة، حيث يساعد في التعلم بشكل كبير.</p>

<p>لا أحتاج إلى معرفة الكثير عن رست. كمهندس برمجيات مع 10 سنوات من الخبرة، يمكنني استخدام الذكاء الاصطناعي لمساعدتي في كتابة العديد من تطبيقات رست البسيطة. كل ما أحتاج إلى معرفته هو الأوامر الأساسية لتجميع رست مثل <code class="language-plaintext highlighter-rouge">cargo</code> و <code class="language-plaintext highlighter-rouge">cargo build</code>. لا أحتاج حتى إلى معرفة الكثير عن Syntax رست نفسه.</p>

<p>بالنسبة لرست، لا يسبب نموذج القابلية للتغيير أو الاستعارة لي أي مشكلة. بالنسبة للتطبيقات البسيطة التي تحتوي على أقل من 200 سطر من الكود، يمكنني طلب من الذكاء الاصطناعي إصلاح الأخطاء مباشرة عن طريق تقديم رسائل الأخطاء.</p>

<p>لكن لماذا لا يزال الناس يستخدمون بايثون كثيرًا إذا كانت رست جيدة جدًا؟ لأن بايثون جيدة في جانب آخر. إنها سهلة الاستخدام والتعلم. لديها مجتمع كبير ومكتبات عديدة.</p>

<p>بايثون ما زالت لديها أداء جيد بما يكفي ودعم المنتجات لمليارات، حتى عشرات الملايين من المستخدمين. معظم المنتجات لا تصل إلى هذا العدد من المستخدمين. إذا كنت لديك هذا العدد من المستخدمين، يمكنك توظيف مهندسي رست أو جافا لتحسين الأداء.</p>

<p>بايثون جيدة لتطوير العديد من المجالات: التعلم الآلي، تطوير الويب، الرياضيات، التدريس، والتشغيل. على الرغم من أن بايثون ليست جيدة في تطبيقات سطح المكتب، إلا أن MicroPython يتم استخدامه في Raspberry Pi.</p>

<p>ما عن جافا في عصر الذكاء الاصطناعي؟ سيكون جيدًا أيضًا، حيث لديها قاعدة مستخدمين كبيرة ومجتمع. الذكاء الاصطناعي يساعد كثيرًا في ذلك. يتم استخدامه من قبل العديد من الشركات الكبيرة. إنهم يميلون إلى عدم تغيير لغاتهم البرمجية الرئيسية. بالنسبة لمشاريعهم القديمة الكبيرة، استخدام لغة برمجة جديدة لإعادة كتابة المشروع سيستغرق عقدًا من الجهد. الذكاء الاصطناعي سيساعد في ذلك، ولكن العملية ستظل بطيئة.</p>

<p>عادةً، الأشخاص العقلانيون في الشركات الكبيرة لن يعتبروا تغيير لغة البرمجة الرئيسية لديهم. أعمالهم الرئيسية في قطاعات أخرى. لا يهتمون كثيرًا بالتكنولوجيا. إذا فعلوا ذلك، لكانوا شركات برمجيات أو إنترنت ويقودون مجتمعات المصدر المفتوح. ومع ذلك، لا تهتم العديد من شركات فورشن 500 بذلك.</p>

<p>سيكون هناك العديد من الشركات الناشئة بسبب الذكاء الاصطناعي. الشركات الناشئة تحب القيام بالأشياء الجديدة، لذلك سيجربون لغات برمجة جديدة. في عصر الذكاء الاصطناعي، ستفوز لغات البرمجة المرنة في الشركات الصغيرة والمتوسطة.</p>

<p>في مسابقات الخوارزميات، هل ستغير اللغة البرمجية المفضلة؟ سيستمر C++ في الهيمنة على هذا القطاع لسنوات. في مسابقات الخوارزميات الفعلية، لا يمكنك استخدام الذكاء الاصطناعي. ولكن أعتقد أن في عصر الذكاء الاصطناعي، سيقل عدد الأشخاص المشاركين.</p>

<p>بسبب أن هؤلاء الأشخاص جيدون جدًا في البرمجة، وهناك العديد من الفرص بسبب الذكاء الاصطناعي، فلماذا لا يبني أكثر من الناس منتجات حقيقية للمستخدمين بدلاً من ممارسة مشاكل الخوارزميات؟ حتى أفضل لاعب في مسابقات الخوارزميات، جينادي كوروتكيفيتش، اختار الانضمام إلى Devin.</p>

<p>لكن مسابقات الخوارزميات يمكن أن تكون هواية استرخاء أو تقاعد لبرمجة الذكية. إنها مثل الشطرنج أو كرة السلة. الناس يفعلون ذلك لأنهم يحبون ذلك أو يحتاجون إليه، وليس لأسباب أخرى. العديد من الأشخاص يلعبون كرة السلة في الثلاثينيات أو الأربعينيات من العمر. ربما يفعلون ذلك لأسباب صحية أو لجعل الحياة أكثر متعة.</p>

<p>بالنسبة لـ iOS وAndroid، فهي جافا، Kotlin، Swift، وObjective-C. لن يكون هناك تغييرات كبيرة بسبب الذكاء الاصطناعي، لأن هناك خيارات محدودة. من جانب المستخدم النهائي، متطلبات الأداء ليست عالية جدًا. Google وApple لديهم سيطرة عالية جدًا على منصاتهما. إذا لم تتغير Google وApple، فلن يتغير المبرمجون.</p>

<p>لكن للخوادم، هناك العديد من الخيارات. اللغات التي تكون أكثر ودية للذكاء الاصطناعي ستفوز.</p>

<p>سيفوز لغات البرمجة الإجرائية أكثر من لغات البرمجة الموجهة للكائنات. لغات البرمجة الإجرائية مباشرة وسهلة التوليد بواسطة الذكاء الاصطناعي، بينما لغات البرمجة الموجهة للكائنات لديها العديد من المستويات المتداخلة أو أنماط التصميم.</p>

<p>هل ستزداد لغات البرمجة بسبب الذكاء الاصطناعي؟ أعتقد ذلك. Zed وOCaml سيحظون بمستخدمين أكثر. LLMs/الذكاء الاصطناعي جيدون جدًا في التعلم من الأنماط، لذا من السهل إعادة كتابة المشاريع بلغات أخرى.</p>

<p>ستواجه لغات البرمجة منافسة أكبر في المستقبل. تلك التي تكون جيدة في الأداء، Syntax، وQuality المجمع ستصبح أكثر شعبية بشكل طبيعي. المنافسة مثل LLMs. تلك التي تكون جيدة بشكل طبيعي، مثل Claude وDeepSeek، تصبح شعبية.</p>

<p>ماذا لو أصبح الذكاء الاصطناعي قويًا جدًا بحيث لا نحتاج إلى تعلم البرمجة anymore؟ هذا ما زال بعيدًا. افترض أن لدينا مشروع كبير جدًا يحتوي على 1000 ملف جافا. ربما يحتاج الذكاء الاصطناعي إلى 10 سنوات للقيام بالمهام بسهولة.</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-ar" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
