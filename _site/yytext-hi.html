<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>YYText कैसे काम करता है</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>YYText कैसे काम करता है | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="YYText कैसे काम करता है" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="hi" />
<meta name="description" content="ऊपर दिखाया गया छाया प्रभाव निम्नलिखित कोड का उपयोग करके बनाया गया है:" />
<meta property="og:description" content="ऊपर दिखाया गया छाया प्रभाव निम्नलिखित कोड का उपयोग करके बनाया गया है:" />
<link rel="canonical" href="https://lzwjava.github.io/yytext-hi" />
<meta property="og:url" content="https://lzwjava.github.io/yytext-hi" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-24T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="YYText कैसे काम करता है" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-24T00:00:00+08:00","datePublished":"2016-05-24T00:00:00+08:00","description":"ऊपर दिखाया गया छाया प्रभाव निम्नलिखित कोड का उपयोग करके बनाया गया है:","headline":"YYText कैसे काम करता है","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/yytext-hi"},"url":"https://lzwjava.github.io/yytext-hi"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=fce7f10c9c134f320e4f9066068094ca64a2e666">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=fce7f10c9c134f320e4f9066068094ca64a2e666" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       YYText कैसे काम करता है | मूल, AI द्वारा अनुवादित
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/hi/2016-05-24-yytext-hi.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postshi2016-05-24-yytext-hi.md</span> -->
      

      <!-- <span>2016-05-24-yytext-hi.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/yytext-en" >English</option>
        <option value="/yytext-zh" >中文</option>
        <option value="/yytext-ja" >日本語</option>
        <option value="/yytext-es" >Español</option>
        <option value="/yytext-hi" selected>हिंदी</option>
        <option value="/yytext-fr" >Français</option>
        <option value="/yytext-de" >Deutsch</option>
        <option value="/yytext-ar" >العربية</option>
        <option value="/yytext-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>ऊपर दिखाया गया छाया प्रभाव निम्नलिखित कोड का उपयोग करके बनाया गया है:</p>

<p>आप देख सकते हैं कि <code class="language-plaintext highlighter-rouge">YYTextShadow</code> बनाया गया है, फिर इसे <code class="language-plaintext highlighter-rouge">attributedString</code> के <code class="language-plaintext highlighter-rouge">yy_textShadow</code> को सौंपा गया है, और फिर <code class="language-plaintext highlighter-rouge">attributedString</code> को <code class="language-plaintext highlighter-rouge">YYLabel</code> में सौंपा गया है, और अंत में <code class="language-plaintext highlighter-rouge">YYLabel</code> को <code class="language-plaintext highlighter-rouge">UIView</code> में जोड़कर प्रदर्शित किया गया है। <code class="language-plaintext highlighter-rouge">yy_textShadow</code> को ट्रैक करने पर पता चलता है कि मुख्य रूप से <code class="language-plaintext highlighter-rouge">textShadow</code> को <code class="language-plaintext highlighter-rouge">NSAttributedString</code> के attribute से बांधा गया है, जहां key <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> है और value <code class="language-plaintext highlighter-rouge">textShadow</code> है, यानी पहले shadow को स्टोर किया जाता है और बाद में उपयोग किया जाता है। Shift + Command + J का उपयोग करके परिभाषा पर तेजी से जाएं:</p>

<p>यहाँ एक <code class="language-plaintext highlighter-rouge">addAttribute</code> है, जो <code class="language-plaintext highlighter-rouge">NSAttributedString.h</code> में परिभाषित है:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAttribute</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">value</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">range</span><span class="p">:(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</code></pre></div></div>

<p>यह कोड Objective-C में एक मेथड को दर्शाता है जो किसी विशेष गुण (attribute) को एक निश्चित रेंज (range) में जोड़ने के लिए उपयोग किया जाता है। इसमें <code class="language-plaintext highlighter-rouge">name</code> पैरामीटर गुण का नाम, <code class="language-plaintext highlighter-rouge">value</code> पैरामीटर गुण का मान, और <code class="language-plaintext highlighter-rouge">range</code> पैरामीटर उस रेंज को दर्शाता है जहाँ यह गुण जोड़ा जाएगा।</p>

<p>यह बताता है कि इसमें किसी भी की-वैल्यू जोड़ी को असाइन किया जा सकता है। और <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> की परिभाषा एक सामान्य स्ट्रिंग है, जिसका मतलब है कि पहले shadow की जानकारी को स्टोर किया जाता है, और फिर बाद में उपयोग किया जाता है। हम <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> को ग्लोबली सर्च करते हैं।</p>

<p>फिर हम <code class="language-plaintext highlighter-rouge">YYTextLayout</code> में <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> फ़ंक्शन पर आते हैं:</p>

<p><code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> का मतलब है कि यह एक Context के अंदर मूल बिंदु (origin) के निर्देशांक को बदलता है, इसलिए</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</code></pre></div></div>

<p>(यह कोड Objective-C में है और इसे अनुवादित नहीं किया जाता है। यह कोड <code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> फ़ंक्शन का उपयोग करके ग्राफ़िक्स कॉन्टेक्स्ट को ट्रांसलेट करता है।)</p>

<p>यह कहा जा रहा है कि ड्रॉ किए गए कॉन्टेक्स्ट को <code class="language-plaintext highlighter-rouge">point</code> बिंदु पर ले जाना है। हम पहले यह समझ लेते हैं कि <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> कहाँ कॉल किया गया है, और हमने पाया कि यह <code class="language-plaintext highlighter-rouge">drawInContext</code> में कॉल किया गया है।</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext</code> में, निम्नलिखित क्रम में ब्लॉक की सीमा रेखा खींची जाती है: पहले बॉर्डर, फिर पृष्ठभूमि बॉर्डर, छाया, अंडरलाइन, टेक्स्ट, एक्सेसरीज़, इनर शैडो, स्ट्राइकथ्रू, टेक्स्ट बॉर्डर, और अंत में डिबग लाइन।</p>

<p>तो आखिर <code class="language-plaintext highlighter-rouge">drawInContext</code> का उपयोग कहाँ किया गया है? आप देख सकते हैं कि इसमें एक पैरामीटर <code class="language-plaintext highlighter-rouge">YYTextDebugOption</code> है, इसलिए यह फ़ंक्शन निश्चित रूप से सिस्टम का कॉलबैक नहीं है, बल्कि YYText के अंदर से ही कॉल किया गया है।</p>

<p>Ctrl + 1 दबाने पर शॉर्टकट पॉप अप होता है, और यह देखा जाता है कि इसे चार स्थानों पर कॉल किया गया है।</p>

<p><code class="language-plaintext highlighter-rouge">drawInContext:size:debug</code> अभी भी YYText का अपना कॉल है, क्योंकि <code class="language-plaintext highlighter-rouge">debug</code> का प्रकार <code class="language-plaintext highlighter-rouge">YYTextDebugOption *</code> है, जो YY का अपना है। <code class="language-plaintext highlighter-rouge">newAsyncTask</code> सिस्टम कॉल की तरह नहीं लगता, <code class="language-plaintext highlighter-rouge">addAttachmentToView:layer:</code> भी ऐसा ही है, इसलिए संभावना है कि यह <code class="language-plaintext highlighter-rouge">drawRect:</code> हो सकता है।</p>

<p>देखिए, दाईं ओर के त्वरित सहायता अनुभाग में विस्तृत व्याख्या है, और सहायता के नीचे यह भी बताया गया है कि यह <code class="language-plaintext highlighter-rouge">UIView</code> में परिभाषित है। अब <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> को देखें, यह <code class="language-plaintext highlighter-rouge">UIView</code> को इनहेरिट करता है।</p>

<p>तो क्या <code class="language-plaintext highlighter-rouge">YYLabel</code> ने <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> का उपयोग किया है? और फिर सिस्टम को <code class="language-plaintext highlighter-rouge">YYTextContainerView</code> में <code class="language-plaintext highlighter-rouge">drawRect:</code> को कॉल करके ड्रा करने दिया है?</p>

<p>अजीब बात है, <code class="language-plaintext highlighter-rouge">YYLabel</code> <code class="language-plaintext highlighter-rouge">UIView</code> को इनहेरिट करता है। इसलिए, YYText में दो चीज़ें होनी चाहिए! एक <code class="language-plaintext highlighter-rouge">YYLabel</code> और एक <code class="language-plaintext highlighter-rouge">YYTextView</code>, जैसे <code class="language-plaintext highlighter-rouge">UILabel</code> और <code class="language-plaintext highlighter-rouge">UITextView</code>। फिर हम पहले वाले <code class="language-plaintext highlighter-rouge">YYLabel</code> के <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code> को फिर से देखेंगे।</p>

<p>बहुत लंबा है, बीच में <code class="language-plaintext highlighter-rouge">YYTextLayout</code> के <code class="language-plaintext highlighter-rouge">drawInContext</code> को कॉल किया गया है। <code class="language-plaintext highlighter-rouge">newAsyncDisplayTask</code>, यह कहाँ कॉल किया गया है?</p>

<p>दूसरी पंक्ति में कॉल किया गया है। इसलिए इसे सरलता से समझा जा सकता है कि <code class="language-plaintext highlighter-rouge">YYLabel</code> ने टेक्स्ट को ड्रॉ करने के लिए एसिंक्रोनस तरीके का उपयोग किया है। और <code class="language-plaintext highlighter-rouge">_displayAsync</code> को ऊपर के <code class="language-plaintext highlighter-rouge">display</code> द्वारा कॉल किया गया है। <code class="language-plaintext highlighter-rouge">display</code> के डॉक्यूमेंटेशन को देखने पर, यह कहा गया है कि सिस्टम उचित समय पर लेयर की सामग्री को अपडेट करने के लिए इसे कॉल करेगा, आपको इसे सीधे कॉल नहीं करना चाहिए। हम इसमें एक ब्रेकपॉइंट भी सेट कर सकते हैं।</p>

<p><code class="language-plaintext highlighter-rouge">display</code> को <code class="language-plaintext highlighter-rouge">CALayer</code> के एक transaction में कॉल किया जाता है। Transaction का उपयोग शायद इसलिए किया जाता है ताकि बड़े पैमाने पर अपडेट को एक साथ किया जा सके, जिससे efficiency बढ़ सके। यह database में rollback की आवश्यकता की तरह नहीं लगता।</p>

<p><code class="language-plaintext highlighter-rouge">display</code> 的系统文档中还提到，如果你想让你自己的 layer 以不同的方式绘制，你可以通过重写这个方法来实现自定义的绘制。</p>

<p>तो, हमारे पास थोड़ा सा विचार है। <code class="language-plaintext highlighter-rouge">YYLabel</code> ने <code class="language-plaintext highlighter-rouge">UIView</code> के <code class="language-plaintext highlighter-rouge">display</code> मेथड को ओवरराइड करके अपनी छाया और अन्य प्रभावों को एसिंक्रोनस तरीके से ड्रॉ करने का तरीका अपनाया है। छाया प्रभाव पहले <code class="language-plaintext highlighter-rouge">YYLabel</code> के <code class="language-plaintext highlighter-rouge">attributedText</code> में एट्रिब्यूट के रूप में सहेजे जाते हैं, और फिर <code class="language-plaintext highlighter-rouge">display</code> में ड्रॉ करते समय इन्हें निकाला जाता है। ड्रॉ करते समय सिस्टम के CoreGraphics फ्रेमवर्क का उपयोग किया जाता है।</p>

<p>कुछ विचारों को स्पष्ट करने के बाद, आपको पता चलेगा कि वास्तव में शक्तिशाली क्या है? एक तरफ इतने सारे प्रभावों और एसिंक्रोनस कॉल्स को व्यवस्थित करना है, और दूसरी तरफ CoreGraphics फ्रेमवर्क का गहराई से उपयोग करना है। इसलिए, पिछले कोड संगठन को समझने के बाद, हम CoreGraphics फ्रेमवर्क में गहराई से जाएंगे। देखें कि यह कैसे ड्रॉ किया जाता है।</p>

<p>चलिए फिर से <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> पर वापस आते हैं।</p>

<p>यहां, <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> और <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> ने ड्राइंग कोड के एक ब्लॉक को घेरा हुआ है। <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> का मतलब है कि वर्तमान ड्राइंग स्टेट की एक कॉपी बनाकर उसे ड्राइंग स्टैक में डाल दिया जाए। हर ड्राइंग Context एक ड्राइंग स्टैक को मेन्टेन करता है। मुझे यह स्पष्ट नहीं है कि स्टैक के अंदर वास्तव में क्या होता है। फिलहाल इसे इस तरह समझें कि ड्राइंग Context से पहले <code class="language-plaintext highlighter-rouge">CGContextSaveGState</code> को कॉल करना है और ड्राइंग Context के बाद <code class="language-plaintext highlighter-rouge">CGContextRestoreGState</code> को कॉल करना है, ताकि बीच का ड्राइंग Context में प्रभावी ढंग से दिखाई दे। <code class="language-plaintext highlighter-rouge">CGContextTranslateCTM</code> Context को संबंधित स्थान पर ले जाता है। पहले <code class="language-plaintext highlighter-rouge">point.x</code> और <code class="language-plaintext highlighter-rouge">point.y</code> पर ले जाया जाता है, जो ड्राइंग का संबंधित स्थान है, लेकिन बाद में 0 और <code class="language-plaintext highlighter-rouge">size.height</code> पर ले जाने का कारण स्पष्ट नहीं है, इसे बाद में देखा जाएगा। फिर <code class="language-plaintext highlighter-rouge">lines</code> को निकाला जाता है और <code class="language-plaintext highlighter-rouge">for</code> लूप को एक्ज़ीक्यूट किया जाता है।</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> क्या है? यह <code class="language-plaintext highlighter-rouge">YYTextLayout</code> में <code class="language-plaintext highlighter-rouge">(YYTextLayout *)layoutWithContainer:(YYTextContainer *)container text:(NSAttributedString *)text range:(NSRange)range</code> के दौरान असाइन किया जाता है।</p>

<p>फिर इस फ़ंक्शन की परिभाषा पर जाएं:</p>

<p>यह फ़ंक्शन बहुत लंबा है, 367 से 861 लाइन तक, 500 लाइन का कोड! इसके शुरुआत और अंत को देखकर, यह स्पष्ट है कि इसका उद्देश्य इन चरों को प्राप्त करना है। <code class="language-plaintext highlighter-rouge">lines</code> कैसे प्राप्त किया जाता है?</p>

<p>एक बड़े <code class="language-plaintext highlighter-rouge">for</code> लूप में, एक-एक करके <code class="language-plaintext highlighter-rouge">line</code> को <code class="language-plaintext highlighter-rouge">lines</code> में जोड़ा जा सकता है। तो <code class="language-plaintext highlighter-rouge">lineCount</code> कैसे प्राप्त होता है?</p>

<p>472वीं पंक्ति में एक <code class="language-plaintext highlighter-rouge">framesetter</code> ऑब्जेक्ट बनाया गया है, <code class="language-plaintext highlighter-rouge">text</code> पैरामीटर <code class="language-plaintext highlighter-rouge">NSAttributedString</code> है, फिर <code class="language-plaintext highlighter-rouge">frameSetter</code> ऑब्जेक्ट में एक <code class="language-plaintext highlighter-rouge">CTFrameRef</code> बनाया गया है, और फिर <code class="language-plaintext highlighter-rouge">CTFrameRef</code> से <code class="language-plaintext highlighter-rouge">lines</code> प्राप्त किया गया है। <code class="language-plaintext highlighter-rouge">line</code> वास्तव में क्या है? हम इस पर एक ब्रेकपॉइंट लगाएंगे।</p>

<p>पाया गया कि <code class="language-plaintext highlighter-rouge">shadow</code> शब्द का <code class="language-plaintext highlighter-rouge">lineCount = 2</code> है, जो हमारी कल्पना के अक्षरों की संख्या नहीं है।</p>

<p>तो क्या अनुमान लगाया जा सकता है कि सफेद <code class="language-plaintext highlighter-rouge">Shadow</code> पूरी तरह से एक <code class="language-plaintext highlighter-rouge">line</code> है, और छाया भी एक <code class="language-plaintext highlighter-rouge">line</code> है?</p>

<p>YYText में कई उदाहरण हैं, जिनमें से केवल एक प्रभाव दिखाया गया है, और अन्य कोड को टिप्पणी में डाल दिया गया है। यह देखकर अजीब लगता है कि Shadow का <code class="language-plaintext highlighter-rouge">lineCount = 2</code> है, और Multiple Shadows का <code class="language-plaintext highlighter-rouge">lineCount</code> भी 2 है, लेकिन Multiple Shadows में आंतरिक छाया (inner shadow) भी है, इसलिए यह 3 होना चाहिए?</p>

<p>CTLine के Apple डॉक्यूमेंटेशन को देखें, यह कहता है कि CTLine एक पंक्ति के टेक्स्ट को प्रतिनिधित्व करता है, और एक CTLine ऑब्जेक्ट में <code class="language-plaintext highlighter-rouge">glyph runs</code> का एक समूह होता है। तो यह सिर्फ साधारण पंक्तियों की संख्या है! ऊपर दिए गए ब्रेकपॉइंट स्क्रीनशॉट को देखें, जहां <code class="language-plaintext highlighter-rouge">shadow</code> का मान 2 था, क्योंकि इसका टेक्स्ट <code class="language-plaintext highlighter-rouge">shadow\n\n</code> था। ध्यान दें कि <code class="language-plaintext highlighter-rouge">\n\n</code> को जानबूझकर जोड़ा गया था, ताकि यह सुंदर दिखे।</p>

<p>इसलिए <code class="language-plaintext highlighter-rouge">shadow\n\n</code> दो पंक्तियों का टेक्स्ट है। CTLine वही है जिसे हम आमतौर पर एक पंक्ति कहते हैं। फिर हमारे <code class="language-plaintext highlighter-rouge">lineCount</code> पर वापस जाते हैं:</p>

<p>यहां हमें <code class="language-plaintext highlighter-rouge">CTLines</code> सरणी मिलती है, उसमें से तत्वों की संख्या प्राप्त करते हैं, और यदि <code class="language-plaintext highlighter-rouge">lineCount</code> 0 से अधिक है तो प्रत्येक पंक्ति के निर्देशांक मूल बिंदु प्राप्त करते हैं। ठीक है, अब हमारे पास <code class="language-plaintext highlighter-rouge">lineCount</code> है, आइए अब <code class="language-plaintext highlighter-rouge">for</code> लूप पर नजर डालते हैं।</p>

<p><code class="language-plaintext highlighter-rouge">ctLines</code> सरणी से <code class="language-plaintext highlighter-rouge">CTLine</code> प्राप्त करें, फिर <code class="language-plaintext highlighter-rouge">YYTextLine</code> ऑब्जेक्ट प्राप्त करें, और उसे <code class="language-plaintext highlighter-rouge">lines</code> सरणी में जोड़ें। फिर <code class="language-plaintext highlighter-rouge">line</code> के फ्रेम की गणना करें। <code class="language-plaintext highlighter-rouge">YYTextLine</code> का कंस्ट्रक्टर बहुत सरल है, पहले स्थिति, लंबवत टाइपसेटिंग, और <code class="language-plaintext highlighter-rouge">CTLine</code> ऑब्जेक्ट को सहेजता है:</p>

<p><code class="language-plaintext highlighter-rouge">lines</code> को समझने के बाद, हम पहले वाले <code class="language-plaintext highlighter-rouge">YYTextDrawShadow</code> पर वापस जाते हैं:</p>

<p>यह कोड अब सरल हो गया है। पहले पंक्तियों की संख्या प्राप्त करें, उन्हें ट्रैवर्स करें, फिर <code class="language-plaintext highlighter-rouge">GlyphRuns</code> सरणी प्राप्त करें, और उसे ट्रैवर्स करें। <code class="language-plaintext highlighter-rouge">GlyphRun</code> को एक प्राइमिटिव या ड्रॉइंग यूनिट के रूप में समझा जा सकता है। फिर उससे <code class="language-plaintext highlighter-rouge">attributes</code> सरणी प्राप्त करें, हमारे पहले <code class="language-plaintext highlighter-rouge">YYTextShadowAttributeName</code> का उपयोग करके, हम शुरू में असाइन किए गए <code class="language-plaintext highlighter-rouge">shadow</code> को प्राप्त करें, और फिर छाया बनाना शुरू करें:</p>

<p>एक <code class="language-plaintext highlighter-rouge">while</code> लूप, जो लगातार उप-छाया बनाता है। <code class="language-plaintext highlighter-rouge">CGContextSetShadowWithColor</code> को कॉल करके छाया का विस्थापन, त्रिज्या और रंग सेट किया जाता है। फिर <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> को कॉल करके वास्तविक रूप से ड्रॉ किया जाता है। <code class="language-plaintext highlighter-rouge">YYTextDrawRun</code> को तीन स्थानों पर कॉल किया जाता है:</p>

<p>यह आंतरिक छाया, टेक्स्ट छाया और टेक्स्ट को ड्रॉ करने के लिए उपयोग किया जाता है। यह दर्शाता है कि यह एक सामान्य विधि है, जिसका उपयोग <code class="language-plaintext highlighter-rouge">Run</code> ऑब्जेक्ट को ड्रॉ करने के लिए किया जाता है।</p>

<p>शुरुआत में टेक्स्ट का ट्रां्सफॉर्म मैट्रिक्स प्राप्त करें, और <code class="language-plaintext highlighter-rouge">runTextMatrixIsID</code> का उपयोग करके जांचें कि क्या यह अपरिवर्तित है। यदि यह वर्टिकल टाइपसेटिंग नहीं है या ग्राफिक्स ट्रां्सफॉर्मेशन सेट नहीं है, तो सीधे ड्रॉ करें। <code class="language-plaintext highlighter-rouge">CTRunDraw</code> को कॉल करके <code class="language-plaintext highlighter-rouge">run</code> ऑब्जेक्ट को ड्रॉ करें। फिर ब्रेकपॉइंट पर ध्यान दें, और पाएं कि शुरुआती शैडो को ड्रॉ करते समय केवल <code class="language-plaintext highlighter-rouge">if</code> ब्लॉक में प्रवेश किया गया था, <code class="language-plaintext highlighter-rouge">else</code> ब्लॉक में नहीं।</p>

<p>तो हमारी छाया ड्राइंग यहीं समाप्त होती है!</p>

<p>संक्षेप में, <code class="language-plaintext highlighter-rouge">YYLabel</code> पहले छाया जैसे प्रभावों को <code class="language-plaintext highlighter-rouge">attributedText</code> के attributes में सहेजता है, <code class="language-plaintext highlighter-rouge">UIView</code> की <code class="language-plaintext highlighter-rouge">display</code> विधि को ओवरराइड करता है, और <code class="language-plaintext highlighter-rouge">display</code> में एसिंक्रोनस ड्राइंग करता है। <code class="language-plaintext highlighter-rouge">CoreText</code> फ्रेमवर्क का उपयोग करके <code class="language-plaintext highlighter-rouge">CTLine</code> और <code class="language-plaintext highlighter-rouge">CTRun</code> ऑब्जेक्ट प्राप्त करता है, <code class="language-plaintext highlighter-rouge">CTRun</code> से attributes प्राप्त करता है, और फिर attributes में मौजूद विभिन्न गुणों के आधार पर <code class="language-plaintext highlighter-rouge">CoreGraphics</code> फ्रेमवर्क का उपयोग करके <code class="language-plaintext highlighter-rouge">CTRun</code> ऑब्जेक्ट को Context में ड्रा करता है।</p>

<p>समझ अभी भी पर्याप्त नहीं है, बाद में फिर से पढ़ने के लिए आऊंगा। अनजाने में यह सोचकर आश्चर्य होता है कि YY वास्तव में बहुत शक्तिशाली है! आज मैंने अपने विचारों को व्यवस्थित किया, और खुद को कोड लिखते और पढ़ते हुए रखा, ताकि यह उबाऊ न हो, और साथ ही दूसरों के लिए संदर्भ के रूप में काम कर सके। अब सोने जाना होगा।</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-hi" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
