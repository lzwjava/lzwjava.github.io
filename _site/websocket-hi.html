<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>WebSocket की खोज</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>WebSocket की खोज | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="WebSocket की खोज" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="hi" />
<meta name="description" content="यह ब्लॉग पोस्ट ChatGPT-4o की सहायता से तैयार किया गया है।" />
<meta property="og:description" content="यह ब्लॉग पोस्ट ChatGPT-4o की सहायता से तैयार किया गया है।" />
<link rel="canonical" href="https://lzwjava.github.io/websocket-hi" />
<meta property="og:url" content="https://lzwjava.github.io/websocket-hi" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-05-29T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="WebSocket की खोज" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2016-05-29T00:00:00+08:00","datePublished":"2016-05-29T00:00:00+08:00","description":"यह ब्लॉग पोस्ट ChatGPT-4o की सहायता से तैयार किया गया है।","headline":"WebSocket की खोज","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/websocket-hi"},"url":"https://lzwjava.github.io/websocket-hi"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=f3748e7a1c742a012267333dcf0859d9f354711d">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=f3748e7a1c742a012267333dcf0859d9f354711d" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       WebSocket की खोज | मूल, AI द्वारा अनुवादित
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/hi/2016-05-29-websocket-hi.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postshi2016-05-29-websocket-hi.md</span> -->
      

      <!-- <span>2016-05-29-websocket-hi.md</span> -->

      
        

        
          
          <a href="#" class="button">2016.05</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/websocket-en" >English</option>
        <option value="/websocket-zh" >中文</option>
        <option value="/websocket-ja" >日本語</option>
        <option value="/websocket-es" >Español</option>
        <option value="/websocket-hi" selected>हिंदी</option>
        <option value="/websocket-fr" >Français</option>
        <option value="/websocket-de" >Deutsch</option>
        <option value="/websocket-ar" >العربية</option>
        <option value="/websocket-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p><em>यह ब्लॉग पोस्ट ChatGPT-4o की सहायता से तैयार किया गया है।</em></p>

<hr />

<h3 id="परिचय">परिचय</h3>
<p>नमस्ते, मैं ली झीवेई हूँ। CodeReview प्लेटफॉर्म के संस्थापक और CTO के रूप में, और पूर्व LeanCloud इंजीनियर के रूप में, मेरे पास WebSocket पर व्यापक अनुभव है, खासकर IM SDK के विकास प्रक्रिया में।</p>

<h3 id="websocket-का-महत्व">WebSocket का महत्व</h3>
<p>WebSocket एक प्रोटोकॉल है जो एकल TCP कनेक्शन पर पूर्ण डुप्लेक्स संचार चैनल प्रदान करता है। यह आधुनिक एप्लिकेशन में व्यापक रूप से उपयोग किया जाता है जहां वास्तविक समय में इंटरैक्शन की आवश्यकता होती है, जैसे कि तात्कालिक संदेश, वास्तविक समय टिप्पणियाँ, मल्टीप्लेयर गेम्स, सहयोगी संपादन और वास्तविक समय स्टॉक मूल्य।</p>

<h3 id="websocket-का-आधुनिक-उपयोग">WebSocket का आधुनिक उपयोग</h3>
<p>WebSocket का उपयोग निम्नलिखित क्षेत्रों में व्यापक रूप से किया जाता है:</p>
<ul>
  <li><strong>तत्काल संदेश (IM)</strong></li>
  <li><strong>रियल-टाइम टिप्पणियाँ</strong></li>
  <li><strong>मल्टीप्लेयर गेम्स</strong></li>
  <li><strong>सहयोगी संपादन</strong></li>
  <li><strong>रियल-टाइम स्टॉक कीमतें</strong></li>
</ul>

<h3 id="websocket-का-विकास">WebSocket का विकास</h3>
<p><strong>पोलिंग (Polling):</strong> क्लाइंट सर्वर से अपडेट प्राप्त करने के लिए बार-बार अनुरोध करता है।
<strong>लॉन्ग पोलिंग (Long Polling):</strong> सर्वर अनुरोध को तब तक खुला रखता है जब तक नई जानकारी उपलब्ध न हो।
<strong>HTTP द्विदिश कनेक्शन (HTTP Bidirectional Connection):</strong> भेजने और प्राप्त करने के लिए कई कनेक्शन की आवश्यकता होती है, और प्रत्येक अनुरोध में HTTP हेडर शामिल होता है।
<strong>एकल TCP कनेक्शन (WebSocket):</strong> HTTP द्विदिश कनेक्शन की सीमाओं को दूर करता है, जिससे उच्च वास्तविक समय क्षमता और कम विलंबता प्रदान की जाती है।</p>

<h3 id="ios-पर-websocket-को-लागू-करना">iOS पर WebSocket को लागू करना</h3>

<p>WebSocket एक प्रोटोकॉल है जो क्लाइंट और सर्वर के बीच द्वि-दिशात्मक संचार को सक्षम बनाता है। iOS ऐप्स में WebSocket का उपयोग करने के लिए, आप <code class="language-plaintext highlighter-rouge">URLSessionWebSocketTask</code> का उपयोग कर सकते हैं, जो iOS 13 और बाद के संस्करणों में उपलब्ध है।</p>

<h4 id="1-websocket-कनेक्शन-स्थापित-करना">1. WebSocket कनेक्शन स्थापित करना</h4>

<p>सबसे पहले, आपको WebSocket कनेक्शन स्थापित करने की आवश्यकता है। यहां एक उदाहरण दिया गया है:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"wss://your.websocket.server"</span><span class="p">)</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">webSocketTask</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">webSocketTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="n">webSocketTask</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="2-संदेश-भेजना-और-प्राप्त-करना">2. संदेश भेजना और प्राप्त करना</h4>

<p>WebSocket कनेक्शन स्थापित होने के बाद, आप संदेश भेज और प्राप्त कर सकते हैं।</p>

<p><strong>संदेश भेजना:</strong></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">message</span> <span class="o">=</span> <span class="kt">URLSessionWebSocketTask</span><span class="o">.</span><span class="kt">Message</span><span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="s">"Hello, WebSocket!"</span><span class="p">)</span>
<span class="n">webSocketTask</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"WebSocket couldn't send message because: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>संदेश प्राप्त करना:</strong></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">webSocketTask</span><span class="o">.</span><span class="n">receive</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">result</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="k">let</span> <span class="nv">error</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"WebSocket couldn't receive message because: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="k">let</span> <span class="nv">message</span><span class="p">):</span>
        <span class="k">switch</span> <span class="n">message</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="k">let</span> <span class="nv">text</span><span class="p">):</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Received text: </span><span class="se">\(</span><span class="n">text</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="k">let</span> <span class="nv">data</span><span class="p">):</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Received data: </span><span class="se">\(</span><span class="n">data</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="kd">@unknown</span> <span class="k">default</span><span class="p">:</span>
            <span class="nf">fatalError</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="3-कनेक्शन-बंद-करना">3. कनेक्शन बंद करना</h4>

<p>जब आप WebSocket कनेक्शन का उपयोग करना समाप्त कर लें, तो इसे बंद करना महत्वपूर्ण है।</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">webSocketTask</span><span class="o">.</span><span class="nf">cancel</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="o">.</span><span class="n">goingAway</span><span class="p">,</span> <span class="nv">reason</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="4-पिंग-और-पोंग">4. पिंग और पोंग</h4>

<p>WebSocket कनेक्शन को सक्रिय रखने के लिए, आप पिंग और पोंग संदेश भेज सकते हैं।</p>

<p><strong>पिंग भेजना:</strong></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">webSocketTask</span><span class="o">.</span><span class="n">sendPing</span> <span class="p">{</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Ping failed: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>पोंग प्राप्त करना:</strong></p>

<p>पोंग संदेश स्वचालित रूप से प्राप्त होते हैं जब सर्वर पिंग का जवाब देता है।</p>

<h4 id="5-त्रुटि-प्रबंधन">5. त्रुटि प्रबंधन</h4>

<p>WebSocket कनेक्शन के दौरान होने वाली त्रुटियों को संभालना महत्वपूर्ण है। आप <code class="language-plaintext highlighter-rouge">URLSessionWebSocketTask</code> के <code class="language-plaintext highlighter-rouge">receive</code> और <code class="language-plaintext highlighter-rouge">send</code> मेथड्स में त्रुटि हैंडलिंग को शामिल कर सकते हैं।</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">webSocketTask</span><span class="o">.</span><span class="n">receive</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">result</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="k">let</span> <span class="nv">error</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"WebSocket error: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="k">let</span> <span class="nv">message</span><span class="p">):</span>
        <span class="c1">// Handle message</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="6-पूर्ण-उदाहरण">6. पूर्ण उदाहरण</h4>

<p>यहां एक पूर्ण उदाहरण दिया गया है जो WebSocket कनेक्शन स्थापित करता है, संदेश भेजता और प्राप्त करता है, और कनेक्शन को बंद करता है:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"wss://your.websocket.server"</span><span class="p">)</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">webSocketTask</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">webSocketTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="n">webSocketTask</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>

<span class="c1">// Send a message</span>
<span class="k">let</span> <span class="nv">message</span> <span class="o">=</span> <span class="kt">URLSessionWebSocketTask</span><span class="o">.</span><span class="kt">Message</span><span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="s">"Hello, WebSocket!"</span><span class="p">)</span>
<span class="n">webSocketTask</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"WebSocket couldn't send message because: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Receive a message</span>
<span class="n">webSocketTask</span><span class="o">.</span><span class="n">receive</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">result</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="k">let</span> <span class="nv">error</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"WebSocket couldn't receive message because: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="k">let</span> <span class="nv">message</span><span class="p">):</span>
        <span class="k">switch</span> <span class="n">message</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="k">let</span> <span class="nv">text</span><span class="p">):</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Received text: </span><span class="se">\(</span><span class="n">text</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="k">let</span> <span class="nv">data</span><span class="p">):</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Received data: </span><span class="se">\(</span><span class="n">data</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="kd">@unknown</span> <span class="k">default</span><span class="p">:</span>
            <span class="nf">fatalError</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Close the connection</span>
<span class="n">webSocketTask</span><span class="o">.</span><span class="nf">cancel</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="o">.</span><span class="n">goingAway</span><span class="p">,</span> <span class="nv">reason</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
</code></pre></div></div>

<p>यह उदाहरण iOS ऐप में WebSocket का उपयोग करने के लिए एक बुनियादी संरचना प्रदान करता है। आप अपनी आवश्यकताओं के अनुसार इसे और विकसित कर सकते हैं।</p>

<p><strong>लोकप्रिय iOS WebSocket लाइब्रेरीज़:</strong></p>
<ul>
  <li><strong>SocketRocket (Objective-C, 4910 स्टार्स)</strong></li>
  <li><strong>Starscream (Swift, 1714 स्टार्स)</strong></li>
  <li><strong>SwiftWebSocket (Swift, 435 स्टार्स)</strong></li>
</ul>

<h3 id="srwebsocket-का-उपयोग">SRWebSocket का उपयोग</h3>

<ol>
  <li><strong>आरंभीकरण और कनेक्शन:</strong>
    <pre><code class="language-objective-c">SRWebSocket *webSocket = [[SRWebSocket alloc] initWithURLRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"ws://echo.websocket.org"]]];
webSocket.delegate = self;
[webSocket open];
</code></pre>
  </li>
  <li><strong>संदेश भेजें:</strong>
    <pre><code class="language-objective-c">[webSocket send:@"Hello, World!"];
</code></pre>
  </li>
  <li>
    <p><strong>संदेश प्राप्त करें:</strong>
आने वाले संदेशों और घटनाओं को संभालने के लिए <code class="language-plaintext highlighter-rouge">SRWebSocketDelegate</code> विधियों को लागू करें।</p>
  </li>
  <li><strong>त्रुटि प्रबंधन और घटना सूचना:</strong>
त्रुटियों को उचित तरीके से संभालें और उपयोगकर्ताओं को कनेक्शन समस्याओं के बारे में सूचित करें।</li>
</ol>

<h3 id="websocket-प्रोटोकॉल-का-विस्तृत-विवरण">WebSocket प्रोटोकॉल का विस्तृत विवरण</h3>

<p>WebSocket एक कंप्यूटर संचार प्रोटोकॉल है जो एक ही TCP कनेक्शन पर पूर्ण-डुप्लेक्स संचार प्रदान करता है। यह HTTP प्रोटोकॉल के ऊपर बनाया गया है और इसे मुख्य रूप से वेब ब्राउज़र और सर्वर के बीच रीयल-टाइम संचार के लिए डिज़ाइन किया गया है। WebSocket प्रोटोकॉल को RFC 6455 द्वारा परिभाषित किया गया है।</p>

<h4 id="websocket-प्रोटोकॉल-के-मुख्य-विशेषताएं">WebSocket प्रोटोकॉल के मुख्य विशेषताएं:</h4>

<ol>
  <li><strong>पूर्ण-डुप्लेक्स संचार</strong>: WebSocket क्लाइंट और सर्वर दोनों एक ही समय पर डेटा भेज और प्राप्त कर सकते हैं।</li>
  <li><strong>कम ओवरहेड</strong>: HTTP की तुलना में WebSocket में डेटा ट्रांसमिशन का ओवरहेड कम होता है।</li>
  <li><strong>रीयल-टाइम संचार</strong>: WebSocket रीयल-टाइम एप्लिकेशन जैसे चैट, गेमिंग, और लाइव डेटा स्ट्रीमिंग के लिए आदर्श है।</li>
</ol>

<h4 id="websocket-हैंडशेक">WebSocket हैंडशेक:</h4>

<p>WebSocket कनेक्शन स्थापित करने के लिए, क्लाइंट और सर्वर के बीच एक हैंडशेक प्रक्रिया होती है। यह प्रक्रिया HTTP प्रोटोकॉल का उपयोग करती है।</p>

<ol>
  <li><strong>क्लाइंट अनुरोध</strong>: क्लाइंट एक HTTP अनुरोध भेजता है जिसमें <code class="language-plaintext highlighter-rouge">Upgrade: websocket</code> और <code class="language-plaintext highlighter-rouge">Connection: Upgrade</code> हेडर शामिल होते हैं।</li>
  <li><strong>सर्वर प्रतिक्रिया</strong>: सर्वर अनुरोध को स्वीकार करता है और एक HTTP प्रतिक्रिया भेजता है जिसमें <code class="language-plaintext highlighter-rouge">101 Switching Protocols</code> स्टेटस कोड होता है।</li>
  <li><strong>कनेक्शन स्थापित</strong>: एक बार हैंडशेक पूरा हो जाने के बाद, क्लाइंट और सर्वर के बीच WebSocket कनेक्शन स्थापित हो जाता है।</li>
</ol>

<h4 id="websocket-फ्रेम">WebSocket फ्रेम:</h4>

<p>WebSocket डेटा को फ्रेम के रूप में ट्रांसमिट करता है। प्रत्येक फ्रेम में निम्नलिखित भाग होते हैं:</p>

<ul>
  <li><strong>FIN बिट</strong>: यह इंगित करता है कि यह अंतिम फ्रेम है या नहीं।</li>
  <li><strong>Opcode</strong>: यह फ्रेम के प्रकार को निर्दिष्ट करता है (उदाहरण के लिए, टेक्स्ट, बाइनरी, कनेक्शन बंद करना)।</li>
  <li><strong>Mask बिट</strong>: यह इंगित करता है कि डेटा मास्क किया गया है या नहीं।</li>
  <li><strong>Payload लंबाई</strong>: यह डेटा की लंबाई को निर्दिष्ट करता है।</li>
  <li><strong>Payload डेटा</strong>: वास्तविक डेटा जो ट्रांसमिट किया जा रहा है।</li>
</ul>

<h4 id="websocket-उपयोग-के-उदाहरण">WebSocket उपयोग के उदाहरण:</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// क्लाइंट साइड JavaScript उदाहरण</span>
<span class="kd">const</span> <span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws://example.com/socket</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">WebSocket कनेक्शन स्थापित</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello Server!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">socket</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">सर्वर से प्राप्त संदेश: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">socket</span><span class="p">.</span><span class="nx">onclose</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">WebSocket कनेक्शन बंद</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># सर्वर साइड Python उदाहरण (websockets लाइब्रेरी का उपयोग करके)
</span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">websockets</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">websocket</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">websocket</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">websocket</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="n">start_server</span> <span class="o">=</span> <span class="n">websockets</span><span class="p">.</span><span class="n">serve</span><span class="p">(</span><span class="n">echo</span><span class="p">,</span> <span class="s">"localhost"</span><span class="p">,</span> <span class="mi">8765</span><span class="p">)</span>

<span class="n">asyncio</span><span class="p">.</span><span class="n">get_event_loop</span><span class="p">().</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">start_server</span><span class="p">)</span>
<span class="n">asyncio</span><span class="p">.</span><span class="n">get_event_loop</span><span class="p">().</span><span class="n">run_forever</span><span class="p">()</span>
</code></pre></div></div>

<p>WebSocket प्रोटोकॉल का उपयोग करके, डेवलपर्स अधिक कुशल और रीयल-टाइम संचार सुविधाओं वाले एप्लिकेशन बना सकते हैं।</p>

<p>WebSocket TCP पर चलता है और इसमें कई सुधार शामिल हैं:</p>
<ul>
  <li><strong>सुरक्षा मॉडल:</strong> ब्राउज़र-आधारित स्रोत सुरक्षा सत्यापन मॉडल को जोड़ा गया है।</li>
  <li><strong>पता और प्रोटोकॉल नामकरण:</strong> एकल पोर्ट पर कई सेवाओं और एकल IP पते पर कई डोमेन नामों का समर्थन करता है।</li>
  <li><strong>फ्रेम मैकेनिज्म:</strong> IP पैकेट के समान फ्रेम मैकेनिज्म के माध्यम से TCP को बढ़ाया गया है, जिसकी कोई लंबाई सीमा नहीं है।</li>
  <li><strong>बंद करने की प्रक्रिया:</strong> कनेक्शन को साफ तरीके से बंद करने की सुनिश्चितता प्रदान करता है।</li>
</ul>

<h3 id="websocket-प्रोटोकॉल-का-मूल">WebSocket प्रोटोकॉल का मूल</h3>

<p>WebSocket प्रोटोकॉल एक ऐसा प्रोटोकॉल है जो क्लाइंट और सर्वर के बीच द्विदिश संचार (bidirectional communication) को सक्षम बनाता है। यह HTTP प्रोटोकॉल पर आधारित है, लेकिन इसे इस तरह से डिज़ाइन किया गया है कि यह कनेक्शन को लंबे समय तक खुला रख सकता है और डेटा को कम ओवरहेड के साथ ट्रांसमिट कर सकता है। WebSocket प्रोटोकॉल के कुछ मुख्य तत्व निम्नलिखित हैं:</p>

<ol>
  <li>
    <p><strong>हैंडशेक (Handshake):</strong>
WebSocket कनेक्शन की शुरुआत एक HTTP हैंडशेक से होती है। क्लाइंट एक HTTP अनुरोध (request) भेजता है जिसमें <code class="language-plaintext highlighter-rouge">Upgrade: websocket</code> हेडर शामिल होता है। यदि सर्वर WebSocket कनेक्शन को स्वीकार करता है, तो यह एक HTTP प्रतिक्रिया (response) भेजता है जिसमें <code class="language-plaintext highlighter-rouge">101 Switching Protocols</code> स्टेटस कोड होता है।</p>
  </li>
  <li>
    <p><strong>फ्रेमिंग (Framing):</strong>
WebSocket डेटा को फ्रेम्स (frames) के रूप में ट्रांसमिट करता है। प्रत्येक फ्रेम में एक छोटा हेडर होता है जो डेटा के प्रकार और लंबाई को निर्दिष्ट करता है। यह फ्रेमिंग मैकेनिज्म WebSocket को डेटा को कुशलतापूर्वक ट्रांसमिट करने में सक्षम बनाता है।</p>
  </li>
  <li>
    <p><strong>द्विदिश संचार (Bidirectional Communication):</strong>
एक बार कनेक्शन स्थापित हो जाने के बाद, क्लाइंट और सर्वर दोनों किसी भी समय डेटा भेज और प्राप्त कर सकते हैं। यह HTTP के अनुरोध-प्रतिक्रिया मॉडल से अलग है, जहां क्लाइंट को हमेशा अनुरोध शुरू करना पड़ता है।</p>
  </li>
  <li>
    <p><strong>कनेक्शन क्लोजिंग (Connection Closing):</strong>
WebSocket कनेक्शन को बंद करने के लिए, क्लाइंट या सर्वर एक क्लोज फ्रेम (close frame) भेज सकते हैं। यह फ्रेम कनेक्शन को सुरक्षित रूप से बंद करने के लिए उपयोग किया जाता है।</p>
  </li>
  <li>
    <p><strong>सुरक्षा (Security):</strong>
WebSocket प्रोटोकॉल में सुरक्षा के लिए TLS/SSL का उपयोग किया जा सकता है, जिसे WebSocket Secure (WSS) कहा जाता है। यह डेटा को एन्क्रिप्ट करके सुरक्षित संचार सुनिश्चित करता है।</p>
  </li>
</ol>

<p>WebSocket प्रोटोकॉल का उपयोग वास्तविक समय (real-time) एप्लिकेशन जैसे चैट एप्लिकेशन, ऑनलाइन गेमिंग, और वित्तीय ट्रेडिंग प्लेटफॉर्म में व्यापक रूप से किया जाता है। यह प्रोटोकॉल कम लेटेंसी और उच्च प्रदर्शन वाले संचार को सक्षम बनाता है।</p>

<p><strong>1. हैंडशेक:</strong>
   WebSocket हैंडशेक HTTP अपग्रेड मैकेनिज्म का उपयोग करता है:</p>
<ul>
  <li><strong>क्लाइंट अनुरोध:</strong>
    <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/chat</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">server.example.com</span>
<span class="na">Upgrade</span><span class="p">:</span> <span class="s">websocket</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Upgrade</span>
<span class="na">Sec-WebSocket-Key</span><span class="p">:</span> <span class="s">dGhlIHNhbXBsZSBub25jZQ==</span>
<span class="na">Origin</span><span class="p">:</span> <span class="s">http://example.com</span>
<span class="na">Sec-WebSocket-Protocol</span><span class="p">:</span> <span class="s">chat, superchat</span>
<span class="na">Sec-WebSocket-Version</span><span class="p">:</span> <span class="s">13</span>
</code></pre></div>    </div>
  </li>
  <li><strong>सर्वर प्रतिक्रिया:</strong>
    <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">101</span> <span class="ne">Switching Protocols</span>
<span class="na">Upgrade</span><span class="p">:</span> <span class="s">websocket</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Upgrade</span>
<span class="na">Sec-WebSocket-Accept</span><span class="p">:</span> <span class="s">s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span>
<span class="na">Sec-WebSocket-Protocol</span><span class="p">:</span> <span class="s">chat</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>2. डेटा ट्रांसमिशन:</strong>
   WebSocket फ्रेम में UTF-8 टेक्स्ट, बाइनरी डेटा और कंट्रोल फ्रेम, जैसे कि बंद करना, पिंग और पोंग, शामिल हो सकते हैं।</p>

<p><strong>3. सुरक्षा:</strong>
   ब्राउज़र स्वचालित रूप से <code class="language-plaintext highlighter-rouge">Origin</code> हेडर जोड़ता है, जिसे अन्य क्लाइंट द्वारा नकली नहीं बनाया जा सकता है।</p>

<h3 id="websocket-uri">WebSocket URI</h3>

<ul>
  <li><strong>ws-URI:</strong> <code class="language-plaintext highlighter-rouge">ws://host:port/path?query</code></li>
  <li><strong>wss-URI:</strong> <code class="language-plaintext highlighter-rouge">wss://host:port/path?query</code></li>
</ul>

<h3 id="websocket-फ्रेम-प्रोटोकॉल">WebSocket फ्रेम प्रोटोकॉल</h3>

<p><strong>फ्रेम संरचना:</strong></p>
<ul>
  <li><strong>FIN (1 बिट):</strong> यह संदेश का अंतिम टुकड़ा है यह दर्शाता है।</li>
  <li><strong>RSV1, RSV2, RSV3 (प्रत्येक 1 बिट):</strong> भविष्य में उपयोग के लिए आरक्षित।</li>
  <li><strong>Opcode (4 बिट):</strong> पेलोड डेटा को कैसे पार्स करना है यह परिभाषित करता है।
    <ul>
      <li><code class="language-plaintext highlighter-rouge">0x0:</code> जारी फ्रेम</li>
      <li><code class="language-plaintext highlighter-rouge">0x1:</code> टेक्स्ट फ्रेम</li>
      <li><code class="language-plaintext highlighter-rouge">0x2:</code> बाइनरी फ्रेम</li>
      <li><code class="language-plaintext highlighter-rouge">0x8:</code> कनेक्शन बंद</li>
      <li><code class="language-plaintext highlighter-rouge">0x9:</code> पिंग</li>
      <li><code class="language-plaintext highlighter-rouge">0xA:</code> पोंग</li>
    </ul>
  </li>
  <li><strong>Mask (1 बिट):</strong> यह दर्शाता है कि पेलोड डेटा मास्क किया गया है या नहीं।</li>
  <li><strong>पेलोड लंबाई (7 बिट):</strong> पेलोड डेटा की लंबाई।</li>
</ul>

<p><strong>मास्किंग कुंजी (Masking Key):</strong> यह मध्यस्थ हमलों (Man-in-the-Middle Attacks) को रोकने के लिए क्लाइंट के फ्रेम को मास्क करने के लिए उपयोग की जाती है।</p>

<h3 id="हैंडशेक-बंद-करना">हैंडशेक बंद करना</h3>

<p><strong>बंद फ्रेम (Close Frame):</strong></p>
<ul>
  <li>इसमें बंद होने के कारण को दर्शाने वाला बॉडी शामिल हो सकता है।</li>
  <li>दोनों पक्षों को बंद फ्रेम भेजना और उसका जवाब देना आवश्यक है।</li>
</ul>

<h3 id="उदाहरण">उदाहरण</h3>

<p><strong>उदाहरण 1: बिना मास्क वाला सिंगल फ्रेम टेक्स्ट संदेश</strong></p>
<pre><code class="language-hex">0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f
</code></pre>
<p>इसमें “Hello” शामिल है।</p>

<p><strong>उदाहरण 2: सिंगल फ्रेम मास्क किए गए टेक्स्ट संदेश</strong></p>
<pre><code class="language-hex">0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58
</code></pre>
<p>इसमें “Hello” शामिल है, जो मास्क कुंजी के साथ है।</p>

<p><strong>उदाहरण 3: शार्डेड अनमास्क टेक्स्ट संदेश</strong></p>
<pre><code class="language-hex">0x01 0x03 0x48 0x65 0x6c
0x80 0x02 0x6c 0x6f
</code></pre>
<p>शार्ड में “Hel” और “lo” दो फ्रेम शामिल हैं।</p>

<h3 id="उन्नत-विषय">उन्नत विषय</h3>

<p><strong>मास्किंग और अनमास्किंग:</strong></p>
<ul>
  <li>मास्किंग का उपयोग मध्यम व्यक्ति हमलों को रोकने के लिए किया जाता है।</li>
  <li>क्लाइंट से आने वाले प्रत्येक फ्रेम को मास्क किया जाना चाहिए।</li>
  <li>प्रत्येक फ्रेम के लिए मास्क कुंजी यादृच्छिक रूप से चुनी जाती है।</li>
</ul>

<p><strong>शार्डिंग (Sharding):</strong></p>
<ul>
  <li>अज्ञात लंबाई के डेटा को भेजने के लिए उपयोग किया जाता है।</li>
  <li>शार्डेड संदेश FIN 0 वाले फ्रेम से शुरू होता है और FIN 1 वाले फ्रेम पर समाप्त होता है।</li>
</ul>

<p><strong>कंट्रोल फ्रेम:</strong></p>
<ul>
  <li>कंट्रोल फ्रेम (जैसे कि बंद करना, पिंग और पोंग) के लिए विशिष्ट ऑपकोड होते हैं।</li>
  <li>ये फ्रेम WebSocket कनेक्शन की स्थिति को प्रबंधित करने के लिए उपयोग किए जाते हैं।</li>
</ul>

<h3 id="विस्तारणीयता-scalability">विस्तारणीयता (Scalability)</h3>

<p><strong>एक्सटेंशन डेटा को मैसेज बॉडी के एप्लिकेशन डेटा से पहले रखा जा सकता है:</strong></p>
<ul>
  <li>प्रत्येक फ्रेम को नियंत्रित करने के लिए रिजर्व्ड बिट्स का उपयोग किया जा सकता है।</li>
  <li>भविष्य में परिभाषित करने के लिए कुछ ऑपकोड रिजर्व किए जा सकते हैं।</li>
  <li>यदि अधिक ऑपकोड की आवश्यकता हो, तो रिजर्व्ड बिट्स का उपयोग किया जा सकता है।</li>
</ul>

<p><strong>भेजें:</strong></p>
<ul>
  <li>कनेक्शन OPEN स्थिति में होना चाहिए।</li>
  <li>डेटा को फ्रेम में एनकैप्सुलेट किया जाता है, और डेटा बड़ा होने पर इसे टुकड़ों में भेजने का विकल्प चुना जा सकता है।</li>
  <li>पहले फ्रेम का मान सही होना चाहिए, जो प्राप्तकर्ता को डेटा प्रकार (टेक्स्ट या बाइनरी) बताता है।</li>
  <li>अंतिम फ्रेम का FIN 1 पर सेट होना चाहिए।</li>
</ul>

<p><strong>हैंडशेक बंद करना:</strong></p>
<ul>
  <li>दोनों पक्ष बंद करने का फ्रेम भेज सकते हैं।</li>
  <li>बंद करने का फ्रेम भेजने के बाद, कोई और डेटा नहीं भेजा जाता है।</li>
  <li>बंद करने का फ्रेम प्राप्त करने के बाद, उसके बाद प्राप्त किसी भी डेटा को छोड़ दिया जाता है।</li>
</ul>

<p><strong>कनेक्शन बंद करना:</strong></p>
<ul>
  <li>WebSocket कनेक्शन को बंद करना, जो नीचे के TCP कनेक्शन को बंद करने के बराबर है।</li>
  <li>बंद करने वाला फ्रेम भेजने या प्राप्त करने के बाद, WebSocket कनेक्शन की स्थिति बंद होने की प्रक्रिया में होती है।</li>
  <li>जब नीचे का TCP कनेक्शन बंद हो जाता है, तो WebSocket कनेक्शन की स्थिति बंद हो जाती है।</li>
</ul>

<h3 id="संदर्भ-सामग्री">संदर्भ सामग्री</h3>

<ul>
  <li>WebSocket RFC : <a href="https://tools.ietf.org/html/rfc6455">RFC6455</a></li>
  <li>知乎《WebSocket 是什么原理？》：<a href="https://www.zhihu.com/question/20215561">知乎链接</a></li>
  <li>SocketRocket: <a href="https://github.com/square/SocketRocket">GitHub链接</a></li>
</ul>

<h3 id="आभार">आभार</h3>
<p>सभी का धन्यवाद। यदि आपके पास और प्रश्न या चर्चा हैं, तो कृपया GitHub या Weibo पर मुझसे संपर्क करने में संकोच न करें।</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-hi" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
