<!DOCTYPE html>
<html lang=" en-US">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/site.webmanifest">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Zhiwei Li"
    href="https://lzwjava.github.io/feeds/feed.xml" />

  <title>Serveur Simple en Temps Réel (SRS) pour le Streaming RTMP</title>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' 
          data-cf-beacon='{"token": "70fc8c466cc1445098b3fc6f209c22c2"}'>
  </script>

  <!-- 
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66656236-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-66656236-1');
  </script>
   -->
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Serveur Simple en Temps Réel (SRS) pour le Streaming RTMP | Zhiwei Li</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Serveur Simple en Temps Réel (SRS) pour le Streaming RTMP" />
<meta name="author" content="Zhiwei Li" />
<meta property="og:locale" content="fr" />
<meta name="description" content="Plongeons dans l’utilisation de Simple Realtime Server (SRS) pour déployer un serveur de bord pour le streaming RTMP, en mettant l’accent sur la compréhension et la configuration efficace, y compris le fichier rtmp.conf. SRS est un serveur multimédia puissant et haute performance conçu pour les protocoles de streaming en temps réel comme RTMP, HLS et HTTP-FLV. Il est particulièrement bien adapté aux scénarios nécessitant une évolutivité, comme les réseaux de distribution de contenu (CDN), où un serveur de bord peut distribuer efficacement les flux à de nombreux clients tout en récupérant le contenu auprès d’un serveur d’origine. Je vais vous guider étape par étape, expliquer le concept de déploiement de bord et clarifier comment travailler avec des configurations comme rtmp.conf." />
<meta property="og:description" content="Plongeons dans l’utilisation de Simple Realtime Server (SRS) pour déployer un serveur de bord pour le streaming RTMP, en mettant l’accent sur la compréhension et la configuration efficace, y compris le fichier rtmp.conf. SRS est un serveur multimédia puissant et haute performance conçu pour les protocoles de streaming en temps réel comme RTMP, HLS et HTTP-FLV. Il est particulièrement bien adapté aux scénarios nécessitant une évolutivité, comme les réseaux de distribution de contenu (CDN), où un serveur de bord peut distribuer efficacement les flux à de nombreux clients tout en récupérant le contenu auprès d’un serveur d’origine. Je vais vous guider étape par étape, expliquer le concept de déploiement de bord et clarifier comment travailler avec des configurations comme rtmp.conf." />
<link rel="canonical" href="https://lzwjava.github.io/srs-streaming-fr" />
<meta property="og:url" content="https://lzwjava.github.io/srs-streaming-fr" />
<meta property="og:site_name" content="Zhiwei Li" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-06T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Serveur Simple en Temps Réel (SRS) pour le Streaming RTMP" />
<meta name="twitter:site" content="@lzwjava" />
<meta name="twitter:creator" content="@lzwjava" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Zhiwei Li"},"dateModified":"2017-01-06T00:00:00+08:00","datePublished":"2017-01-06T00:00:00+08:00","description":"Plongeons dans l’utilisation de Simple Realtime Server (SRS) pour déployer un serveur de bord pour le streaming RTMP, en mettant l’accent sur la compréhension et la configuration efficace, y compris le fichier rtmp.conf. SRS est un serveur multimédia puissant et haute performance conçu pour les protocoles de streaming en temps réel comme RTMP, HLS et HTTP-FLV. Il est particulièrement bien adapté aux scénarios nécessitant une évolutivité, comme les réseaux de distribution de contenu (CDN), où un serveur de bord peut distribuer efficacement les flux à de nombreux clients tout en récupérant le contenu auprès d’un serveur d’origine. Je vais vous guider étape par étape, expliquer le concept de déploiement de bord et clarifier comment travailler avec des configurations comme rtmp.conf.","headline":"Serveur Simple en Temps Réel (SRS) pour le Streaming RTMP","mainEntityOfPage":{"@type":"WebPage","@id":"https://lzwjava.github.io/srs-streaming-fr"},"url":"https://lzwjava.github.io/srs-streaming-fr"}</script>
<!-- End Jekyll SEO tag -->


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Facebook Meta Tags -->
  <!-- <meta property="og:url" content="https://lzwjava.github.io"> -->
  <meta property="og:type" content="website">
  <!-- <meta property="og:title" content="Zhiwei Li's Blog">
  <meta property="og:description" content="A personal blog featuring programming insights and projects."> -->
  
  
  
  
  
  
  
  
  <meta property="og:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lzwjava">
  <meta property="twitter:domain" content="lzwjava.github.io">
  <!-- <meta property="twitter:url" content="https://lzwjava.github.io"> -->
  <!-- <meta name="twitter:title" content="Zhiwei Li's Blog">
  <meta name="twitter:description" content="A personal blog featuring programming insights and projects."> -->
  <meta name="twitter:image" content="https://lzwjava.github.io/assets/images/og/og4.jpg">


  <link rel="stylesheet" href="/assets/css/style.css?v=907b9bd4e53fa2eb57e018b48c2049bdd3b63df0">

  <!-- for mathjax support -->
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['\\(','\\)'], ['$', '$']],
            displayMath: [ ['$$','$$'], ['\\[','\\]']],
            processEscapes: false
          },
          "HTML-CSS": { linebreaks: { automatic: true } },
          "CommonHTML": {
            linebreaks: { automatic: true }
          },
          TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- <script src="/assets/js/donatePopup.js?v=907b9bd4e53fa2eb57e018b48c2049bdd3b63df0" defer></script> -->
</head>

<body>
  <main id="content" class="main-content post-content" role="main">
  

  

  


  <div class="title-row post-title-row">
    <h2 class="title post-title">
       Serveur Simple en Temps Réel (SRS) pour le Streaming RTMP | Original, traduit par l'IA
    </h2>
  </div>

  <div class="button-container">
    <a href="/" class="button left-button">Home</a>

    <!-- PDF Button -->
     
    <!-- <a href="#" id="downloadPdfButton" class="button pdf-button" data-file-path="_posts/fr/2017-01-06-srs-streaming-fr.md">PDF</a> -->

    <!-- Audio Button -->



    <!--  -->

        <!-- Date Button -->
    
      
      <!-- <span>_postsfr2017-01-06-srs-streaming-fr.md</span> -->
      

      <!-- <span>2017-01-06-srs-streaming-fr.md</span> -->

      
        

        
          
          <a href="#" class="button">2017.01</a>
        

      
    

    <button id="themeTogglePost" class="button icon-button" aria-label="Toggle Theme" style="float: right;margin-bottom: 5px;">
      <!-- theme-icons.html -->
<svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

<svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
    <path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"></path>
</svg>
    </button>    

    <!-- Language Select Section -->
    
    
    
    
    
    
    

    
    <select id="languageSelect" class="button right-button">
        
        <option value="/srs-streaming-en" >English</option>
        <option value="/srs-streaming-zh" >中文</option>
        <option value="/srs-streaming-ja" >日本語</option>
        <option value="/srs-streaming-es" >Español</option>
        <option value="/srs-streaming-hi" >हिंदी</option>
        <option value="/srs-streaming-fr" selected>Français</option>
        <option value="/srs-streaming-de" >Deutsch</option>
        <option value="/srs-streaming-ar" >العربية</option>
        <option value="/srs-streaming-hant" >繁體中文</option>
    </select>
  </div>

  <!-- Audio player for text-to-speech -->
  <div class="audio-container">
    <audio id="audioPlayer" controls loop style="display:none;">
      <source id="audioSource" src="" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>

  <hr>

  <p>Plongeons dans l’utilisation de Simple Realtime Server (SRS) pour déployer un serveur de bord pour le streaming RTMP, en mettant l’accent sur la compréhension et la configuration efficace, y compris le fichier <code class="language-plaintext highlighter-rouge">rtmp.conf</code>. SRS est un serveur multimédia puissant et haute performance conçu pour les protocoles de streaming en temps réel comme RTMP, HLS et HTTP-FLV. Il est particulièrement bien adapté aux scénarios nécessitant une évolutivité, comme les réseaux de distribution de contenu (CDN), où un serveur de bord peut distribuer efficacement les flux à de nombreux clients tout en récupérant le contenu auprès d’un serveur d’origine. Je vais vous guider étape par étape, expliquer le concept de déploiement de bord et clarifier comment travailler avec des configurations comme <code class="language-plaintext highlighter-rouge">rtmp.conf</code>.</p>

<h3 id="quest-ce-que-srs-et-le-déploiement-de-bord-">Qu’est-ce que SRS et le déploiement de bord ?</h3>
<p>SRS est un serveur open-source conçu pour gérer le streaming multimédia en temps réel avec un accent sur la simplicité et l’efficacité. Il prend en charge RTMP (Real-Time Messaging Protocol) pour le streaming en direct à faible latence, ainsi que d’autres protocoles comme HLS et WebRTC. Dans SRS, un serveur de “bord” agit comme intermédiaire entre les clients (spectateurs ou diffuseurs) et un serveur d’“origine” (d’où provient le flux). Le bord récupère les flux auprès de l’origine uniquement lorsqu’ils sont demandés par les clients, réduisant ainsi la charge sur l’origine et permettant une distribution évolutive—pensez-y comme à une couche de mise en cache de CDN adaptée pour les flux en direct.</p>

<p>Déployer un serveur de bord avec SRS est idéal lorsque vous avez besoin de :</p>
<ul>
  <li>Servir un grand nombre de spectateurs sans submerger l’origine.</li>
  <li>Permettre aux diffuseurs de pousser des flux vers le bord, qui les transfère ensuite vers l’origine.</li>
  <li>Minimiser l’utilisation de la bande passante sur les serveurs d’origine coûteux en utilisant des nœuds de bord moins chers.</li>
</ul>

<h3 id="étape-par-étape--déployer-un-serveur-de-bord-avec-srs-pour-rtmp">Étape par étape : Déployer un serveur de bord avec SRS pour RTMP</h3>
<p>Voici comment configurer SRS en tant que serveur de bord pour le streaming RTMP. Je suppose que vous travaillez sur un système Linux (par exemple, Ubuntu), car SRS est optimisé pour ces environnements.</p>

<h4 id="1-installer-srs">1. Installer SRS</h4>
<p>Tout d’abord, vous devez faire fonctionner SRS sur votre machine :</p>
<ul>
  <li><strong>Télécharger SRS</strong> : Obtenez la dernière version stable à partir du dépôt GitHub officiel (github.com/ossrs/srs). À ce jour, le 26 février 2025, vous cloneriez généralement le dépôt :
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/ossrs/srs.git
cd srs
</code></pre></div>    </div>
  </li>
  <li><strong>Compiler SRS</strong> : SRS utilise un processus de compilation simple avec <code class="language-plaintext highlighter-rouge">./configure</code> et <code class="language-plaintext highlighter-rouge">make</code> :
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./configure
make
</code></pre></div>    </div>
    <p>Cela compile le serveur dans le répertoire <code class="language-plaintext highlighter-rouge">objs</code> (par exemple, <code class="language-plaintext highlighter-rouge">objs/srs</code>).</p>
  </li>
  <li><strong>Tester le binaire</strong> : Exécutez-le avec la configuration par défaut pour vous assurer qu’il fonctionne :
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./objs/srs -c conf/srs.conf
</code></pre></div>    </div>
    <p>Par défaut, il écoute sur le port 1935 pour RTMP. Vérifiez la sortie de la console pour confirmation.</p>
  </li>
</ul>

<h4 id="2-comprendre-le-concept-de-bord">2. Comprendre le concept de bord</h4>
<p>Dans SRS, un serveur de bord fonctionne en mode “remote”, ce qui signifie qu’il ne génère pas de flux lui-même mais les récupère auprès d’un serveur d’origine lorsqu’un client les demande (pour la lecture) ou pousse des flux vers l’origine (pour la diffusion). Cette récupération à la demande est ce qui rend les serveurs de bord efficaces pour la mise à l’échelle de la distribution RTMP.</p>

<ul>
  <li><strong>Serveur d’origine</strong> : La source du flux (par exemple, là où un encodeur comme OBS pousse un flux RTMP).</li>
  <li><strong>Serveur de bord</strong> : Un relais auquel les clients se connectent, récupérant auprès de l’origine uniquement lorsque cela est nécessaire.</li>
</ul>

<p>Pour cet exemple, supposons que vous avez déjà un serveur d’origine exécutant SRS à <code class="language-plaintext highlighter-rouge">192.168.1.100:1935</code> (remplacez ceci par votre adresse IP d’origine réelle).</p>

<h4 id="3-configurer-le-serveur-de-bord">3. Configurer le serveur de bord</h4>
<p>SRS utilise des fichiers de configuration pour définir son comportement. Le <code class="language-plaintext highlighter-rouge">srs.conf</code> par défaut est un bon point de départ, mais pour le déploiement de bord, vous créerez une configuration spécifique—appelons-la <code class="language-plaintext highlighter-rouge">edge.conf</code>. Voici comment la configurer :</p>

<ul>
  <li><strong>Créer <code class="language-plaintext highlighter-rouge">edge.conf</code></strong> :
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd conf
nano edge.conf
</code></pre></div>    </div>
  </li>
  <li><strong>Ajouter la configuration de bord</strong> :
Voici un <code class="language-plaintext highlighter-rouge">edge.conf</code> minimal pour le déploiement de bord RTMP :
    <div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">listen</span>              <span class="m">1935</span>;
<span class="n">max_connections</span>     <span class="m">1000</span>;
<span class="n">srs_log_tank</span>        <span class="n">file</span>;
<span class="n">srs_log_file</span>        ./<span class="n">objs</span>/<span class="n">edge</span>.<span class="n">log</span>;
<span class="n">vhost</span> <span class="err">__</span><span class="n">defaultVhost__</span> {
    <span class="n">cluster</span> {
        <span class="n">mode</span>        <span class="n">remote</span>;
        <span class="n">origin</span>      <span class="m">192</span>.<span class="m">168</span>.<span class="m">1</span>.<span class="m">100</span>:<span class="m">1935</span>;
    }
}
</code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">listen 1935</code> : Le bord écoute les connexions RTMP sur le port 1935.</li>
      <li><code class="language-plaintext highlighter-rouge">max_connections 1000</code> : Limite les connexions simultanées (ajustez en fonction de la capacité de votre serveur).</li>
      <li><code class="language-plaintext highlighter-rouge">srs_log_file</code> : Journaux dans un fichier pour le débogage.</li>
      <li><code class="language-plaintext highlighter-rouge">vhost __defaultVhost__</code> : La configuration de l’hôte virtuel par défaut.</li>
      <li><code class="language-plaintext highlighter-rouge">cluster { mode remote; origin 192.168.1.100:1935; }</code> : Définit ce serveur comme un bord (<code class="language-plaintext highlighter-rouge">mode remote</code>) et le pointe vers le serveur d’origine.</li>
    </ul>
  </li>
  <li><strong>Enregistrer et quitter</strong> : Ctrl+O, Entrée, Ctrl+X dans nano.</li>
</ul>

<h4 id="4-démarrer-le-serveur-de-bord">4. Démarrer le serveur de bord</h4>
<p>Exécutez SRS avec votre configuration de bord :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./objs/srs -c conf/edge.conf
</code></pre></div></div>
<p>Vérifiez les journaux (<code class="language-plaintext highlighter-rouge">./objs/edge.log</code>) pour confirmer qu’il fonctionne et est connecté à l’origine.</p>

<h4 id="5-tester-la-configuration">5. Tester la configuration</h4>
<ul>
  <li><strong>Publier un flux</strong> : Utilisez un outil comme OBS ou FFmpeg pour pousser un flux RTMP vers le serveur d’origine :
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffmpeg -re -i input.mp4 -c copy -f flv rtmp://192.168.1.100/live/livestream
</code></pre></div>    </div>
    <p>Ici, <code class="language-plaintext highlighter-rouge">live</code> est le nom de l’application et <code class="language-plaintext highlighter-rouge">livestream</code> est la clé de flux.</p>
  </li>
  <li><strong>Lire depuis le bord</strong> : Utilisez VLC ou un autre client RTMP pour lire le flux depuis le bord :
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rtmp://&lt;edge-server-ip&gt;/live/livestream
</code></pre></div>    </div>
    <p>Remplacez <code class="language-plaintext highlighter-rouge">&lt;edge-server-ip&gt;</code> par l’IP de votre serveur de bord (par exemple, <code class="language-plaintext highlighter-rouge">192.168.1.101</code>). Le bord récupérera le flux auprès de l’origine et le servira.</p>
  </li>
</ul>

<h4 id="6-explorer-rtmpconf">6. Explorer <code class="language-plaintext highlighter-rouge">rtmp.conf</code></h4>
<p>SRS ne fournit pas de fichier <code class="language-plaintext highlighter-rouge">rtmp.conf</code> par défaut, mais vous pourriez rencontrer des références à celui-ci dans des tutoriels ou des configurations personnalisées. Il s’agit essentiellement d’une convention de nommage pour un fichier de configuration spécifique à RTMP. Par exemple, la documentation SRS (ossrs.net) fournit un exemple de <code class="language-plaintext highlighter-rouge">rtmp.conf</code> pour le streaming RTMP en temps réel :</p>
<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">listen</span>              <span class="m">1935</span>;
<span class="n">max_connections</span>     <span class="m">1000</span>;
<span class="n">vhost</span> <span class="err">__</span><span class="n">defaultVhost__</span> {
    <span class="n">tcp_nodelay</span>     <span class="n">on</span>;
    <span class="n">min_latency</span>     <span class="n">on</span>;
    <span class="n">play</span> {
        <span class="n">gop_cache</span>   <span class="n">off</span>;
        <span class="n">queue_length</span> <span class="m">10</span>;
    }
    <span class="n">publish</span> {
        <span class="n">mr</span>          <span class="n">off</span>;
    }
}
</code></pre></div></div>
<ul>
  <li><strong>But</strong> : Cette configuration optimise pour le streaming RTMP à faible latence sur un serveur d’origine, pas un bord. Pour le déploiement de bord, vous l’adapteriez en ajoutant le bloc <code class="language-plaintext highlighter-rouge">cluster</code> de l’étape 3.</li>
  <li><strong>Paramètres clés</strong> :
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tcp_nodelay on</code> : Réduit la latence en désactivant l’algorithme de Nagle.</li>
      <li><code class="language-plaintext highlighter-rouge">min_latency on</code> : Priorise la faible latence sur la mise en mémoire tampon.</li>
      <li><code class="language-plaintext highlighter-rouge">gop_cache off</code> : Désactive la mise en cache du Groupe d’Images pour la lecture en temps réel.</li>
      <li><code class="language-plaintext highlighter-rouge">mr off</code> : Désactive “merge read” pour éviter les retards dans la publication.</li>
    </ul>
  </li>
</ul>

<p>Pour un bord, vous combineriez cela avec les paramètres <code class="language-plaintext highlighter-rouge">cluster</code> plutôt que de l’utiliser seul.</p>

<h3 id="expliquer-plus--mécanismes-de-bord-et-rtmp">Expliquer plus : Mécanismes de bord et RTMP</h3>
<ul>
  <li><strong>Comment fonctionne le bord</strong> : Lorsqu’un client demande <code class="language-plaintext highlighter-rouge">rtmp://&lt;edge-ip&gt;/live/livestream</code>, le bord vérifie s’il dispose du flux. Si ce n’est pas le cas, il le récupère auprès de l’origine (<code class="language-plaintext highlighter-rouge">192.168.1.100:1935</code>) et le met en cache localement pour servir d’autres clients. Si un diffuseur pousse vers le bord, il transfère le flux vers l’origine.</li>
  <li><strong>Spécificités RTMP</strong> : RTMP est un protocole à faible latence idéal pour le streaming en direct. SRS gère RTMP efficacement, prenant en charge des fonctionnalités comme le codage temporel absolu (ATC) pour la synchronisation entre serveurs, bien que cela soit désactivé par défaut en mode bord sauf spécification.</li>
  <li><strong>Évolutivité</strong> : Ajoutez plusieurs bords pointant vers la même origine pour gérer des milliers de clients. SRS prend en charge la bascule en listant plusieurs origines (par exemple, <code class="language-plaintext highlighter-rouge">origin 192.168.1.100:1935 192.168.1.200:1935;</code>).</li>
</ul>

<h3 id="conseils-et-dépannage">Conseils et dépannage</h3>
<ul>
  <li><strong>Pare-feu</strong> : Assurez-vous que le port 1935 est ouvert sur les serveurs d’origine et de bord.</li>
  <li><strong>Journaux</strong> : Vérifiez <code class="language-plaintext highlighter-rouge">edge.log</code> pour des erreurs comme des échecs de connexion à l’origine.</li>
  <li><strong>Latence</strong> : Le bord ajoute une latence minimale (généralement &lt;1s) si l’origine est également à faible latence.</li>
  <li><strong>Multiples bords</strong> : Déployez des bords supplémentaires avec la même configuration, ajustant les ports <code class="language-plaintext highlighter-rouge">listen</code> ou les IPs si nécessaire.</li>
</ul>

<h3 id="conclusion">Conclusion</h3>
<p>Déployer un serveur de bord SRS pour RTMP est simple une fois que vous comprenez la relation origine-bord. Le <code class="language-plaintext highlighter-rouge">edge.conf</code> configure le bord pour récupérer ou pousser des flux dynamiquement, tandis qu’une configuration de type <code class="language-plaintext highlighter-rouge">rtmp.conf</code> pourrait affiner les performances RTMP si nécessaire. Avec cette configuration, vous êtes prêt à évoluer efficacement le streaming en direct—que ce soit pour quelques spectateurs ou un public mondial. Vous souhaitez l’ajuster davantage ou intégrer HLS en plus de RTMP ? Faites-le moi savoir !</p>


  <hr>

  <div class="button-container">
    <a href="/" class="button left-button">Back</a>


    

    
    
    <a href="/donate-fr" class="button right-button">Donate</a>
  </div>
</main>

<script src="/assets/js/dark-mode.js"></script>
<script src="/assets/js/audio.js" defer></script>
<script src="/assets/js/pdf.js" defer></script>
<script>
    document.getElementById('languageSelect').addEventListener('change', function() {
        var selectedValue = this.value;
        if (selectedValue) {
            window.location.href = selectedValue;
        }
    });
</script>

</body>

</html>
